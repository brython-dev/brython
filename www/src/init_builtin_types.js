/* generated by D:\brython\20221025\scripts\get_info_from_cpython.py */
(function($B){
var _b_ = $B.builtins
_b_.object = Object.create(null)
Object.assign(_b_.object,
{
    tp_name: "object",
    tp_basicsize: 16,
    tp_itersize: 0,
    tp_flags: 5378,
    tp_weakrefoffset: 0,
    tp_dictoffset: 0,
    tp_doc: `The base class of the class hierarchy.

When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.
`,
    tp_bases: [],
})

_b_.BaseException = Object.create(null)
Object.assign(_b_.BaseException,
{
    tp_name: "BaseException",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 16,
    tp_doc: `Common base class for all exceptions`,
    tp_bases: [_b_.object],
})

_b_.bytearray = Object.create(null)
Object.assign(_b_.bytearray,
{
    tp_name: "bytearray",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 4199682,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `bytearray(iterable_of_ints) -> bytearray
bytearray(string, encoding[, errors]) -> bytearray
bytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer
bytearray(int) -> bytes array of size given by the parameter initialized with null bytes
bytearray() -> empty bytes array

Construct a mutable bytearray object from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - a bytes or a buffer object
  - any object implementing the buffer API.
  - an integer`,
    tp_bases: [_b_.object],
})

_b_.bytes = Object.create(null)
Object.assign(_b_.bytes,
{
    tp_name: "bytes",
    tp_basicsize: 33,
    tp_itersize: 1,
    tp_flags: 138417410,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer`,
    tp_bases: [_b_.object],
})

_b_.classmethod = Object.create(null)
Object.assign(_b_.classmethod,
{
    tp_name: "classmethod",
    tp_basicsize: 32,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 24,
    tp_doc: `Convert a function to be a class method.

A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:

  class C:
      @classmethod
      def f(cls, arg1, arg2, argN):
          ...

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.

Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.`,
    tp_bases: [_b_.object],
})

_b_.complex = Object.create(null)
Object.assign(_b_.complex,
{
    tp_name: "complex",
    tp_basicsize: 32,
    tp_itersize: 0,
    tp_flags: 5378,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Create a complex number from a string or numbers.

If a string is given, parse it as a complex number.
If a single number is given, convert it to a complex number.
If the 'real' or 'imag' arguments are given, create a complex number
with the specified real and imaginary components.`,
    tp_bases: [_b_.object],
})

_b_.dict = Object.create(null)
Object.assign(_b_.dict,
{
    tp_name: "dict",
    tp_basicsize: 48,
    tp_itersize: 0,
    tp_flags: 541087042,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)`,
    tp_bases: [_b_.object],
})

_b_.enumerate = Object.create(null)
Object.assign(_b_.enumerate,
{
    tp_name: "enumerate",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Return an enumerate object.

  iterable
    an object supporting iteration

The enumerate object yields pairs containing a count (from start, which
defaults to zero) and a value yielded by the iterable argument.

enumerate is useful for obtaining an indexed list:
    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...`,
    tp_bases: [_b_.object],
})

_b_.filter = Object.create(null)
Object.assign(_b_.filter,
{
    tp_name: "filter",
    tp_basicsize: 32,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Return an iterator yielding those items of iterable for which function(item)
is true. If function is None, return the items that are true.`,
    tp_bases: [_b_.object],
})

_b_.float = Object.create(null)
Object.assign(_b_.float,
{
    tp_name: "float",
    tp_basicsize: 24,
    tp_itersize: 0,
    tp_flags: 4199682,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Convert a string or number to a floating-point number, if possible.`,
    tp_bases: [_b_.object],
})

_b_.frozenset = Object.create(null)
Object.assign(_b_.frozenset,
{
    tp_name: "frozenset",
    tp_basicsize: 200,
    tp_itersize: 0,
    tp_flags: 4216066,
    tp_weakrefoffset: 192,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Build an immutable unordered collection of unique elements.`,
    tp_bases: [_b_.object],
})

_b_.int = Object.create(null)
Object.assign(_b_.int,
{
    tp_name: "int",
    tp_basicsize: 24,
    tp_itersize: 4,
    tp_flags: 20976898,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating-point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4`,
    tp_bases: [_b_.object],
})

_b_.list = Object.create(null)
Object.assign(_b_.list,
{
    tp_name: "list",
    tp_basicsize: 40,
    tp_itersize: 0,
    tp_flags: 37770530,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.`,
    tp_bases: [_b_.object],
})

_b_.map = Object.create(null)
Object.assign(_b_.map,
{
    tp_name: "map",
    tp_basicsize: 40,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Make an iterator that computes the function using arguments from
each of the iterables.  Stops when the shortest iterable is exhausted.

If strict is true and one of the arguments is exhausted before the others,
raise a ValueError.`,
    tp_bases: [_b_.object],
})

_b_.memoryview = Object.create(null)
Object.assign(_b_.memoryview,
{
    tp_name: "memoryview",
    tp_basicsize: 144,
    tp_itersize: 8,
    tp_flags: 20770,
    tp_weakrefoffset: 136,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Create a new memoryview object which references the given object.`,
    tp_bases: [_b_.object],
})

_b_.property = Object.create(null)
Object.assign(_b_.property,
{
    tp_name: "property",
    tp_basicsize: 64,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Property attribute.

  fget
    function to be used for getting an attribute value
  fset
    function to be used for setting an attribute value
  fdel
    function to be used for del'ing an attribute
  doc
    docstring

Typical use is to define a managed attribute x:

class C(object):
    def getx(self): return self._x
    def setx(self, value): self._x = value
    def delx(self): del self._x
    x = property(getx, setx, delx, "I'm the 'x' property.")

Decorators make defining new properties or modifying existing ones easy:

class C(object):
    @property
    def x(self):
        "I am the 'x' property."
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x`,
    tp_bases: [_b_.object],
})

_b_.range = Object.create(null)
Object.assign(_b_.range,
{
    tp_name: "range",
    tp_basicsize: 48,
    tp_itersize: 0,
    tp_flags: 4386,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `range(stop) -> range object
range(start, stop[, step]) -> range object

Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).`,
    tp_bases: [_b_.object],
})

_b_.reversed = Object.create(null)
Object.assign(_b_.reversed,
{
    tp_name: "reversed",
    tp_basicsize: 32,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Return a reverse iterator over the values of the given sequence.`,
    tp_bases: [_b_.object],
})

_b_.set = Object.create(null)
Object.assign(_b_.set,
{
    tp_name: "set",
    tp_basicsize: 200,
    tp_itersize: 0,
    tp_flags: 4216066,
    tp_weakrefoffset: 192,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Build an unordered collection of unique elements.`,
    tp_bases: [_b_.object],
})

_b_.slice = Object.create(null)
Object.assign(_b_.slice,
{
    tp_name: "slice",
    tp_basicsize: 40,
    tp_itersize: 0,
    tp_flags: 20738,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `slice(stop)
slice(start, stop[, step])

Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).`,
    tp_bases: [_b_.object],
})

_b_.staticmethod = Object.create(null)
Object.assign(_b_.staticmethod,
{
    tp_name: "staticmethod",
    tp_basicsize: 32,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 24,
    tp_doc: `Convert a function to be a static method.

A static method does not receive an implicit first argument.
To declare a static method, use this idiom:

     class C:
         @staticmethod
         def f(arg1, arg2, argN):
             ...

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()). Both the class and the instance are ignored, and
neither is passed implicitly as the first argument to the method.

Static methods in Python are similar to those found in Java or C++.
For a more advanced concept, see the classmethod builtin.`,
    tp_bases: [_b_.object],
})

_b_.str = Object.create(null)
Object.assign(_b_.str,
{
    tp_name: "str",
    tp_basicsize: 64,
    tp_itersize: 0,
    tp_flags: 272635138,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to 'utf-8'.
errors defaults to 'strict'.`,
    tp_bases: [_b_.object],
})

_b_.super = Object.create(null)
Object.assign(_b_.super,
{
    tp_name: "super",
    tp_basicsize: 40,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `super() -> same as super(__class__, <first argument>)
super(type) -> unbound super object
super(type, obj) -> bound super object; requires isinstance(obj, type)
super(type, type2) -> bound super object; requires issubclass(type2, type)
Typical use to call a cooperative superclass method:
class C(B):
    def meth(self, arg):
        super().meth(arg)
This works for class methods too:
class C(B):
    @classmethod
    def cmeth(cls, arg):
        super().cmeth(arg)
`,
    tp_bases: [_b_.object],
})

_b_.tuple = Object.create(null)
Object.assign(_b_.tuple,
{
    tp_name: "tuple",
    tp_basicsize: 32,
    tp_itersize: 8,
    tp_flags: 71324962,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Built-in immutable sequence.

If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.

If the argument is a tuple, the return value is the same object.`,
    tp_bases: [_b_.object],
})

_b_.type = Object.create(null)
Object.assign(_b_.type,
{
    tp_name: "type",
    tp_basicsize: 936,
    tp_itersize: 40,
    tp_flags: 2155896066,
    tp_weakrefoffset: 368,
    tp_base: _b_.object,
    tp_dictoffset: 264,
    tp_doc: `type(object) -> the object's type
type(name, bases, dict, **kwds) -> a new type`,
    tp_bases: [_b_.object],
})

_b_.zip = Object.create(null)
Object.assign(_b_.zip,
{
    tp_name: "zip",
    tp_basicsize: 48,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `The zip object yields n-length tuples, where n is the number of iterables
passed as positional arguments to zip().  The i-th element in every tuple
comes from the i-th iterable argument to zip().  This continues until the
shortest argument is exhausted.

If strict is true and one of the arguments is exhausted before the others,
raise a ValueError.

   >>> list(zip('abcdefg', range(3), range(4)))
   [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]`,
    tp_bases: [_b_.object],
})

$B.BuiltinImporter = Object.create(null)
Object.assign($B.BuiltinImporter,
{
    tp_name: "BuiltinImporter",
    tp_basicsize: 16,
    tp_itersize: 0,
    tp_flags: 22044,
    tp_weakrefoffset: -32,
    tp_base: _b_.object,
    tp_dictoffset: -1,
    tp_doc: `Meta path import for built-in modules.

All methods are either class or static methods to avoid the need to
instantiate the class.

`,
    tp_bases: [_b_.object],
})

$B.DynamicClassAttribute = Object.create(null)
Object.assign($B.DynamicClassAttribute,
{
    tp_name: "DynamicClassAttribute",
    tp_basicsize: 16,
    tp_itersize: 0,
    tp_flags: 22044,
    tp_weakrefoffset: -32,
    tp_base: _b_.object,
    tp_dictoffset: -1,
    tp_doc: `Route attribute access on a class to __getattr__.

This is a descriptor, used to define attributes that act differently when
accessed through an instance and through a class.  Instance access remains
normal, but access to an attribute through a class will be routed to the
class's __getattr__ method; this is done by raising AttributeError.

This allows one to have properties active on an instance, and have virtual
attributes on the class with the same name.  (Enum used this between Python
versions 3.4 - 3.9 .)

Subclass from this to use a different method of accessing virtual attributes
and still be treated properly by the inspect module. (Enum uses this since
Python 3.10 .)

`,
    tp_bases: [_b_.object],
})

$B.GenericAlias = Object.create(null)
Object.assign($B.GenericAlias,
{
    tp_name: "GenericAlias",
    tp_basicsize: 64,
    tp_itersize: 0,
    tp_flags: 23810,
    tp_weakrefoffset: 40,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Represent a PEP 585 generic type

E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).`,
    tp_bases: [_b_.object],
})

$B.NoneType = Object.create(null)
Object.assign($B.NoneType,
{
    tp_name: "NoneType",
    tp_basicsize: 16,
    tp_itersize: 0,
    tp_flags: 4354,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `The type of the None singleton.`,
    tp_bases: [_b_.object],
})

$B.NotImplementedType = Object.create(null)
Object.assign($B.NotImplementedType,
{
    tp_name: "NotImplementedType",
    tp_basicsize: 16,
    tp_itersize: 0,
    tp_flags: 4354,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `The type of the NotImplemented singleton.`,
    tp_bases: [_b_.object],
})

$B.PyCapsule = Object.create(null)
Object.assign($B.PyCapsule,
{
    tp_name: "PyCapsule",
    tp_basicsize: 64,
    tp_itersize: 0,
    tp_flags: 20866,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Capsule objects let you wrap a C "void *" pointer in a Python
object.  They're a way of passing data through the Python interpreter
without creating your own custom type.

Capsules are used for communication between extension modules.
They provide a way for an extension module to export a C interface
to other extension modules, so that extension modules can use the
Python import mechanism to link to one another.
`,
    tp_bases: [_b_.object],
})

$B.SimpleNamespace = Object.create(null)
Object.assign($B.SimpleNamespace,
{
    tp_name: "SimpleNamespace",
    tp_basicsize: 24,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 16,
    tp_doc: `A simple attribute-based namespace.`,
    tp_bases: [_b_.object],
})

$B.Union = Object.create(null)
Object.assign($B.Union,
{
    tp_name: "Union",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 20866,
    tp_weakrefoffset: 48,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Represent a union type

E.g. for int | str`,
    tp_bases: [_b_.object],
})

$B._GeneratorWrapper = Object.create(null)
Object.assign($B._GeneratorWrapper,
{
    tp_name: "_GeneratorWrapper",
    tp_basicsize: 16,
    tp_itersize: 0,
    tp_flags: 22044,
    tp_weakrefoffset: -32,
    tp_base: _b_.object,
    tp_dictoffset: -1,
    tp_bases: [_b_.object],
})

$B.async_generator = Object.create(null)
Object.assign($B.async_generator,
{
    tp_name: "async_generator",
    tp_basicsize: 152,
    tp_itersize: 8,
    tp_flags: 20866,
    tp_weakrefoffset: 16,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.builtin_function_or_method = Object.create(null)
Object.assign($B.builtin_function_or_method,
{
    tp_name: "builtin_function_or_method",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 22914,
    tp_weakrefoffset: 40,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.cell = Object.create(null)
Object.assign($B.cell,
{
    tp_name: "cell",
    tp_basicsize: 24,
    tp_itersize: 0,
    tp_flags: 20738,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Create a new cell object.

  contents
    the contents of the cell. If not specified, the cell will be empty,
    and 
 further attempts to access its cell_contents attribute will
    raise a ValueError.`,
    tp_bases: [_b_.object],
})

$B.classmethod_descriptor = Object.create(null)
Object.assign($B.classmethod_descriptor,
{
    tp_name: "classmethod_descriptor",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 20866,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.code = Object.create(null)
Object.assign($B.code,
{
    tp_name: "code",
    tp_basicsize: 208,
    tp_itersize: 2,
    tp_flags: 4354,
    tp_weakrefoffset: 144,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Create a code object.  Not for the faint of heart.`,
    tp_bases: [_b_.object],
})

$B.coroutine = Object.create(null)
Object.assign($B.coroutine,
{
    tp_name: "coroutine",
    tp_basicsize: 152,
    tp_itersize: 8,
    tp_flags: 20866,
    tp_weakrefoffset: 16,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.ellipsis = Object.create(null)
Object.assign($B.ellipsis,
{
    tp_name: "ellipsis",
    tp_basicsize: 16,
    tp_itersize: 0,
    tp_flags: 4354,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `The type of the Ellipsis singleton.`,
    tp_bases: [_b_.object],
})

$B.frame = Object.create(null)
Object.assign($B.frame,
{
    tp_name: "frame",
    tp_basicsize: 152,
    tp_itersize: 8,
    tp_flags: 20866,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.function = Object.create(null)
Object.assign($B.function,
{
    tp_name: "function",
    tp_basicsize: 152,
    tp_itersize: 0,
    tp_flags: 153858,
    tp_weakrefoffset: 96,
    tp_base: _b_.object,
    tp_dictoffset: 88,
    tp_doc: `Create a function object.

  code
    a code object
  globals
    the globals dictionary
  name
    a string that overrides the name from the code object
  argdefs
    a tuple that specifies the default argument values
  closure
    a tuple that supplies the bindings for free variables
  kwdefaults
    a dictionary that specifies the default keyword argument values`,
    tp_bases: [_b_.object],
})

$B.generator = Object.create(null)
Object.assign($B.generator,
{
    tp_name: "generator",
    tp_basicsize: 152,
    tp_itersize: 8,
    tp_flags: 20866,
    tp_weakrefoffset: 16,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.getset_descriptor = Object.create(null)
Object.assign($B.getset_descriptor,
{
    tp_name: "getset_descriptor",
    tp_basicsize: 48,
    tp_itersize: 0,
    tp_flags: 20866,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.mappingproxy = Object.create(null)
Object.assign($B.mappingproxy,
{
    tp_name: "mappingproxy",
    tp_basicsize: 24,
    tp_itersize: 0,
    tp_flags: 20802,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Read-only proxy of a mapping.`,
    tp_bases: [_b_.object],
})

$B.member_descriptor = Object.create(null)
Object.assign($B.member_descriptor,
{
    tp_name: "member_descriptor",
    tp_basicsize: 48,
    tp_itersize: 0,
    tp_flags: 20866,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.method = Object.create(null)
Object.assign($B.method,
{
    tp_name: "method",
    tp_basicsize: 48,
    tp_itersize: 0,
    tp_flags: 22786,
    tp_weakrefoffset: 32,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Create a bound instance method object.`,
    tp_bases: [_b_.object],
})

$B.method_wrapper = Object.create(null)
Object.assign($B.method_wrapper,
{
    tp_name: "method-wrapper",
    tp_basicsize: 32,
    tp_itersize: 0,
    tp_flags: 20866,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.method_descriptor = Object.create(null)
Object.assign($B.method_descriptor,
{
    tp_name: "method_descriptor",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 153986,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

$B.module = Object.create(null)
Object.assign($B.module,
{
    tp_name: "module",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 21762,
    tp_weakrefoffset: 40,
    tp_base: _b_.object,
    tp_dictoffset: 16,
    tp_doc: `Create a module object.

The name must be a string; the optional doc argument can have any type.`,
    tp_bases: [_b_.object],
})

$B.traceback = Object.create(null)
Object.assign($B.traceback,
{
    tp_name: "traceback",
    tp_basicsize: 40,
    tp_itersize: 0,
    tp_flags: 20738,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_doc: `Create a new traceback object.`,
    tp_bases: [_b_.object],
})

$B.wrapper_descriptor = Object.create(null)
Object.assign($B.wrapper_descriptor,
{
    tp_name: "wrapper_descriptor",
    tp_basicsize: 56,
    tp_itersize: 0,
    tp_flags: 151938,
    tp_weakrefoffset: 0,
    tp_base: _b_.object,
    tp_dictoffset: 0,
    tp_bases: [_b_.object],
})

_b_.BaseExceptionGroup = Object.create(null)
Object.assign(_b_.BaseExceptionGroup,
{
    tp_name: "BaseExceptionGroup",
    tp_basicsize: 88,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.BaseException,
    tp_dictoffset: 16,
    tp_doc: `A combination of multiple unrelated exceptions.`,
    tp_bases: [_b_.BaseException],
})

_b_.Exception = Object.create(null)
Object.assign(_b_.Exception,
{
    tp_name: "Exception",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.BaseException,
    tp_dictoffset: 16,
    tp_doc: `Common base class for all non-exit exceptions.`,
    tp_bases: [_b_.BaseException],
})

_b_.GeneratorExit = Object.create(null)
Object.assign(_b_.GeneratorExit,
{
    tp_name: "GeneratorExit",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.BaseException,
    tp_dictoffset: 16,
    tp_doc: `Request that a generator exit.`,
    tp_bases: [_b_.BaseException],
})

_b_.KeyboardInterrupt = Object.create(null)
Object.assign(_b_.KeyboardInterrupt,
{
    tp_name: "KeyboardInterrupt",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.BaseException,
    tp_dictoffset: 16,
    tp_doc: `Program interrupted by user.`,
    tp_bases: [_b_.BaseException],
})

_b_.SystemExit = Object.create(null)
Object.assign(_b_.SystemExit,
{
    tp_name: "SystemExit",
    tp_basicsize: 80,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.BaseException,
    tp_dictoffset: 16,
    tp_doc: `Request to exit from the interpreter.`,
    tp_bases: [_b_.BaseException],
})

_b_.bool = Object.create(null)
Object.assign(_b_.bool,
{
    tp_name: "bool",
    tp_basicsize: 24,
    tp_itersize: 4,
    tp_flags: 20975874,
    tp_weakrefoffset: 0,
    tp_base: _b_.int,
    tp_dictoffset: 0,
    tp_doc: `Returns True when the argument is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.`,
    tp_bases: [_b_.int],
})

_b_.ArithmeticError = Object.create(null)
Object.assign(_b_.ArithmeticError,
{
    tp_name: "ArithmeticError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Base class for arithmetic errors.`,
    tp_bases: [_b_.Exception],
})

_b_.AssertionError = Object.create(null)
Object.assign(_b_.AssertionError,
{
    tp_name: "AssertionError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Assertion failed.`,
    tp_bases: [_b_.Exception],
})

_b_.AttributeError = Object.create(null)
Object.assign(_b_.AttributeError,
{
    tp_name: "AttributeError",
    tp_basicsize: 88,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Attribute not found.`,
    tp_bases: [_b_.Exception],
})

_b_.BufferError = Object.create(null)
Object.assign(_b_.BufferError,
{
    tp_name: "BufferError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Buffer error.`,
    tp_bases: [_b_.Exception],
})

_b_.EOFError = Object.create(null)
Object.assign(_b_.EOFError,
{
    tp_name: "EOFError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Read beyond end of file.`,
    tp_bases: [_b_.Exception],
})

_b_.ExceptionGroup = Object.create(null)
Object.assign(_b_.ExceptionGroup,
{
    tp_name: "ExceptionGroup",
    tp_basicsize: 88,
    tp_itersize: 0,
    tp_flags: 1073763848,
    tp_weakrefoffset: -32,
    tp_base: _b_.BaseExceptionGroup,
    tp_dictoffset: 16,
    tp_bases: [_b_.BaseExceptionGroup, _b_.Exception],
})

_b_.ImportError = Object.create(null)
Object.assign(_b_.ImportError,
{
    tp_name: "ImportError",
    tp_basicsize: 104,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Import can't find module, or can't find name in module.`,
    tp_bases: [_b_.Exception],
})

_b_.LookupError = Object.create(null)
Object.assign(_b_.LookupError,
{
    tp_name: "LookupError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Base class for lookup errors.`,
    tp_bases: [_b_.Exception],
})

_b_.MemoryError = Object.create(null)
Object.assign(_b_.MemoryError,
{
    tp_name: "MemoryError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Out of memory.`,
    tp_bases: [_b_.Exception],
})

_b_.NameError = Object.create(null)
Object.assign(_b_.NameError,
{
    tp_name: "NameError",
    tp_basicsize: 80,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Name not found globally.`,
    tp_bases: [_b_.Exception],
})

_b_.OSError = Object.create(null)
Object.assign(_b_.OSError,
{
    tp_name: "OSError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Base class for I/O related errors.`,
    tp_bases: [_b_.Exception],
})

_b_.ReferenceError = Object.create(null)
Object.assign(_b_.ReferenceError,
{
    tp_name: "ReferenceError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Weak ref proxy used after referent went away.`,
    tp_bases: [_b_.Exception],
})

_b_.RuntimeError = Object.create(null)
Object.assign(_b_.RuntimeError,
{
    tp_name: "RuntimeError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Unspecified run-time error.`,
    tp_bases: [_b_.Exception],
})

_b_.StopAsyncIteration = Object.create(null)
Object.assign(_b_.StopAsyncIteration,
{
    tp_name: "StopAsyncIteration",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Signal the end from iterator.__anext__().`,
    tp_bases: [_b_.Exception],
})

_b_.StopIteration = Object.create(null)
Object.assign(_b_.StopIteration,
{
    tp_name: "StopIteration",
    tp_basicsize: 80,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Signal the end from iterator.__next__().`,
    tp_bases: [_b_.Exception],
})

_b_.SyntaxError = Object.create(null)
Object.assign(_b_.SyntaxError,
{
    tp_name: "SyntaxError",
    tp_basicsize: 144,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Invalid syntax.`,
    tp_bases: [_b_.Exception],
})

_b_.SystemError = Object.create(null)
Object.assign(_b_.SystemError,
{
    tp_name: "SystemError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Internal error in the Python interpreter.

Please report this to the Python maintainer, along with the traceback,
the Python version, and the hardware/OS platform and version.`,
    tp_bases: [_b_.Exception],
})

_b_.TypeError = Object.create(null)
Object.assign(_b_.TypeError,
{
    tp_name: "TypeError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Inappropriate argument type.`,
    tp_bases: [_b_.Exception],
})

_b_.ValueError = Object.create(null)
Object.assign(_b_.ValueError,
{
    tp_name: "ValueError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Inappropriate argument value (of correct type).`,
    tp_bases: [_b_.Exception],
})

_b_.Warning = Object.create(null)
Object.assign(_b_.Warning,
{
    tp_name: "Warning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Exception,
    tp_dictoffset: 16,
    tp_doc: `Base class for warning categories.`,
    tp_bases: [_b_.Exception],
})

_b_.BlockingIOError = Object.create(null)
Object.assign(_b_.BlockingIOError,
{
    tp_name: "BlockingIOError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `I/O operation would block.`,
    tp_bases: [_b_.OSError],
})

_b_.BytesWarning = Object.create(null)
Object.assign(_b_.BytesWarning,
{
    tp_name: "BytesWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about bytes and buffer related problems, mostly
related to conversion from str or comparing to str.`,
    tp_bases: [_b_.Warning],
})

_b_.ChildProcessError = Object.create(null)
Object.assign(_b_.ChildProcessError,
{
    tp_name: "ChildProcessError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Child process error.`,
    tp_bases: [_b_.OSError],
})

_b_.ConnectionError = Object.create(null)
Object.assign(_b_.ConnectionError,
{
    tp_name: "ConnectionError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Connection error.`,
    tp_bases: [_b_.OSError],
})

_b_.DeprecationWarning = Object.create(null)
Object.assign(_b_.DeprecationWarning,
{
    tp_name: "DeprecationWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about deprecated features.`,
    tp_bases: [_b_.Warning],
})

_b_.EncodingWarning = Object.create(null)
Object.assign(_b_.EncodingWarning,
{
    tp_name: "EncodingWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about encodings.`,
    tp_bases: [_b_.Warning],
})

_b_.FileExistsError = Object.create(null)
Object.assign(_b_.FileExistsError,
{
    tp_name: "FileExistsError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `File already exists.`,
    tp_bases: [_b_.OSError],
})

_b_.FileNotFoundError = Object.create(null)
Object.assign(_b_.FileNotFoundError,
{
    tp_name: "FileNotFoundError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `File not found.`,
    tp_bases: [_b_.OSError],
})

_b_.FloatingPointError = Object.create(null)
Object.assign(_b_.FloatingPointError,
{
    tp_name: "FloatingPointError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ArithmeticError,
    tp_dictoffset: 16,
    tp_doc: `Floating-point operation failed.`,
    tp_bases: [_b_.ArithmeticError],
})

_b_.FutureWarning = Object.create(null)
Object.assign(_b_.FutureWarning,
{
    tp_name: "FutureWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about constructs that will change semantically
in the future.`,
    tp_bases: [_b_.Warning],
})

_b_.ImportWarning = Object.create(null)
Object.assign(_b_.ImportWarning,
{
    tp_name: "ImportWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about probable mistakes in module imports`,
    tp_bases: [_b_.Warning],
})

_b_.IndentationError = Object.create(null)
Object.assign(_b_.IndentationError,
{
    tp_name: "IndentationError",
    tp_basicsize: 144,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.SyntaxError,
    tp_dictoffset: 16,
    tp_doc: `Improper indentation.`,
    tp_bases: [_b_.SyntaxError],
})

_b_.IndexError = Object.create(null)
Object.assign(_b_.IndexError,
{
    tp_name: "IndexError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.LookupError,
    tp_dictoffset: 16,
    tp_doc: `Sequence index out of range.`,
    tp_bases: [_b_.LookupError],
})

_b_.InterruptedError = Object.create(null)
Object.assign(_b_.InterruptedError,
{
    tp_name: "InterruptedError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Interrupted by signal.`,
    tp_bases: [_b_.OSError],
})

_b_.IsADirectoryError = Object.create(null)
Object.assign(_b_.IsADirectoryError,
{
    tp_name: "IsADirectoryError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Operation doesn't work on directories.`,
    tp_bases: [_b_.OSError],
})

_b_.KeyError = Object.create(null)
Object.assign(_b_.KeyError,
{
    tp_name: "KeyError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.LookupError,
    tp_dictoffset: 16,
    tp_doc: `Mapping key not found.`,
    tp_bases: [_b_.LookupError],
})

_b_.ModuleNotFoundError = Object.create(null)
Object.assign(_b_.ModuleNotFoundError,
{
    tp_name: "ModuleNotFoundError",
    tp_basicsize: 104,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ImportError,
    tp_dictoffset: 16,
    tp_doc: `Module not found.`,
    tp_bases: [_b_.ImportError],
})

_b_.NotADirectoryError = Object.create(null)
Object.assign(_b_.NotADirectoryError,
{
    tp_name: "NotADirectoryError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Operation only works on directories.`,
    tp_bases: [_b_.OSError],
})

_b_.NotImplementedError = Object.create(null)
Object.assign(_b_.NotImplementedError,
{
    tp_name: "NotImplementedError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.RuntimeError,
    tp_dictoffset: 16,
    tp_doc: `Method or function hasn't been implemented yet.`,
    tp_bases: [_b_.RuntimeError],
})

_b_.OverflowError = Object.create(null)
Object.assign(_b_.OverflowError,
{
    tp_name: "OverflowError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ArithmeticError,
    tp_dictoffset: 16,
    tp_doc: `Result too large to be represented.`,
    tp_bases: [_b_.ArithmeticError],
})

_b_.PendingDeprecationWarning = Object.create(null)
Object.assign(_b_.PendingDeprecationWarning,
{
    tp_name: "PendingDeprecationWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about features which will be deprecated
in the future.`,
    tp_bases: [_b_.Warning],
})

_b_.PermissionError = Object.create(null)
Object.assign(_b_.PermissionError,
{
    tp_name: "PermissionError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Not enough permissions.`,
    tp_bases: [_b_.OSError],
})

_b_.ProcessLookupError = Object.create(null)
Object.assign(_b_.ProcessLookupError,
{
    tp_name: "ProcessLookupError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Process not found.`,
    tp_bases: [_b_.OSError],
})

_b_.PythonFinalizationError = Object.create(null)
Object.assign(_b_.PythonFinalizationError,
{
    tp_name: "PythonFinalizationError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.RuntimeError,
    tp_dictoffset: 16,
    tp_doc: `Operation blocked during Python finalization.`,
    tp_bases: [_b_.RuntimeError],
})

_b_.RecursionError = Object.create(null)
Object.assign(_b_.RecursionError,
{
    tp_name: "RecursionError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.RuntimeError,
    tp_dictoffset: 16,
    tp_doc: `Recursion limit exceeded.`,
    tp_bases: [_b_.RuntimeError],
})

_b_.ResourceWarning = Object.create(null)
Object.assign(_b_.ResourceWarning,
{
    tp_name: "ResourceWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about resource usage.`,
    tp_bases: [_b_.Warning],
})

_b_.RuntimeWarning = Object.create(null)
Object.assign(_b_.RuntimeWarning,
{
    tp_name: "RuntimeWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about dubious runtime behavior.`,
    tp_bases: [_b_.Warning],
})

_b_.SyntaxWarning = Object.create(null)
Object.assign(_b_.SyntaxWarning,
{
    tp_name: "SyntaxWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about dubious syntax.`,
    tp_bases: [_b_.Warning],
})

_b_.TimeoutError = Object.create(null)
Object.assign(_b_.TimeoutError,
{
    tp_name: "TimeoutError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.OSError,
    tp_dictoffset: 16,
    tp_doc: `Timeout expired.`,
    tp_bases: [_b_.OSError],
})

_b_.UnboundLocalError = Object.create(null)
Object.assign(_b_.UnboundLocalError,
{
    tp_name: "UnboundLocalError",
    tp_basicsize: 80,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.NameError,
    tp_dictoffset: 16,
    tp_doc: `Local name referenced but not bound to a value.`,
    tp_bases: [_b_.NameError],
})

_b_.UnicodeError = Object.create(null)
Object.assign(_b_.UnicodeError,
{
    tp_name: "UnicodeError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ValueError,
    tp_dictoffset: 16,
    tp_doc: `Unicode related error.`,
    tp_bases: [_b_.ValueError],
})

_b_.UnicodeWarning = Object.create(null)
Object.assign(_b_.UnicodeWarning,
{
    tp_name: "UnicodeWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings about Unicode related problems, mostly
related to conversion problems.`,
    tp_bases: [_b_.Warning],
})

_b_.UserWarning = Object.create(null)
Object.assign(_b_.UserWarning,
{
    tp_name: "UserWarning",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.Warning,
    tp_dictoffset: 16,
    tp_doc: `Base class for warnings generated by user code.`,
    tp_bases: [_b_.Warning],
})

_b_.ZeroDivisionError = Object.create(null)
Object.assign(_b_.ZeroDivisionError,
{
    tp_name: "ZeroDivisionError",
    tp_basicsize: 72,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ArithmeticError,
    tp_dictoffset: 16,
    tp_doc: `Second argument to a division or modulo operation was zero.`,
    tp_bases: [_b_.ArithmeticError],
})

_b_._IncompleteInputError = Object.create(null)
Object.assign(_b_._IncompleteInputError,
{
    tp_name: "_IncompleteInputError",
    tp_basicsize: 144,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.SyntaxError,
    tp_dictoffset: 16,
    tp_doc: `incomplete input.`,
    tp_bases: [_b_.SyntaxError],
})

_b_.BrokenPipeError = Object.create(null)
Object.assign(_b_.BrokenPipeError,
{
    tp_name: "BrokenPipeError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ConnectionError,
    tp_dictoffset: 16,
    tp_doc: `Broken pipe.`,
    tp_bases: [_b_.ConnectionError],
})

_b_.ConnectionAbortedError = Object.create(null)
Object.assign(_b_.ConnectionAbortedError,
{
    tp_name: "ConnectionAbortedError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ConnectionError,
    tp_dictoffset: 16,
    tp_doc: `Connection aborted.`,
    tp_bases: [_b_.ConnectionError],
})

_b_.ConnectionRefusedError = Object.create(null)
Object.assign(_b_.ConnectionRefusedError,
{
    tp_name: "ConnectionRefusedError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ConnectionError,
    tp_dictoffset: 16,
    tp_doc: `Connection refused.`,
    tp_bases: [_b_.ConnectionError],
})

_b_.ConnectionResetError = Object.create(null)
Object.assign(_b_.ConnectionResetError,
{
    tp_name: "ConnectionResetError",
    tp_basicsize: 120,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.ConnectionError,
    tp_dictoffset: 16,
    tp_doc: `Connection reset.`,
    tp_bases: [_b_.ConnectionError],
})

_b_.TabError = Object.create(null)
Object.assign(_b_.TabError,
{
    tp_name: "TabError",
    tp_basicsize: 144,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.IndentationError,
    tp_dictoffset: 16,
    tp_doc: `Improper mixture of spaces and tabs.`,
    tp_bases: [_b_.IndentationError],
})

_b_.UnicodeDecodeError = Object.create(null)
Object.assign(_b_.UnicodeDecodeError,
{
    tp_name: "UnicodeDecodeError",
    tp_basicsize: 112,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.UnicodeError,
    tp_dictoffset: 16,
    tp_doc: `Unicode decoding error.`,
    tp_bases: [_b_.UnicodeError],
})

_b_.UnicodeEncodeError = Object.create(null)
Object.assign(_b_.UnicodeEncodeError,
{
    tp_name: "UnicodeEncodeError",
    tp_basicsize: 112,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.UnicodeError,
    tp_dictoffset: 16,
    tp_doc: `Unicode encoding error.`,
    tp_bases: [_b_.UnicodeError],
})

_b_.UnicodeTranslateError = Object.create(null)
Object.assign(_b_.UnicodeTranslateError,
{
    tp_name: "UnicodeTranslateError",
    tp_basicsize: 112,
    tp_itersize: 0,
    tp_flags: 1073763586,
    tp_weakrefoffset: 0,
    tp_base: _b_.UnicodeError,
    tp_dictoffset: 16,
    tp_doc: `Unicode translation error.`,
    tp_bases: [_b_.UnicodeError],
})

/* set ob_type to _b_.type */
for(let cls in _b_){
    _b_[cls].ob_type = _b_.type
    _b_[cls].dict = Object.create(null)
    _b_[cls].tp_mro = $B.make_mro(_b_[cls])
}
})(__BRYTHON__)
