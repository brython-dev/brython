"use strict";
__BRYTHON__.ast_classes = {
Add:'',
And:'',
AnnAssign:'target,annotation,value?,simple',
Assert:'test,msg?',
Assign:'targets*,value,type_comment?',
AsyncFor:'target,iter,body*,orelse*,type_comment?',
AsyncFunctionDef:'name,args,body*,decorator_list*,returns?,type_comment?,type_params*',
AsyncWith:'items*,body*,type_comment?',
Attribute:'value,attr,ctx',
AugAssign:'target,op,value',
Await:'value',
BinOp:'left,op,right',
BitAnd:'',
BitOr:'',
BitXor:'',
BoolOp:'op,values*',
Break:'',
Call:'func,args*,keywords*',
ClassDef:'name,bases*,keywords*,body*,decorator_list*,type_params*',
Compare:'left,ops*,comparators*',
Constant:'value,kind?',
Continue:'',
Del:'',
Delete:'targets*',
Dict:'keys*,values*',
DictComp:'key,value,generators*',
Div:'',
Eq:'',
ExceptHandler:'type?,name?,body*',
Expr:'value',
Expression:'body',
FloorDiv:'',
For:'target,iter,body*,orelse*,type_comment?',
FormattedValue:'value,conversion,format_spec?',
FunctionDef:'name,args,body*,decorator_list*,returns?,type_comment?,type_params*',
FunctionType:'argtypes*,returns',
GeneratorExp:'elt,generators*',
Global:'names*',
Gt:'',
GtE:'',
If:'test,body*,orelse*',
IfExp:'test,body,orelse',
Import:'names*',
ImportFrom:'module?,names*,level?',
In:'',
Interactive:'body*',
Invert:'',
Is:'',
IsNot:'',
JoinedStr:'values*',
LShift:'',
Lambda:'args,body',
List:'elts*,ctx',
ListComp:'elt,generators*',
Load:'',
Lt:'',
LtE:'',
MatMult:'',
Match:'subject,cases*',
MatchAs:'pattern?,name?',
MatchClass:'cls,patterns*,kwd_attrs*,kwd_patterns*',
MatchMapping:'keys*,patterns*,rest?',
MatchOr:'patterns*',
MatchSequence:'patterns*',
MatchSingleton:'value',
MatchStar:'name?',
MatchValue:'value',
Mod:'',
Module:'body*,type_ignores*',
Mult:'',
Name:'id,ctx',
NamedExpr:'target,value',
Nonlocal:'names*',
Not:'',
NotEq:'',
NotIn:'',
Or:'',
ParamSpec:'name',
Pass:'',
Pow:'',
RShift:'',
Raise:'exc?,cause?',
Return:'value?',
Set:'elts*',
SetComp:'elt,generators*',
Slice:'lower?,upper?,step?',
Starred:'value,ctx',
Store:'',
Sub:'',
Subscript:'value,slice,ctx',
Try:'body*,handlers*,orelse*,finalbody*',
TryStar:'body*,handlers*,orelse*,finalbody*',
Tuple:'elts*,ctx',
TypeAlias:'name,type_params*,value',
TypeIgnore:'lineno,tag',
TypeVar:'name,bound?',
TypeVarTuple:'name',
UAdd:'',
USub:'',
UnaryOp:'op,operand',
While:'test,body*,orelse*',
With:'items*,body*,type_comment?',
Yield:'value?',
YieldFrom:'value',
alias:'name,asname?',
arg:'arg,annotation?,type_comment?',
arguments:'posonlyargs*,args*,vararg?,kwonlyargs*,kw_defaults*,kwarg?,defaults*',
boolop:['And','Or'],
cmpop:['Eq','NotEq','Lt','LtE','Gt','GtE','Is','IsNot','In','NotIn'],
comprehension:'target,iter,ifs*,is_async',
excepthandler:['ExceptHandler'],
expr:['BoolOp','NamedExpr','BinOp','UnaryOp','Lambda','IfExp','Dict','Set','ListComp','SetComp','DictComp','GeneratorExp','Await','Yield','YieldFrom','Compare','Call','FormattedValue','JoinedStr','Constant','Attribute','Subscript','Starred','Name','List','Tuple','Slice'],
expr_context:['Load','Store','Del'],
keyword:'arg?,value',
match_case:'pattern,guard?,body*',
mod:['Module','Interactive','Expression','FunctionType'],
operator:['Add','Sub','Mult','MatMult','Div','Mod','Pow','LShift','RShift','BitOr','BitXor','BitAnd','FloorDiv'],
pattern:['MatchValue','MatchSingleton','MatchSequence','MatchMapping','MatchClass','MatchStar','MatchAs','MatchOr'],
stmt:['FunctionDef','AsyncFunctionDef','ClassDef','Return','Delete','Assign','TypeAlias','AugAssign','AnnAssign','For','AsyncFor','While','If','With','AsyncWith','Match','Raise','Try','TryStar','Assert','Import','ImportFrom','Global','Nonlocal','Expr','Pass','Break','Continue'],
type_ignore:['TypeIgnore'],
type_param:['TypeVar','ParamSpec','TypeVarTuple'],
unaryop:['Invert','Not','UAdd','USub'],
withitem:'context_expr,optional_vars?'
}
