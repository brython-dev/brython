__BRYTHON__.libs = __BRYTHON__.libs || {};
__BRYTHON__.=libs['unittest']={"unittest.test.test_setups": ["import io\nimport sys\n\nimport unittest\n\n\ndef resultFactory(*_):\n return unittest.TestResult()\n \n \nclass TestSetups(unittest.TestCase):\n\n def getRunner(self):\n  return unittest.TextTestRunner(resultclass=resultFactory,\n  stream=io.StringIO())\n def runTests(self, *cases):\n  suite = unittest.TestSuite()\n  for case in cases:\n   tests = unittest.defaultTestLoader.loadTestsFromTestCase(case)\n   suite.addTests(tests)\n   \n  runner = self.getRunner()\n  \n  \n  realSuite = unittest.TestSuite()\n  realSuite.addTest(suite)\n  \n  suite.addTest(unittest.TestSuite())\n  realSuite.addTest(unittest.TestSuite())\n  return runner.run(realSuite)\n  \n def test_setup_class(self):\n  class Test(unittest.TestCase):\n   setUpCalled = 0\n   @classmethod\n   def setUpClass(cls):\n    Test.setUpCalled += 1\n    unittest.TestCase.setUpClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  result = self.runTests(Test)\n  \n  self.assertEqual(Test.setUpCalled, 1)\n  self.assertEqual(result.testsRun, 2)\n  self.assertEqual(len(result.errors), 0)\n  \n def test_teardown_class(self):\n  class Test(unittest.TestCase):\n   tearDownCalled = 0\n   @classmethod\n   def tearDownClass(cls):\n    Test.tearDownCalled += 1\n    unittest.TestCase.tearDownClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  result = self.runTests(Test)\n  \n  self.assertEqual(Test.tearDownCalled, 1)\n  self.assertEqual(result.testsRun, 2)\n  self.assertEqual(len(result.errors), 0)\n  \n def test_teardown_class_two_classes(self):\n  class Test(unittest.TestCase):\n   tearDownCalled = 0\n   @classmethod\n   def tearDownClass(cls):\n    Test.tearDownCalled += 1\n    unittest.TestCase.tearDownClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  class Test2(unittest.TestCase):\n   tearDownCalled = 0\n   @classmethod\n   def tearDownClass(cls):\n    Test2.tearDownCalled += 1\n    unittest.TestCase.tearDownClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  result = self.runTests(Test, Test2)\n  \n  self.assertEqual(Test.tearDownCalled, 1)\n  self.assertEqual(Test2.tearDownCalled, 1)\n  self.assertEqual(result.testsRun, 4)\n  self.assertEqual(len(result.errors), 0)\n  \n def test_error_in_setupclass(self):\n  class BrokenTest(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  result = self.runTests(BrokenTest)\n  \n  self.assertEqual(result.testsRun, 0)\n  self.assertEqual(len(result.errors), 1)\n  error, _ = result.errors[0]\n  self.assertEqual(str(error),\n  'setUpClass (%s.BrokenTest)' % __name__)\n  \n def test_error_in_teardown_class(self):\n  class Test(unittest.TestCase):\n   tornDown = 0\n   @classmethod\n   def tearDownClass(cls):\n    Test.tornDown += 1\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  class Test2(unittest.TestCase):\n   tornDown = 0\n   @classmethod\n   def tearDownClass(cls):\n    Test2.tornDown += 1\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  result = self.runTests(Test, Test2)\n  self.assertEqual(result.testsRun, 4)\n  self.assertEqual(len(result.errors), 2)\n  self.assertEqual(Test.tornDown, 1)\n  self.assertEqual(Test2.tornDown, 1)\n  \n  error, _ = result.errors[0]\n  self.assertEqual(str(error),\n  'tearDownClass (%s.Test)' % __name__)\n  \n def test_class_not_torndown_when_setup_fails(self):\n  class Test(unittest.TestCase):\n   tornDown = False\n   @classmethod\n   def setUpClass(cls):\n    raise TypeError\n   @classmethod\n   def tearDownClass(cls):\n    Test.tornDown = True\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n    \n  self.runTests(Test)\n  self.assertFalse(Test.tornDown)\n  \n def test_class_not_setup_or_torndown_when_skipped(self):\n  class Test(unittest.TestCase):\n   classSetUp = False\n   tornDown = False\n   @classmethod\n   def setUpClass(cls):\n    Test.classSetUp = True\n   @classmethod\n   def tearDownClass(cls):\n    Test.tornDown = True\n   def test_one(self):\n    pass\n    \n  Test = unittest.skip(\"hop\")(Test)\n  self.runTests(Test)\n  self.assertFalse(Test.classSetUp)\n  self.assertFalse(Test.tornDown)\n  \n def test_setup_teardown_order_with_pathological_suite(self):\n  results = []\n  \n  class Module1(object):\n   @staticmethod\n   def setUpModule():\n    results.append('Module1.setUpModule')\n   @staticmethod\n   def tearDownModule():\n    results.append('Module1.tearDownModule')\n    \n  class Module2(object):\n   @staticmethod\n   def setUpModule():\n    results.append('Module2.setUpModule')\n   @staticmethod\n   def tearDownModule():\n    results.append('Module2.tearDownModule')\n    \n  class Test1(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    results.append('setup 1')\n   @classmethod\n   def tearDownClass(cls):\n    results.append('teardown 1')\n   def testOne(self):\n    results.append('Test1.testOne')\n   def testTwo(self):\n    results.append('Test1.testTwo')\n    \n  class Test2(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    results.append('setup 2')\n   @classmethod\n   def tearDownClass(cls):\n    results.append('teardown 2')\n   def testOne(self):\n    results.append('Test2.testOne')\n   def testTwo(self):\n    results.append('Test2.testTwo')\n    \n  class Test3(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    results.append('setup 3')\n   @classmethod\n   def tearDownClass(cls):\n    results.append('teardown 3')\n   def testOne(self):\n    results.append('Test3.testOne')\n   def testTwo(self):\n    results.append('Test3.testTwo')\n    \n  Test1.__module__ = Test2.__module__ = 'Module'\n  Test3.__module__ = 'Module2'\n  sys.modules['Module'] = Module1\n  sys.modules['Module2'] = Module2\n  \n  first = unittest.TestSuite((Test1('testOne'),))\n  second = unittest.TestSuite((Test1('testTwo'),))\n  third = unittest.TestSuite((Test2('testOne'),))\n  fourth = unittest.TestSuite((Test2('testTwo'),))\n  fifth = unittest.TestSuite((Test3('testOne'),))\n  sixth = unittest.TestSuite((Test3('testTwo'),))\n  suite = unittest.TestSuite((first, second, third, fourth, fifth, sixth))\n  \n  runner = self.getRunner()\n  result = runner.run(suite)\n  self.assertEqual(result.testsRun, 6)\n  self.assertEqual(len(result.errors), 0)\n  \n  self.assertEqual(results,\n  ['Module1.setUpModule', 'setup 1',\n  'Test1.testOne', 'Test1.testTwo', 'teardown 1',\n  'setup 2', 'Test2.testOne', 'Test2.testTwo',\n  'teardown 2', 'Module1.tearDownModule',\n  'Module2.setUpModule', 'setup 3',\n  'Test3.testOne', 'Test3.testTwo',\n  'teardown 3', 'Module2.tearDownModule'])\n  \n def test_setup_module(self):\n  class Module(object):\n   moduleSetup = 0\n   @staticmethod\n   def setUpModule():\n    Module.moduleSetup += 1\n    \n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  \n  result = self.runTests(Test)\n  self.assertEqual(Module.moduleSetup, 1)\n  self.assertEqual(result.testsRun, 2)\n  self.assertEqual(len(result.errors), 0)\n  \n def test_error_in_setup_module(self):\n  class Module(object):\n   moduleSetup = 0\n   moduleTornDown = 0\n   @staticmethod\n   def setUpModule():\n    Module.moduleSetup += 1\n    raise TypeError('foo')\n   @staticmethod\n   def tearDownModule():\n    Module.moduleTornDown += 1\n    \n  class Test(unittest.TestCase):\n   classSetUp = False\n   classTornDown = False\n   @classmethod\n   def setUpClass(cls):\n    Test.classSetUp = True\n   @classmethod\n   def tearDownClass(cls):\n    Test.classTornDown = True\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  class Test2(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__ = 'Module'\n  Test2.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  \n  result = self.runTests(Test, Test2)\n  self.assertEqual(Module.moduleSetup, 1)\n  self.assertEqual(Module.moduleTornDown, 0)\n  self.assertEqual(result.testsRun, 0)\n  self.assertFalse(Test.classSetUp)\n  self.assertFalse(Test.classTornDown)\n  self.assertEqual(len(result.errors), 1)\n  error, _ = result.errors[0]\n  self.assertEqual(str(error), 'setUpModule (Module)')\n  \n def test_testcase_with_missing_module(self):\n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__ = 'Module'\n  sys.modules.pop('Module', None)\n  \n  result = self.runTests(Test)\n  self.assertEqual(result.testsRun, 2)\n  \n def test_teardown_module(self):\n  class Module(object):\n   moduleTornDown = 0\n   @staticmethod\n   def tearDownModule():\n    Module.moduleTornDown += 1\n    \n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  \n  result = self.runTests(Test)\n  self.assertEqual(Module.moduleTornDown, 1)\n  self.assertEqual(result.testsRun, 2)\n  self.assertEqual(len(result.errors), 0)\n  \n def test_error_in_teardown_module(self):\n  class Module(object):\n   moduleTornDown = 0\n   @staticmethod\n   def tearDownModule():\n    Module.moduleTornDown += 1\n    raise TypeError('foo')\n    \n  class Test(unittest.TestCase):\n   classSetUp = False\n   classTornDown = False\n   @classmethod\n   def setUpClass(cls):\n    Test.classSetUp = True\n   @classmethod\n   def tearDownClass(cls):\n    Test.classTornDown = True\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  class Test2(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__ = 'Module'\n  Test2.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  \n  result = self.runTests(Test, Test2)\n  self.assertEqual(Module.moduleTornDown, 1)\n  self.assertEqual(result.testsRun, 4)\n  self.assertTrue(Test.classSetUp)\n  self.assertTrue(Test.classTornDown)\n  self.assertEqual(len(result.errors), 1)\n  error, _ = result.errors[0]\n  self.assertEqual(str(error), 'tearDownModule (Module)')\n  \n def test_skiptest_in_setupclass(self):\n  class Test(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    raise unittest.SkipTest('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  result = self.runTests(Test)\n  self.assertEqual(result.testsRun, 0)\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.skipped), 1)\n  skipped = result.skipped[0][0]\n  self.assertEqual(str(skipped), 'setUpClass (%s.Test)' % __name__)\n  \n def test_skiptest_in_setupmodule(self):\n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n    \n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    raise unittest.SkipTest('foo')\n    \n  Test.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  \n  result = self.runTests(Test)\n  self.assertEqual(result.testsRun, 0)\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.skipped), 1)\n  skipped = result.skipped[0][0]\n  self.assertEqual(str(skipped), 'setUpModule (Module)')\n  \n def test_suite_debug_executes_setups_and_teardowns(self):\n  ordering = []\n  \n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    ordering.append('setUpModule')\n   @staticmethod\n   def tearDownModule():\n    ordering.append('tearDownModule')\n    \n  class Test(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    ordering.append('setUpClass')\n   @classmethod\n   def tearDownClass(cls):\n    ordering.append('tearDownClass')\n   def test_something(self):\n    ordering.append('test_something')\n    \n  Test.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  \n  suite = unittest.defaultTestLoader.loadTestsFromTestCase(Test)\n  suite.debug()\n  expectedOrder = ['setUpModule', 'setUpClass', 'test_something', 'tearDownClass', 'tearDownModule']\n  self.assertEqual(ordering, expectedOrder)\n  \n def test_suite_debug_propagates_exceptions(self):\n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    if phase == 0:\n     raise Exception('setUpModule')\n   @staticmethod\n   def tearDownModule():\n    if phase == 1:\n     raise Exception('tearDownModule')\n     \n  class Test(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    if phase == 2:\n     raise Exception('setUpClass')\n   @classmethod\n   def tearDownClass(cls):\n    if phase == 3:\n     raise Exception('tearDownClass')\n   def test_something(self):\n    if phase == 4:\n     raise Exception('test_something')\n     \n  Test.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  \n  _suite = unittest.defaultTestLoader.loadTestsFromTestCase(Test)\n  suite = unittest.TestSuite()\n  suite.addTest(_suite)\n  \n  messages = ('setUpModule', 'tearDownModule', 'setUpClass', 'tearDownClass', 'test_something')\n  for phase, msg in enumerate(messages):\n   with self.assertRaisesRegex(Exception, msg):\n    suite.debug()\n    \nif __name__ == '__main__':\n unittest.main()\n"], "test.test_re": ["\n\n\n\nverbose = True\n\n\n\nimport re\n\n\n\nimport sre_constants\nimport sys\nimport string\nimport traceback\n\n\n\n\n\n\n\n\n\nimport unittest\n\nclass ReTests(unittest.TestCase):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n def test_search_star_plus(self):\n  self.assertEqual(re.search('x*', 'axx').span(0), (0, 0))\n  self.assertEqual(re.search('x*', 'axx').span(), (0, 0))\n  self.assertEqual(re.search('x+', 'axx').span(0), (1, 3))\n  self.assertEqual(re.search('x+', 'axx').span(), (1, 3))\n  self.assertEqual(re.search('x', 'aaa'), None)\n  self.assertEqual(re.match('a*', 'xxx').span(0), (0, 0))\n  self.assertEqual(re.match('a*', 'xxx').span(), (0, 0))\n  self.assertEqual(re.match('x*', 'xxxa').span(0), (0, 3))\n  self.assertEqual(re.match('x*', 'xxxa').span(), (0, 3))\n  self.assertEqual(re.match('a+', 'xxx'), None)\n  \n def bump_num(self, matchobj):\n  int_value = int(matchobj.group(0))\n  return str(int_value + 1)\n  \n def test_basic_re_sub(self):\n  self.assertEqual(re.sub(\"(?i)b+\", \"x\", \"bbbb BBBB\"), 'x x')\n  self.assertEqual(re.sub(r'\\d+', self.bump_num, '08.2 -2 23x99y'),\n  '9.3 -3 24x100y')\n  self.assertEqual(re.sub(r'\\d+', self.bump_num, '08.2 -2 23x99y', 3),\n  '9.3 -3 23x99y')\n  \n  self.assertEqual(re.sub('.', lambda m: r\"\\n\", 'x'), '\\\\n')\n  self.assertEqual(re.sub('.', r\"\\n\", 'x'), '\\n')\n  \n  s = r\"\\1\\1\"\n  self.assertEqual(re.sub('(.)', s, 'x'), 'xx')\n  self.assertEqual(re.sub('(.)', re.escape(s), 'x'), s)\n  self.assertEqual(re.sub('(.)', lambda m: s, 'x'), s)\n  \n  self.assertEqual(re.sub('(?P<a>x)', '\\g<a>\\g<a>', 'xx'), 'xxxx')\n  self.assertEqual(re.sub('(?P<a>x)', '\\g<a>\\g<1>', 'xx'), 'xxxx')\n  self.assertEqual(re.sub('(?P<unk>x)', '\\g<unk>\\g<unk>', 'xx'), 'xxxx')\n  self.assertEqual(re.sub('(?P<unk>x)', '\\g<1>\\g<1>', 'xx'), 'xxxx')\n  \n  self.assertEqual(re.sub('a',r'\\t\\n\\v\\r\\f\\a\\b\\B\\Z\\a\\A\\w\\W\\s\\S\\d\\D','a'),\n  '\\t\\n\\v\\r\\f\\a\\b\\\\B\\\\Z\\a\\\\A\\\\w\\\\W\\\\s\\\\S\\\\d\\\\D')\n  self.assertEqual(re.sub('a', '\\t\\n\\v\\r\\f\\a', 'a'), '\\t\\n\\v\\r\\f\\a')\n  self.assertEqual(re.sub('a', '\\t\\n\\v\\r\\f\\a', 'a'),\n  (chr(9)+chr(10)+chr(11)+chr(13)+chr(12)+chr(7)))\n  \n  self.assertEqual(re.sub('^\\s*', 'X', 'test'), 'Xtest')\n  \n def test_bug_449964(self):\n \n  self.assertEqual(re.sub(r'(?P<unk>x)', '\\g<1>\\g<1>\\\\b', 'xx'),\n  'xx\\bxx\\b')\n  \n def test_bug_449000(self):\n \n  self.assertEqual(re.sub(r'\\r\\n', r'\\n', 'abc\\r\\ndef\\r\\n'),\n  'abc\\ndef\\n')\n  self.assertEqual(re.sub('\\r\\n', r'\\n', 'abc\\r\\ndef\\r\\n'),\n  'abc\\ndef\\n')\n  self.assertEqual(re.sub(r'\\r\\n', '\\n', 'abc\\r\\ndef\\r\\n'),\n  'abc\\ndef\\n')\n  self.assertEqual(re.sub('\\r\\n', '\\n', 'abc\\r\\ndef\\r\\n'),\n  'abc\\ndef\\n')\n  \n def test_bug_1661(self):\n \n  pattern = re.compile('.')\n  self.assertRaises(ValueError, re.match, pattern, 'A', re.I)\n  self.assertRaises(ValueError, re.search, pattern, 'A', re.I)\n  self.assertRaises(ValueError, re.findall, pattern, 'A', re.I)\n  self.assertRaises(ValueError, re.compile, pattern, re.I)\n  \n def test_bug_3629(self):\n \n  re.compile(\"(?P<quote>)(?(quote))\")\n  \n def test_sub_template_numeric_escape(self):\n \n  self.assertEqual(re.sub('x', r'\\0', 'x'), '\\0')\n  self.assertEqual(re.sub('x', r'\\000', 'x'), '\\000')\n  self.assertEqual(re.sub('x', r'\\001', 'x'), '\\001')\n  self.assertEqual(re.sub('x', r'\\008', 'x'), '\\0' + '8')\n  self.assertEqual(re.sub('x', r'\\009', 'x'), '\\0' + '9')\n  self.assertEqual(re.sub('x', r'\\111', 'x'), '\\111')\n  self.assertEqual(re.sub('x', r'\\117', 'x'), '\\117')\n  \n  self.assertEqual(re.sub('x', r'\\1111', 'x'), '\\1111')\n  self.assertEqual(re.sub('x', r'\\1111', 'x'), '\\111' + '1')\n  \n  self.assertEqual(re.sub('x', r'\\00', 'x'), '\\x00')\n  self.assertEqual(re.sub('x', r'\\07', 'x'), '\\x07')\n  self.assertEqual(re.sub('x', r'\\08', 'x'), '\\0' + '8')\n  self.assertEqual(re.sub('x', r'\\09', 'x'), '\\0' + '9')\n  self.assertEqual(re.sub('x', r'\\0a', 'x'), '\\0' + 'a')\n  \n  self.assertEqual(re.sub('x', r'\\400', 'x'), '\\0')\n  self.assertEqual(re.sub('x', r'\\777', 'x'), '\\377')\n  \n  self.assertRaises(re.error, re.sub, 'x', r'\\1', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\8', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\9', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\11', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\18', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\1a', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\90', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\99', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\118', 'x') \n  self.assertRaises(re.error, re.sub, 'x', r'\\11a', 'x')\n  self.assertRaises(re.error, re.sub, 'x', r'\\181', 'x') \n  self.assertRaises(re.error, re.sub, 'x', r'\\800', 'x') \n  \n  \n  self.assertEqual(re.sub('(((((((((((x)))))))))))', r'\\11', 'x'), 'x')\n  self.assertEqual(re.sub('((((((((((y))))))))))(.)', r'\\118', 'xyz'),\n  'xz8')\n  self.assertEqual(re.sub('((((((((((y))))))))))(.)', r'\\11a', 'xyz'),\n  'xza')\n  \n def test_qualified_re_sub(self):\n  self.assertEqual(re.sub('a', 'b', 'aaaaa'), 'bbbbb')\n  self.assertEqual(re.sub('a', 'b', 'aaaaa', 1), 'baaaa')\n  \n def test_bug_114660(self):\n  self.assertEqual(re.sub(r'(\\S)\\s+(\\S)', r'\\1 \\2', 'hello  there'),\n  'hello there')\n  \n def test_bug_462270(self):\n \n  self.assertEqual(re.sub('x*', '-', 'abxd'), '-a-b-d-')\n  self.assertEqual(re.sub('x+', '-', 'abxd'), 'ab-d')\n  \n def test_symbolic_groups(self):\n  re.compile('(?P<a>x)(?P=a)(?(a)y)')\n  re.compile('(?P<a1>x)(?P=a1)(?(a1)y)')\n  self.assertRaises(re.error, re.compile, '(?P<a>)(?P<a>)')\n  self.assertRaises(re.error, re.compile, '(?Px)')\n  self.assertRaises(re.error, re.compile, '(?P=)')\n  self.assertRaises(re.error, re.compile, '(?P=1)')\n  self.assertRaises(re.error, re.compile, '(?P=a)')\n  self.assertRaises(re.error, re.compile, '(?P=a1)')\n  self.assertRaises(re.error, re.compile, '(?P=a.)')\n  self.assertRaises(re.error, re.compile, '(?P<)')\n  self.assertRaises(re.error, re.compile, '(?P<>)')\n  self.assertRaises(re.error, re.compile, '(?P<1>)')\n  self.assertRaises(re.error, re.compile, '(?P<a.>)')\n  self.assertRaises(re.error, re.compile, '(?())')\n  self.assertRaises(re.error, re.compile, '(?(a))')\n  self.assertRaises(re.error, re.compile, '(?(1a))')\n  self.assertRaises(re.error, re.compile, '(?(a.))')\n  \n  re.compile('(?P<\u00b5>x)(?P=\u00b5)(?(\u00b5)y)')\n  re.compile('(?P<\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22>x)(?P=\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22)(?(\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22)y)')\n  self.assertRaises(re.error, re.compile, '(?P<\u00a9>x)')\n  \n def test_symbolic_refs(self):\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', '\\g<a', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', '\\g<', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', '\\g', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', '\\g<a a>', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', '\\g<>', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', '\\g<1a1>', 'xx')\n  self.assertRaises(IndexError, re.sub, '(?P<a>x)', '\\g<ab>', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)|(?P<b>y)', '\\g<b>', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)|(?P<b>y)', '\\\\2', 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', '\\g<-1>', 'xx')\n  \n  self.assertEqual(re.sub('(?P<\u00b5>x)', r'\\g<\u00b5>', 'xx'), 'xx')\n  self.assertEqual(re.sub('(?P<\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22>x)', r'\\g<\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22>', 'xx'), 'xx')\n  self.assertRaises(re.error, re.sub, '(?P<a>x)', r'\\g<\u00a9>', 'xx')\n  \n def test_re_subn(self):\n  self.assertEqual(re.subn(\"(?i)b+\", \"x\", \"bbbb BBBB\"), ('x x', 2))\n  self.assertEqual(re.subn(\"b+\", \"x\", \"bbbb BBBB\"), ('x BBBB', 1))\n  self.assertEqual(re.subn(\"b+\", \"x\", \"xyz\"), ('xyz', 0))\n  self.assertEqual(re.subn(\"b*\", \"x\", \"xyz\"), ('xxxyxzx', 4))\n  self.assertEqual(re.subn(\"b*\", \"x\", \"xyz\", 2), ('xxxyz', 2))\n  \n def test_re_split(self):\n  self.assertEqual(re.split(\":\", \":a:b::c\"), ['', 'a', 'b', '', 'c'])\n  self.assertEqual(re.split(\":*\", \":a:b::c\"), ['', 'a', 'b', 'c'])\n  self.assertEqual(re.split(\"(:*)\", \":a:b::c\"),\n  ['', ':', 'a', ':', 'b', '::', 'c'])\n  self.assertEqual(re.split(\"(?::*)\", \":a:b::c\"), ['', 'a', 'b', 'c'])\n  self.assertEqual(re.split(\"(:)*\", \":a:b::c\"),\n  ['', ':', 'a', ':', 'b', ':', 'c'])\n  self.assertEqual(re.split(\"([b:]+)\", \":a:b::c\"),\n  ['', ':', 'a', ':b::', 'c'])\n  self.assertEqual(re.split(\"(b)|(:+)\", \":a:b::c\"),\n  ['', None, ':', 'a', None, ':', '', 'b', None, '',\n  None, '::', 'c'])\n  self.assertEqual(re.split(\"(?:b)|(?::+)\", \":a:b::c\"),\n  ['', 'a', '', '', 'c'])\n  \n def test_qualified_re_split(self):\n  self.assertEqual(re.split(\":\", \":a:b::c\", 2), ['', 'a', 'b::c'])\n  self.assertEqual(re.split(':', 'a:b:c:d', 2), ['a', 'b', 'c:d'])\n  self.assertEqual(re.split(\"(:)\", \":a:b::c\", 2),\n  ['', ':', 'a', ':', 'b::c'])\n  self.assertEqual(re.split(\"(:*)\", \":a:b::c\", 2),\n  ['', ':', 'a', ':', 'b::c'])\n  \n def test_re_findall(self):\n  self.assertEqual(re.findall(\":+\", \"abc\"), [])\n  self.assertEqual(re.findall(\":+\", \"a:b::c:::d\"), [\":\", \"::\", \":::\"])\n  self.assertEqual(re.findall(\"(:+)\", \"a:b::c:::d\"), [\":\", \"::\", \":::\"])\n  self.assertEqual(re.findall(\"(:)(:*)\", \"a:b::c:::d\"), [(\":\", \"\"),\n  (\":\", \":\"),\n  (\":\", \"::\")])\n  \n def test_bug_117612(self):\n  self.assertEqual(re.findall(r\"(a|(b))\", \"aba\"),\n  [(\"a\", \"\"),(\"b\", \"b\"),(\"a\", \"\")])\n  \n def test_re_match(self):\n  self.assertEqual(re.match('a', 'a').groups(), ())\n  self.assertEqual(re.match('(a)', 'a').groups(), ('a',))\n  self.assertEqual(re.match(r'(a)', 'a').group(0), 'a')\n  self.assertEqual(re.match(r'(a)', 'a').group(1), 'a')\n  self.assertEqual(re.match(r'(a)', 'a').group(1, 1), ('a', 'a'))\n  \n  pat = re.compile('((a)|(b))(c)?')\n  self.assertEqual(pat.match('a').groups(), ('a', 'a', None, None))\n  self.assertEqual(pat.match('b').groups(), ('b', None, 'b', None))\n  self.assertEqual(pat.match('ac').groups(), ('a', 'a', None, 'c'))\n  self.assertEqual(pat.match('bc').groups(), ('b', None, 'b', 'c'))\n  self.assertEqual(pat.match('bc').groups(\"\"), ('b', \"\", 'b', 'c'))\n  \n  \n  m = re.match('(a)', 'a')\n  self.assertEqual(m.group(0), 'a')\n  self.assertEqual(m.group(0), 'a')\n  self.assertEqual(m.group(1), 'a')\n  self.assertEqual(m.group(1, 1), ('a', 'a'))\n  \n  pat = re.compile('(?:(?P<a1>a)|(?P<b2>b))(?P<c3>c)?')\n  self.assertEqual(pat.match('a').group(1, 2, 3), ('a', None, None))\n  self.assertEqual(pat.match('b').group('a1', 'b2', 'c3'),\n  (None, 'b', None))\n  self.assertEqual(pat.match('ac').group(1, 'b2', 3), ('a', None, 'c'))\n  \n def test_re_groupref_exists(self):\n  self.assertEqual(re.match('^(\\()?([^()]+)(?(1)\\))$', '(a)').groups(),\n  ('(', 'a'))\n  self.assertEqual(re.match('^(\\()?([^()]+)(?(1)\\))$', 'a').groups(),\n  (None, 'a'))\n  self.assertEqual(re.match('^(\\()?([^()]+)(?(1)\\))$', 'a)'), None)\n  self.assertEqual(re.match('^(\\()?([^()]+)(?(1)\\))$', '(a'), None)\n  self.assertEqual(re.match('^(?:(a)|c)((?(1)b|d))$', 'ab').groups(),\n  ('a', 'b'))\n  self.assertEqual(re.match('^(?:(a)|c)((?(1)b|d))$', 'cd').groups(),\n  (None, 'd'))\n  self.assertEqual(re.match('^(?:(a)|c)((?(1)|d))$', 'cd').groups(),\n  (None, 'd'))\n  self.assertEqual(re.match('^(?:(a)|c)((?(1)|d))$', 'a').groups(),\n  ('a', ''))\n  \n  \n  p = re.compile('(?P<g1>a)(?P<g2>b)?((?(g2)c|d))')\n  self.assertEqual(p.match('abc').groups(),\n  ('a', 'b', 'c'))\n  self.assertEqual(p.match('ad').groups(),\n  ('a', None, 'd'))\n  self.assertEqual(p.match('abd'), None)\n  self.assertEqual(p.match('ac'), None)\n  \n  \n def test_re_groupref(self):\n  self.assertEqual(re.match(r'^(\\|)?([^()]+)\\1$', '|a|').groups(),\n  ('|', 'a'))\n  self.assertEqual(re.match(r'^(\\|)?([^()]+)\\1?$', 'a').groups(),\n  (None, 'a'))\n  self.assertEqual(re.match(r'^(\\|)?([^()]+)\\1$', 'a|'), None)\n  self.assertEqual(re.match(r'^(\\|)?([^()]+)\\1$', '|a'), None)\n  self.assertEqual(re.match(r'^(?:(a)|c)(\\1)$', 'aa').groups(),\n  ('a', 'a'))\n  self.assertEqual(re.match(r'^(?:(a)|c)(\\1)?$', 'c').groups(),\n  (None, None))\n  \n def test_groupdict(self):\n  self.assertEqual(re.match('(?P<first>first) (?P<second>second)',\n  'first second').groupdict(),\n  {'first':'first', 'second':'second'})\n  \n def test_expand(self):\n  self.assertEqual(re.match(\"(?P<first>first) (?P<second>second)\",\n  \"first second\")\n  .expand(r\"\\2 \\1 \\g<second> \\g<first>\"),\n  \"second first second first\")\n  \n def test_repeat_minmax(self):\n  self.assertEqual(re.match(\"^(\\w){1}$\", \"abc\"), None)\n  self.assertEqual(re.match(\"^(\\w){1}?$\", \"abc\"), None)\n  self.assertEqual(re.match(\"^(\\w){1,2}$\", \"abc\"), None)\n  self.assertEqual(re.match(\"^(\\w){1,2}?$\", \"abc\"), None)\n  \n  self.assertEqual(re.match(\"^(\\w){3}$\", \"abc\").group(1), \"c\")\n  self.assertEqual(re.match(\"^(\\w){1,3}$\", \"abc\").group(1), \"c\")\n  self.assertEqual(re.match(\"^(\\w){1,4}$\", \"abc\").group(1), \"c\")\n  self.assertEqual(re.match(\"^(\\w){3,4}?$\", \"abc\").group(1), \"c\")\n  self.assertEqual(re.match(\"^(\\w){3}?$\", \"abc\").group(1), \"c\")\n  self.assertEqual(re.match(\"^(\\w){1,3}?$\", \"abc\").group(1), \"c\")\n  self.assertEqual(re.match(\"^(\\w){1,4}?$\", \"abc\").group(1), \"c\")\n  self.assertEqual(re.match(\"^(\\w){3,4}?$\", \"abc\").group(1), \"c\")\n  \n  self.assertEqual(re.match(\"^x{1}$\", \"xxx\"), None)\n  self.assertEqual(re.match(\"^x{1}?$\", \"xxx\"), None)\n  self.assertEqual(re.match(\"^x{1,2}$\", \"xxx\"), None)\n  self.assertEqual(re.match(\"^x{1,2}?$\", \"xxx\"), None)\n  \n  self.assertNotEqual(re.match(\"^x{3}$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{1,3}$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{1,4}$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{3,4}?$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{3}?$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{1,3}?$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{1,4}?$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{3,4}?$\", \"xxx\"), None)\n  \n  self.assertEqual(re.match(\"^x{}$\", \"xxx\"), None)\n  self.assertNotEqual(re.match(\"^x{}$\", \"x{}\"), None)\n  \n def test_getattr(self):\n  self.assertEqual(re.compile(\"(?i)(a)(b)\").pattern, \"(?i)(a)(b)\")\n  self.assertEqual(re.compile(\"(?i)(a)(b)\").flags, re.I | re.U)\n  self.assertEqual(re.compile(\"(?i)(a)(b)\").groups, 2)\n  self.assertEqual(re.compile(\"(?i)(a)(b)\").groupindex, {})\n  self.assertEqual(re.compile(\"(?i)(?P<first>a)(?P<other>b)\").groupindex,\n  {'first': 1, 'other': 2})\n  \n  self.assertEqual(re.match(\"(a)\", \"a\").pos, 0)\n  self.assertEqual(re.match(\"(a)\", \"a\").endpos, 1)\n  self.assertEqual(re.match(\"(a)\", \"a\").string, \"a\")\n  self.assertEqual(re.match(\"(a)\", \"a\").regs, ((0, 1), (0, 1)))\n  self.assertNotEqual(re.match(\"(a)\", \"a\").re, None)\n  \n def test_special_escapes(self):\n  self.assertEqual(re.search(r\"\\b(b.)\\b\",\n  \"abcd abc bcd bx\").group(1), \"bx\")\n  self.assertEqual(re.search(r\"\\B(b.)\\B\",\n  \"abc bcd bc abxd\").group(1), \"bx\")\n  self.assertEqual(re.search(r\"\\b(b.)\\b\",\n  \"abcd abc bcd bx\", re.LOCALE).group(1), \"bx\")\n  self.assertEqual(re.search(r\"\\B(b.)\\B\",\n  \"abc bcd bc abxd\", re.LOCALE).group(1), \"bx\")\n  self.assertEqual(re.search(r\"\\b(b.)\\b\",\n  \"abcd abc bcd bx\", re.UNICODE).group(1), \"bx\")\n  self.assertEqual(re.search(r\"\\B(b.)\\B\",\n  \"abc bcd bc abxd\", re.UNICODE).group(1), \"bx\")\n  self.assertEqual(re.search(r\"^abc$\", \"\\nabc\\n\", re.M).group(0), \"abc\")\n  self.assertEqual(re.search(r\"^\\Aabc\\Z$\", \"abc\", re.M).group(0), \"abc\")\n  self.assertEqual(re.search(r\"^\\Aabc\\Z$\", \"\\nabc\\n\", re.M), None)\n  self.assertEqual(re.search(r\"\\b(b.)\\b\",\n  \"abcd abc bcd bx\").group(1), \"bx\")\n  self.assertEqual(re.search(r\"\\B(b.)\\B\",\n  \"abc bcd bc abxd\").group(1), \"bx\")\n  self.assertEqual(re.search(r\"^abc$\", \"\\nabc\\n\", re.M).group(0), \"abc\")\n  self.assertEqual(re.search(r\"^\\Aabc\\Z$\", \"abc\", re.M).group(0), \"abc\")\n  self.assertEqual(re.search(r\"^\\Aabc\\Z$\", \"\\nabc\\n\", re.M), None)\n  self.assertEqual(re.search(r\"\\d\\D\\w\\W\\s\\S\",\n  \"1aa! a\").group(0), \"1aa! a\")\n  self.assertEqual(re.search(r\"\\d\\D\\w\\W\\s\\S\",\n  \"1aa! a\", re.LOCALE).group(0), \"1aa! a\")\n  self.assertEqual(re.search(r\"\\d\\D\\w\\W\\s\\S\",\n  \"1aa! a\", re.UNICODE).group(0), \"1aa! a\")\n  \n def test_string_boundaries(self):\n \n  self.assertEqual(re.search(r\"\\b(abc)\\b\", \"abc\").group(1),\n  \"abc\")\n  \n  self.assertTrue(re.match(r\"\\b\", \"abc\"))\n  \n  self.assertTrue(re.search(r\"\\B\", \"abc\"))\n  \n  self.assertFalse(re.match(r\"\\B\", \"abc\"))\n  \n  \n  self.assertEqual(re.search(r\"\\B\", \"\"), None)\n  \n  \n  self.assertEqual(re.search(r\"\\b\", \"\"), None)\n  \n  \n  self.assertEqual(len(re.findall(r\"\\b\", \"a\")), 2)\n  self.assertEqual(len(re.findall(r\"\\B\", \"a\")), 0)\n  \n  self.assertEqual(len(re.findall(r\"\\b\", \" \")), 0)\n  self.assertEqual(len(re.findall(r\"\\b\", \"   \")), 0)\n  \n  self.assertEqual(len(re.findall(r\"\\B\", \" \")), 2)\n  \n def test_bigcharset(self):\n  self.assertEqual(re.match(\"([\\u2222\\u2223])\",\n  \"\\u2222\").group(1), \"\\u2222\")\n  self.assertEqual(re.match(\"([\\u2222\\u2223])\",\n  \"\\u2222\", re.UNICODE).group(1), \"\\u2222\")\n  \n def test_big_codesize(self):\n \n  r = re.compile('|'.join(('%d'%x for x in range(10000))))\n  self.assertIsNotNone(r.match('1000'))\n  self.assertIsNotNone(r.match('9999'))\n  \n def test_anyall(self):\n  self.assertEqual(re.match(\"a.b\", \"a\\nb\", re.DOTALL).group(0),\n  \"a\\nb\")\n  self.assertEqual(re.match(\"a.*b\", \"a\\n\\nb\", re.DOTALL).group(0),\n  \"a\\n\\nb\")\n  \n def test_non_consuming(self):\n  self.assertEqual(re.match(\"(a(?=\\s[^a]))\", \"a b\").group(1), \"a\")\n  self.assertEqual(re.match(\"(a(?=\\s[^a]*))\", \"a b\").group(1), \"a\")\n  self.assertEqual(re.match(\"(a(?=\\s[abc]))\", \"a b\").group(1), \"a\")\n  self.assertEqual(re.match(\"(a(?=\\s[abc]*))\", \"a bc\").group(1), \"a\")\n  self.assertEqual(re.match(r\"(a)(?=\\s\\1)\", \"a a\").group(1), \"a\")\n  self.assertEqual(re.match(r\"(a)(?=\\s\\1*)\", \"a aa\").group(1), \"a\")\n  self.assertEqual(re.match(r\"(a)(?=\\s(abc|a))\", \"a a\").group(1), \"a\")\n  \n  self.assertEqual(re.match(r\"(a(?!\\s[^a]))\", \"a a\").group(1), \"a\")\n  self.assertEqual(re.match(r\"(a(?!\\s[abc]))\", \"a d\").group(1), \"a\")\n  self.assertEqual(re.match(r\"(a)(?!\\s\\1)\", \"a b\").group(1), \"a\")\n  self.assertEqual(re.match(r\"(a)(?!\\s(abc|a))\", \"a b\").group(1), \"a\")\n  \n def test_ignore_case(self):\n  self.assertEqual(re.match(\"abc\", \"ABC\", re.I).group(0), \"ABC\")\n  self.assertEqual(re.match(\"abc\", \"ABC\", re.I).group(0), \"ABC\")\n  self.assertEqual(re.match(r\"(a\\s[^a])\", \"a b\", re.I).group(1), \"a b\")\n  self.assertEqual(re.match(r\"(a\\s[^a]*)\", \"a bb\", re.I).group(1), \"a bb\")\n  self.assertEqual(re.match(r\"(a\\s[abc])\", \"a b\", re.I).group(1), \"a b\")\n  self.assertEqual(re.match(r\"(a\\s[abc]*)\", \"a bb\", re.I).group(1), \"a bb\")\n  self.assertEqual(re.match(r\"((a)\\s\\2)\", \"a a\", re.I).group(1), \"a a\")\n  self.assertEqual(re.match(r\"((a)\\s\\2*)\", \"a aa\", re.I).group(1), \"a aa\")\n  self.assertEqual(re.match(r\"((a)\\s(abc|a))\", \"a a\", re.I).group(1), \"a a\")\n  self.assertEqual(re.match(r\"((a)\\s(abc|a)*)\", \"a aa\", re.I).group(1), \"a aa\")\n  \n def test_category(self):\n  self.assertEqual(re.match(r\"(\\s)\", \" \").group(1), \" \")\n  \n def test_getlower(self):\n  import _sre\n  self.assertEqual(_sre.getlower(ord('A'), 0), ord('a'))\n  self.assertEqual(_sre.getlower(ord('A'), re.LOCALE), ord('a'))\n  self.assertEqual(_sre.getlower(ord('A'), re.UNICODE), ord('a'))\n  \n  self.assertEqual(re.match(\"abc\", \"ABC\", re.I).group(0), \"ABC\")\n  self.assertEqual(re.match(\"abc\", \"ABC\", re.I).group(0), \"ABC\")\n  \n def test_not_literal(self):\n  self.assertEqual(re.search(\"\\s([^a])\", \" b\").group(1), \"b\")\n  self.assertEqual(re.search(\"\\s([^a]*)\", \" bb\").group(1), \"bb\")\n  \n def test_search_coverage(self):\n  self.assertEqual(re.search(\"\\s(b)\", \" b\").group(1), \"b\")\n  self.assertEqual(re.search(\"a\\s\", \"a \").group(0), \"a \")\n  \n def assertMatch(self, pattern, text, match=None, span=None,\n matcher=re.match):\n  if match is None and span is None:\n  \n   match = text\n   span = (0, len(text))\n  elif match is None or span is None:\n   raise ValueError('If match is not None, span should be specified '\n   '(and vice versa).')\n  m = matcher(pattern, text)\n  self.assertTrue(m)\n  self.assertEqual(m.group(), match)\n  self.assertEqual(m.span(), span)\n  \n def test_re_escape(self):\n  alnum_chars = string.ascii_letters + string.digits + '_'\n  p = ''.join(chr(i) for i in range(256))\n  for c in p:\n   if c in alnum_chars:\n    self.assertEqual(re.escape(c), c)\n   elif c == '\\x00':\n    self.assertEqual(re.escape(c), '\\\\000')\n   else:\n    self.assertEqual(re.escape(c), '\\\\' + c)\n   self.assertMatch(re.escape(c), c)\n  self.assertMatch(re.escape(p), p)\n  \n def test_re_escape_byte(self):\n  alnum_chars = (string.ascii_letters + string.digits + '_').encode('ascii')\n  p = bytes(range(256))\n  for i in p:\n   b = bytes([i])\n   if b in alnum_chars:\n    self.assertEqual(re.escape(b), b)\n   elif i == 0:\n    self.assertEqual(re.escape(b), b'\\\\000')\n   else:\n    self.assertEqual(re.escape(b), b'\\\\' + b)\n   self.assertMatch(re.escape(b), b)\n  self.assertMatch(re.escape(p), p)\n  \n def test_re_escape_non_ascii(self):\n  s = 'xxx\\u2620\\u2620\\u2620xxx'\n  s_escaped = re.escape(s)\n  self.assertEqual(s_escaped, 'xxx\\\\\\u2620\\\\\\u2620\\\\\\u2620xxx')\n  self.assertMatch(s_escaped, s)\n  self.assertMatch('.%s+.' % re.escape('\\u2620'), s,\n  'x\\u2620\\u2620\\u2620x', (2, 7), re.search)\n  \n def test_re_escape_non_ascii_bytes(self):\n  b = 'y\\u2620y\\u2620y'.encode('utf-8')\n  b_escaped = re.escape(b)\n  self.assertEqual(b_escaped, b'y\\\\\\xe2\\\\\\x98\\\\\\xa0y\\\\\\xe2\\\\\\x98\\\\\\xa0y')\n  self.assertMatch(b_escaped, b)\n  res = re.findall(re.escape('\\u2620'.encode('utf-8')), b)\n  self.assertEqual(len(res), 2)\n  \n def pickle_test(self, pickle):\n  oldpat = re.compile('a(?:b|(c|e){1,2}?|d)+?(.)')\n  s = pickle.dumps(oldpat)\n  newpat = pickle.loads(s)\n  self.assertEqual(oldpat, newpat)\n  \n def test_constants(self):\n  self.assertEqual(re.I, re.IGNORECASE)\n  self.assertEqual(re.L, re.LOCALE)\n  self.assertEqual(re.M, re.MULTILINE)\n  self.assertEqual(re.S, re.DOTALL)\n  self.assertEqual(re.X, re.VERBOSE)\n  \n def test_flags(self):\n  for flag in [re.I, re.M, re.X, re.S, re.L]:\n   self.assertNotEqual(re.compile('^pattern$', flag), None)\n   \n def test_sre_character_literals(self):\n  for i in [0, 8, 16, 32, 64, 127, 128, 255, 256, 0xFFFF, 0x10000, 0x10FFFF]:\n   if i < 256:\n    self.assertIsNotNone(re.match(r\"\\%03o\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"\\%03o0\" % i, chr(i)+\"0\"))\n    self.assertIsNotNone(re.match(r\"\\%03o8\" % i, chr(i)+\"8\"))\n    self.assertIsNotNone(re.match(r\"\\x%02x\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"\\x%02x0\" % i, chr(i)+\"0\"))\n    self.assertIsNotNone(re.match(r\"\\x%02xz\" % i, chr(i)+\"z\"))\n   if i < 0x10000:\n    self.assertIsNotNone(re.match(r\"\\u%04x\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"\\u%04x0\" % i, chr(i)+\"0\"))\n    self.assertIsNotNone(re.match(r\"\\u%04xz\" % i, chr(i)+\"z\"))\n   self.assertIsNotNone(re.match(r\"\\U%08x\" % i, chr(i)))\n   self.assertIsNotNone(re.match(r\"\\U%08x0\" % i, chr(i)+\"0\"))\n   self.assertIsNotNone(re.match(r\"\\U%08xz\" % i, chr(i)+\"z\"))\n  self.assertIsNotNone(re.match(r\"\\0\", \"\\000\"))\n  self.assertIsNotNone(re.match(r\"\\08\", \"\\0008\"))\n  self.assertIsNotNone(re.match(r\"\\01\", \"\\001\"))\n  self.assertIsNotNone(re.match(r\"\\018\", \"\\0018\"))\n  self.assertIsNotNone(re.match(r\"\\567\", chr(0o167)))\n  self.assertRaises(re.error, re.match, r\"\\911\", \"\")\n  self.assertRaises(re.error, re.match, r\"\\x1\", \"\")\n  self.assertRaises(re.error, re.match, r\"\\x1z\", \"\")\n  self.assertRaises(re.error, re.match, r\"\\u123\", \"\")\n  self.assertRaises(re.error, re.match, r\"\\u123z\", \"\")\n  self.assertRaises(re.error, re.match, r\"\\U0001234\", \"\")\n  self.assertRaises(re.error, re.match, r\"\\U0001234z\", \"\")\n  self.assertRaises(re.error, re.match, r\"\\U00110000\", \"\")\n  \n def test_sre_character_class_literals(self):\n  for i in [0, 8, 16, 32, 64, 127, 128, 255, 256, 0xFFFF, 0x10000, 0x10FFFF]:\n   if i < 256:\n    self.assertIsNotNone(re.match(r\"[\\%o]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\%o8]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\%03o]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\%03o0]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\%03o8]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\x%02x]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\x%02x0]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\x%02xz]\" % i, chr(i)))\n   if i < 0x10000:\n    self.assertIsNotNone(re.match(r\"[\\u%04x]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\u%04x0]\" % i, chr(i)))\n    self.assertIsNotNone(re.match(r\"[\\u%04xz]\" % i, chr(i)))\n   self.assertIsNotNone(re.match(r\"[\\U%08x]\" % i, chr(i)))\n   self.assertIsNotNone(re.match(r\"[\\U%08x0]\" % i, chr(i)+\"0\"))\n   self.assertIsNotNone(re.match(r\"[\\U%08xz]\" % i, chr(i)+\"z\"))\n  self.assertIsNotNone(re.match(r\"[\\U0001d49c-\\U0001d4b5]\", \"\\U0001d49e\"))\n  self.assertRaises(re.error, re.match, r\"[\\911]\", \"\")\n  self.assertRaises(re.error, re.match, r\"[\\x1z]\", \"\")\n  self.assertRaises(re.error, re.match, r\"[\\u123z]\", \"\")\n  self.assertRaises(re.error, re.match, r\"[\\U0001234z]\", \"\")\n  self.assertRaises(re.error, re.match, r\"[\\U00110000]\", \"\")\n  \n def test_sre_byte_literals(self):\n  for i in [0, 8, 16, 32, 64, 127, 128, 255]:\n   self.assertIsNotNone(re.match((r\"\\%03o\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"\\%03o0\" % i).encode(), bytes([i])+b\"0\"))\n   self.assertIsNotNone(re.match((r\"\\%03o8\" % i).encode(), bytes([i])+b\"8\"))\n   self.assertIsNotNone(re.match((r\"\\x%02x\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"\\x%02x0\" % i).encode(), bytes([i])+b\"0\"))\n   self.assertIsNotNone(re.match((r\"\\x%02xz\" % i).encode(), bytes([i])+b\"z\"))\n  self.assertIsNotNone(re.match(br\"\\u\", b'u'))\n  self.assertIsNotNone(re.match(br\"\\U\", b'U'))\n  self.assertIsNotNone(re.match(br\"\\0\", b\"\\000\"))\n  self.assertIsNotNone(re.match(br\"\\08\", b\"\\0008\"))\n  self.assertIsNotNone(re.match(br\"\\01\", b\"\\001\"))\n  self.assertIsNotNone(re.match(br\"\\018\", b\"\\0018\"))\n  self.assertIsNotNone(re.match(br\"\\567\", bytes([0o167])))\n  self.assertRaises(re.error, re.match, br\"\\911\", b\"\")\n  self.assertRaises(re.error, re.match, br\"\\x1\", b\"\")\n  self.assertRaises(re.error, re.match, br\"\\x1z\", b\"\")\n  \n def test_sre_byte_class_literals(self):\n  for i in [0, 8, 16, 32, 64, 127, 128, 255]:\n   self.assertIsNotNone(re.match((r\"[\\%o]\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"[\\%o8]\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"[\\%03o]\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"[\\%03o0]\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"[\\%03o8]\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"[\\x%02x]\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"[\\x%02x0]\" % i).encode(), bytes([i])))\n   self.assertIsNotNone(re.match((r\"[\\x%02xz]\" % i).encode(), bytes([i])))\n  self.assertIsNotNone(re.match(br\"[\\u]\", b'u'))\n  self.assertIsNotNone(re.match(br\"[\\U]\", b'U'))\n  self.assertRaises(re.error, re.match, br\"[\\911]\", \"\")\n  self.assertRaises(re.error, re.match, br\"[\\x1z]\", \"\")\n  \n def test_bug_113254(self):\n  self.assertEqual(re.match(r'(a)|(b)', 'b').start(1), -1)\n  self.assertEqual(re.match(r'(a)|(b)', 'b').end(1), -1)\n  self.assertEqual(re.match(r'(a)|(b)', 'b').span(1), (-1, -1))\n  \n def test_bug_527371(self):\n \n  self.assertEqual(re.match(r'(a)?a','a').lastindex, None)\n  self.assertEqual(re.match(r'(a)(b)?b','ab').lastindex, 1)\n  self.assertEqual(re.match(r'(?P<a>a)(?P<b>b)?b','ab').lastgroup, 'a')\n  self.assertEqual(re.match(\"(?P<a>a(b))\", \"ab\").lastgroup, 'a')\n  self.assertEqual(re.match(\"((a))\", \"a\").lastindex, 1)\n  \n def test_bug_545855(self):\n \n \n  self.assertRaises(re.error, re.compile, 'foo[a-')\n  \n def test_bug_418626(self):\n \n \n \n  self.assertEqual(re.match('.*?c', 10000*'ab'+'cd').end(0), 20001)\n  self.assertEqual(re.match('.*?cd', 5000*'ab'+'c'+5000*'ab'+'cde').end(0),\n  20003)\n  self.assertEqual(re.match('.*?cd', 20000*'abc'+'de').end(0), 60001)\n  \n  \n  self.assertEqual(re.search('(a|b)*?c', 10000*'ab'+'cd').end(0), 20001)\n  \n def test_bug_612074(self):\n  pat=\"[\"+re.escape(\"\\u2039\")+\"]\"\n  self.assertEqual(re.compile(pat) and 1, 1)\n  \n def test_stack_overflow(self):\n \n \n  self.assertEqual(re.match('(x)*', 50000*'x').group(1), 'x')\n  self.assertEqual(re.match('(x)*y', 50000*'x'+'y').group(1), 'x')\n  self.assertEqual(re.match('(x)*?y', 50000*'x'+'y').group(1), 'x')\n  \n def test_unlimited_zero_width_repeat(self):\n \n  self.assertIsNone(re.match(r'(?:a?)*y', 'z'))\n  self.assertIsNone(re.match(r'(?:a?)+y', 'z'))\n  self.assertIsNone(re.match(r'(?:a?){2,}y', 'z'))\n  self.assertIsNone(re.match(r'(?:a?)*?y', 'z'))\n  self.assertIsNone(re.match(r'(?:a?)+?y', 'z'))\n  self.assertIsNone(re.match(r'(?:a?){2,}?y', 'z'))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_bug_448951(self):\n \n \n  for op in '','?','*':\n   self.assertEqual(re.match(r'((.%s):)?z'%op, 'z').groups(),\n   (None, None))\n   self.assertEqual(re.match(r'((.%s):)?z'%op, 'a:z').groups(),\n   ('a:', 'a'))\n   \n def test_bug_725106(self):\n \n  self.assertEqual(re.match('^((a)|b)*', 'abc').groups(),\n  ('b', 'a'))\n  self.assertEqual(re.match('^(([ab])|c)*', 'abc').groups(),\n  ('c', 'b'))\n  self.assertEqual(re.match('^((d)|[ab])*', 'abc').groups(),\n  ('b', None))\n  self.assertEqual(re.match('^((a)c|[ab])*', 'abc').groups(),\n  ('b', None))\n  self.assertEqual(re.match('^((a)|b)*?c', 'abc').groups(),\n  ('b', 'a'))\n  self.assertEqual(re.match('^(([ab])|c)*?d', 'abcd').groups(),\n  ('c', 'b'))\n  self.assertEqual(re.match('^((d)|[ab])*?c', 'abc').groups(),\n  ('b', None))\n  self.assertEqual(re.match('^((a)c|[ab])*?c', 'abc').groups(),\n  ('b', None))\n  \n def test_bug_725149(self):\n \n  self.assertEqual(re.match('(a)(?:(?=(b)*)c)*', 'abb').groups(),\n  ('a', None))\n  self.assertEqual(re.match('(a)((?!(b)*))*', 'abb').groups(),\n  ('a', None, None))\n  \n def test_bug_764548(self):\n \n  class my_unicode(str): pass\n  pat = re.compile(my_unicode(\"abc\"))\n  self.assertEqual(pat.match(\"xyz\"), None)\n  \n def test_finditer(self):\n  iter = re.finditer(r\":+\", \"a:b::c:::d\")\n  self.assertEqual([item.group(0) for item in iter],\n  [\":\", \"::\", \":::\"])\n  \n  pat = re.compile(r\":+\")\n  iter = pat.finditer(\"a:b::c:::d\", 1, 10)\n  self.assertEqual([item.group(0) for item in iter],\n  [\":\", \"::\", \":::\"])\n  \n  pat = re.compile(r\":+\")\n  iter = pat.finditer(\"a:b::c:::d\", pos=1, endpos=10)\n  self.assertEqual([item.group(0) for item in iter],\n  [\":\", \"::\", \":::\"])\n  \n  pat = re.compile(r\":+\")\n  iter = pat.finditer(\"a:b::c:::d\", endpos=10, pos=1)\n  self.assertEqual([item.group(0) for item in iter],\n  [\":\", \"::\", \":::\"])\n  \n  pat = re.compile(r\":+\")\n  iter = pat.finditer(\"a:b::c:::d\", pos=3, endpos=8)\n  self.assertEqual([item.group(0) for item in iter],\n  [\"::\", \"::\"])\n  \n def test_bug_926075(self):\n  self.assertTrue(re.compile('bug_926075') is not\n  re.compile(b'bug_926075'))\n  \n def test_bug_931848(self):\n  pattern = eval('\"[\\u002E\\u3002\\uFF0E\\uFF61]\"')\n  self.assertEqual(re.compile(pattern).split(\"a.b.c\"),\n  ['a','b','c'])\n  \n def test_bug_581080(self):\n  iter = re.finditer(r\"\\s\", \"a b\")\n  self.assertEqual(next(iter).span(), (1,2))\n  self.assertRaises(StopIteration, next, iter)\n  \n  scanner = re.compile(r\"\\s\").scanner(\"a b\")\n  self.assertEqual(scanner.search().span(), (1, 2))\n  self.assertEqual(scanner.search(), None)\n  \n def test_bug_817234(self):\n  iter = re.finditer(r\".*\", \"asdf\")\n  self.assertEqual(next(iter).span(), (0, 4))\n  self.assertEqual(next(iter).span(), (4, 4))\n  self.assertRaises(StopIteration, next, iter)\n  \n def test_bug_6561(self):\n \n \n \n  decimal_digits = [\n  '\\u0037', \n  '\\u0e58', \n  '\\uff10', \n  ]\n  for x in decimal_digits:\n   self.assertEqual(re.match('^\\d$', x).group(0), x)\n   \n  not_decimal_digits = [\n  '\\u2165', \n  '\\u3039', \n  '\\u2082', \n  '\\u32b4', \n  ]\n  for x in not_decimal_digits:\n   self.assertIsNone(re.match('^\\d$', x))\n   \n def test_empty_array(self):\n \n  import array\n  for typecode in 'bBuhHiIlLfd':\n   a = array.array(typecode)\n   self.assertEqual(re.compile(b\"bla\").match(a), None)\n   self.assertEqual(re.compile(b\"\").match(a).groups(), ())\n   \n def test_inline_flags(self):\n \n  upper_char = chr(0x1ea0) \n  lower_char = chr(0x1ea1) \n  \n  p = re.compile(upper_char, re.I | re.U)\n  q = p.match(lower_char)\n  self.assertNotEqual(q, None)\n  \n  p = re.compile(lower_char, re.I | re.U)\n  q = p.match(upper_char)\n  self.assertNotEqual(q, None)\n  \n  p = re.compile('(?i)' + upper_char, re.U)\n  q = p.match(lower_char)\n  self.assertNotEqual(q, None)\n  \n  p = re.compile('(?i)' + lower_char, re.U)\n  q = p.match(upper_char)\n  self.assertNotEqual(q, None)\n  \n  p = re.compile('(?iu)' + upper_char)\n  q = p.match(lower_char)\n  self.assertNotEqual(q, None)\n  \n  p = re.compile('(?iu)' + lower_char)\n  q = p.match(upper_char)\n  self.assertNotEqual(q, None)\n  \n def test_dollar_matches_twice(self):\n  \"\"\n  pattern = re.compile('$')\n  self.assertEqual(pattern.sub('#', 'a\\nb\\n'), 'a\\nb#\\n#')\n  self.assertEqual(pattern.sub('#', 'a\\nb\\nc'), 'a\\nb\\nc#')\n  self.assertEqual(pattern.sub('#', '\\n'), '#\\n#')\n  \n  pattern = re.compile('$', re.MULTILINE)\n  self.assertEqual(pattern.sub('#', 'a\\nb\\n' ), 'a#\\nb#\\n#' )\n  self.assertEqual(pattern.sub('#', 'a\\nb\\nc'), 'a#\\nb#\\nc#')\n  self.assertEqual(pattern.sub('#', '\\n'), '#\\n#')\n  \n def test_bytes_str_mixing(self):\n \n  pat = re.compile('.')\n  bpat = re.compile(b'.')\n  self.assertRaises(TypeError, pat.match, b'b')\n  self.assertRaises(TypeError, bpat.match, 'b')\n  self.assertRaises(TypeError, pat.sub, b'b', 'c')\n  self.assertRaises(TypeError, pat.sub, 'b', b'c')\n  self.assertRaises(TypeError, pat.sub, b'b', b'c')\n  self.assertRaises(TypeError, bpat.sub, b'b', 'c')\n  self.assertRaises(TypeError, bpat.sub, 'b', b'c')\n  self.assertRaises(TypeError, bpat.sub, 'b', 'c')\n  \n def test_ascii_and_unicode_flag(self):\n \n  for flags in (0, re.UNICODE):\n   pat = re.compile('\\xc0', flags | re.IGNORECASE)\n   self.assertNotEqual(pat.match('\\xe0'), None)\n   pat = re.compile('\\w', flags)\n   self.assertNotEqual(pat.match('\\xe0'), None)\n  pat = re.compile('\\xc0', re.ASCII | re.IGNORECASE)\n  self.assertEqual(pat.match('\\xe0'), None)\n  pat = re.compile('(?a)\\xc0', re.IGNORECASE)\n  self.assertEqual(pat.match('\\xe0'), None)\n  pat = re.compile('\\w', re.ASCII)\n  self.assertEqual(pat.match('\\xe0'), None)\n  pat = re.compile('(?a)\\w')\n  self.assertEqual(pat.match('\\xe0'), None)\n  \n  for flags in (0, re.ASCII):\n   pat = re.compile(b'\\xc0', re.IGNORECASE)\n   self.assertEqual(pat.match(b'\\xe0'), None)\n   pat = re.compile(b'\\w')\n   self.assertEqual(pat.match(b'\\xe0'), None)\n   \n  self.assertRaises(ValueError, re.compile, b'\\w', re.UNICODE)\n  self.assertRaises(ValueError, re.compile, b'(?u)\\w')\n  self.assertRaises(ValueError, re.compile, '\\w', re.UNICODE | re.ASCII)\n  self.assertRaises(ValueError, re.compile, '(?u)\\w', re.ASCII)\n  self.assertRaises(ValueError, re.compile, '(?a)\\w', re.UNICODE)\n  self.assertRaises(ValueError, re.compile, '(?au)\\w')\n  \n def test_bug_6509(self):\n \n \n  pat = re.compile('a(\\w)')\n  self.assertEqual(pat.sub('b\\\\1', 'ac'), 'bc')\n  pat = re.compile('a(.)')\n  self.assertEqual(pat.sub('b\\\\1', 'a\\u1234'), 'b\\u1234')\n  pat = re.compile('..')\n  self.assertEqual(pat.sub(lambda m: 'str', 'a5'), 'str')\n  \n  \n  pat = re.compile(b'a(\\w)')\n  self.assertEqual(pat.sub(b'b\\\\1', b'ac'), b'bc')\n  pat = re.compile(b'a(.)')\n  self.assertEqual(pat.sub(b'b\\\\1', b'a\\xCD'), b'b\\xCD')\n  pat = re.compile(b'..')\n  self.assertEqual(pat.sub(lambda m: b'bytes', b'a5'), b'bytes')\n  \n def test_dealloc(self):\n \n  import _sre\n  \n  \n  \n  \n  long_overflow = 2**128\n  self.assertRaises(TypeError, re.finditer, \"a\", {})\n  self.assertRaises(OverflowError, _sre.compile, \"abc\", 0, [long_overflow])\n  self.assertRaises(TypeError, _sre.compile, {}, 0, [])\n  \n def test_search_dot_unicode(self):\n  self.assertIsNotNone(re.search(\"123.*-\", '123abc-'))\n  self.assertIsNotNone(re.search(\"123.*-\", '123\\xe9-'))\n  self.assertIsNotNone(re.search(\"123.*-\", '123\\u20ac-'))\n  self.assertIsNotNone(re.search(\"123.*-\", '123\\U0010ffff-'))\n  self.assertIsNotNone(re.search(\"123.*-\", '123\\xe9\\u20ac\\U0010ffff-'))\n  \n def test_compile(self):\n \n  pattern = re.compile('random pattern')\n  self.assertIsInstance(pattern, re._pattern_type)\n  same_pattern = re.compile(pattern)\n  self.assertIsInstance(same_pattern, re._pattern_type)\n  self.assertIs(same_pattern, pattern)\n  \n  self.assertRaises(TypeError, re.compile, 0)\n  \n def test_bug_13899(self):\n \n \n  self.assertEqual(re.findall(r'[\\A\\B\\b\\C\\Z]', 'AB\\bCZ'),\n  ['A', 'B', '\\b', 'C', 'Z'])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_bug_16688(self):\n \n \n  self.assertEqual(re.findall(r\"(?i)(a)\\1\", \"aa \\u0100\"), ['a'])\n  self.assertEqual(re.match(r\"(?s).{1,3}\", \"\\u0100\\u0100\").span(), (0, 2))\n  \n def test_repeat_minmax_overflow(self):\n \n  string = \"x\" * 100000\n  self.assertEqual(re.match(r\".{65535}\", string).span(), (0, 65535))\n  self.assertEqual(re.match(r\".{,65535}\", string).span(), (0, 65535))\n  self.assertEqual(re.match(r\".{65535,}?\", string).span(), (0, 65535))\n  self.assertEqual(re.match(r\".{65536}\", string).span(), (0, 65536))\n  self.assertEqual(re.match(r\".{,65536}\", string).span(), (0, 65536))\n  self.assertEqual(re.match(r\".{65536,}?\", string).span(), (0, 65536))\n  \n  self.assertRaises(OverflowError, re.compile, r\".{%d}\" % 2**128)\n  self.assertRaises(OverflowError, re.compile, r\".{,%d}\" % 2**128)\n  self.assertRaises(OverflowError, re.compile, r\".{%d,}?\" % 2**128)\n  self.assertRaises(OverflowError, re.compile, r\".{%d,%d}\" % (2**129, 2**128))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_backref_group_name_in_exception(self):\n \n  with self.assertRaisesRegex(sre_constants.error, '<foo>'):\n   re.compile('(?P=<foo>)')\n   \n def test_group_name_in_exception(self):\n \n  with self.assertRaisesRegex(sre_constants.error, '\\?foo'):\n   re.compile('(?P<?foo>)')\n   \n   \ndef run_re_tests():\n from test.re_tests import tests, SUCCEED, FAIL, SYNTAX_ERROR\n if verbose:\n  print('Running re_tests test suite')\n else:\n \n \n  pass\n  \n for t in tests:\n  sys.stdout.flush()\n  pattern = s = outcome = repl = expected = None\n  if len(t) == 5:\n   pattern, s, outcome, repl, expected = t\n  elif len(t) == 3:\n   pattern, s, outcome = t\n  else:\n   raise ValueError('Test tuples should have 3 or 5 fields', t)\n   \n  try:\n   obj = re.compile(pattern)\n  except re.error:\n   if outcome == SYNTAX_ERROR: pass \n   else:\n    print('=== Syntax error:', t)\n  except KeyboardInterrupt: raise KeyboardInterrupt\n  except:\n   print('*** Unexpected error ***', t)\n   if verbose:\n    traceback.print_exc(file=sys.stdout)\n  else:\n   try:\n    result = obj.search(s)\n   except re.error as msg:\n    print('=== Unexpected exception', t, repr(msg))\n   if outcome == SYNTAX_ERROR:\n   \n    pass\n   elif outcome == FAIL:\n    if result is None: pass \n    else: print('=== Succeeded incorrectly', t)\n   elif outcome == SUCCEED:\n    if result is not None:\n    \n    \n     start, end = result.span(0)\n     vardict={'found': result.group(0),\n     'groups': result.group(),\n     'flags': result.re.flags}\n     for i in range(1, 100):\n      try:\n       gi = result.group(i)\n       \n       if gi is None:\n        gi = \"None\"\n      except IndexError:\n       gi = \"Error\"\n      vardict['g%d' % i] = gi\n     for i in result.re.groupindex.keys():\n      try:\n       gi = result.group(i)\n       if gi is None:\n        gi = \"None\"\n      except IndexError:\n       gi = \"Error\"\n      vardict[i] = gi\n     repl = eval(repl, vardict)\n     if repl != expected:\n      print('=== grouping error', t, end=' ')\n      print(repr(repl) + ' should be ' + repr(expected))\n    else:\n     print('=== Failed incorrectly', t)\n     \n     \n     \n    try:\n     bpat = bytes(pattern, \"ascii\")\n     bs = bytes(s, \"ascii\")\n    except UnicodeEncodeError:\n    \n     pass\n    else:\n     try:\n      bpat = re.compile(bpat)\n     except Exception:\n      print('=== Fails on bytes pattern compile', t)\n      if verbose:\n       traceback.print_exc(file=sys.stdout)\n     else:\n      bytes_result = bpat.search(bs)\n      if bytes_result is None:\n       print('=== Fails on bytes pattern match', t)\n       \n       \n       \n       \n       \n       \n    if pattern[:2] != '\\\\B' and pattern[-2:] != '\\\\B' and result is not None:\n     obj = re.compile(pattern)\n     result = obj.search(s, result.start(0), result.end(0) + 1)\n     if result is None:\n      print('=== Failed on range-limited match', t)\n      \n      \n      \n    obj = re.compile(pattern, re.IGNORECASE)\n    result = obj.search(s)\n    if result is None:\n     print('=== Fails on case-insensitive match', t)\n     \n     \n     \n    if '(?u)' not in pattern:\n     obj = re.compile(pattern, re.LOCALE)\n     result = obj.search(s)\n     if result is None:\n      print('=== Fails on locale-sensitive match', t)\n      \n      \n      \n    obj = re.compile(pattern, re.UNICODE)\n    result = obj.search(s)\n    if result is None:\n     print('=== Fails on unicode-sensitive match', t)\n     \n     \ndef test_main():\n\n\n run_re_tests()\n \nif __name__ == \"__main__\":\n test_main()\n"], "unittest.test.testmock.testwith": ["import unittest\nfrom warnings import catch_warnings\n\nfrom unittest.test.testmock.support import is_instance\nfrom unittest.mock import MagicMock, Mock, patch, sentinel, mock_open, call\n\n\n\nsomething = sentinel.Something\nsomething_else = sentinel.SomethingElse\n\n\n\nclass WithTest(unittest.TestCase):\n\n def test_with_statement(self):\n  with patch('%s.something' % __name__, sentinel.Something2):\n   self.assertEqual(something, sentinel.Something2, \"unpatched\")\n  self.assertEqual(something, sentinel.Something)\n  \n  \n def test_with_statement_exception(self):\n  try:\n   with patch('%s.something' % __name__, sentinel.Something2):\n    self.assertEqual(something, sentinel.Something2, \"unpatched\")\n    raise Exception('pow')\n  except Exception:\n   pass\n  else:\n   self.fail(\"patch swallowed exception\")\n  self.assertEqual(something, sentinel.Something)\n  \n  \n def test_with_statement_as(self):\n  with patch('%s.something' % __name__) as mock_something:\n   self.assertEqual(something, mock_something, \"unpatched\")\n   self.assertTrue(is_instance(mock_something, MagicMock),\n   \"patching wrong type\")\n  self.assertEqual(something, sentinel.Something)\n  \n  \n def test_patch_object_with_statement(self):\n  class Foo(object):\n   something = 'foo'\n  original = Foo.something\n  with patch.object(Foo, 'something'):\n   self.assertNotEqual(Foo.something, original, \"unpatched\")\n  self.assertEqual(Foo.something, original)\n  \n  \n def test_with_statement_nested(self):\n  with catch_warnings(record=True):\n   with patch('%s.something' % __name__) as mock_something, patch('%s.something_else' % __name__) as mock_something_else:\n    self.assertEqual(something, mock_something, \"unpatched\")\n    self.assertEqual(something_else, mock_something_else,\n    \"unpatched\")\n    \n  self.assertEqual(something, sentinel.Something)\n  self.assertEqual(something_else, sentinel.SomethingElse)\n  \n  \n def test_with_statement_specified(self):\n  with patch('%s.something' % __name__, sentinel.Patched) as mock_something:\n   self.assertEqual(something, mock_something, \"unpatched\")\n   self.assertEqual(mock_something, sentinel.Patched, \"wrong patch\")\n  self.assertEqual(something, sentinel.Something)\n  \n  \n def testContextManagerMocking(self):\n  mock = Mock()\n  mock.__enter__ = Mock()\n  mock.__exit__ = Mock()\n  mock.__exit__.return_value = False\n  \n  with mock as m:\n   self.assertEqual(m, mock.__enter__.return_value)\n  mock.__enter__.assert_called_with()\n  mock.__exit__.assert_called_with(None, None, None)\n  \n  \n def test_context_manager_with_magic_mock(self):\n  mock = MagicMock()\n  \n  with self.assertRaises(TypeError):\n   with mock:\n    \"\" + 3\n  mock.__enter__.assert_called_with()\n  self.assertTrue(mock.__exit__.called)\n  \n  \n def test_with_statement_same_attribute(self):\n  with patch('%s.something' % __name__, sentinel.Patched) as mock_something:\n   self.assertEqual(something, mock_something, \"unpatched\")\n   \n   with patch('%s.something' % __name__) as mock_again:\n    self.assertEqual(something, mock_again, \"unpatched\")\n    \n   self.assertEqual(something, mock_something,\n   \"restored with wrong instance\")\n   \n  self.assertEqual(something, sentinel.Something, \"not restored\")\n  \n  \n def test_with_statement_imbricated(self):\n  with patch('%s.something' % __name__) as mock_something:\n   self.assertEqual(something, mock_something, \"unpatched\")\n   \n   with patch('%s.something_else' % __name__) as mock_something_else:\n    self.assertEqual(something_else, mock_something_else,\n    \"unpatched\")\n    \n  self.assertEqual(something, sentinel.Something)\n  self.assertEqual(something_else, sentinel.SomethingElse)\n  \n  \n def test_dict_context_manager(self):\n  foo = {}\n  with patch.dict(foo, {'a': 'b'}):\n   self.assertEqual(foo, {'a': 'b'})\n  self.assertEqual(foo, {})\n  \n  with self.assertRaises(NameError):\n   with patch.dict(foo, {'a': 'b'}):\n    self.assertEqual(foo, {'a': 'b'})\n    raise NameError('Konrad')\n    \n  self.assertEqual(foo, {})\n  \n  \n  \nclass TestMockOpen(unittest.TestCase):\n\n def test_mock_open(self):\n  mock = mock_open()\n  with patch('%s.open' % __name__, mock, create=True) as patched:\n   self.assertIs(patched, mock)\n   open('foo')\n   \n  mock.assert_called_once_with('foo')\n  \n  \n def test_mock_open_context_manager(self):\n  mock = mock_open()\n  handle = mock.return_value\n  with patch('%s.open' % __name__, mock, create=True):\n   with open('foo') as f:\n    f.read()\n    \n  expected_calls = [call('foo'), call().__enter__(), call().read(),\n  call().__exit__(None, None, None)]\n  self.assertEqual(mock.mock_calls, expected_calls)\n  self.assertIs(f, handle)\n  \n  \n def test_explicit_mock(self):\n  mock = MagicMock()\n  mock_open(mock)\n  \n  with patch('%s.open' % __name__, mock, create=True) as patched:\n   self.assertIs(patched, mock)\n   open('foo')\n   \n  mock.assert_called_once_with('foo')\n  \n  \n def test_read_data(self):\n  mock = mock_open(read_data='foo')\n  with patch('%s.open' % __name__, mock, create=True):\n   h = open('bar')\n   result = h.read()\n   \n  self.assertEqual(result, 'foo')\n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.test.testmock.testsentinel": ["import unittest\nfrom unittest.mock import sentinel, DEFAULT\n\n\nclass SentinelTest(unittest.TestCase):\n\n def testSentinels(self):\n  self.assertEqual(sentinel.whatever, sentinel.whatever,\n  'sentinel not stored')\n  self.assertNotEqual(sentinel.whatever, sentinel.whateverelse,\n  'sentinel should be unique')\n  \n  \n def testSentinelName(self):\n  self.assertEqual(str(sentinel.whatever), 'sentinel.whatever',\n  'sentinel name incorrect')\n  \n  \n def testDEFAULT(self):\n  self.assertTrue(DEFAULT is sentinel.DEFAULT)\n  \n def testBases(self):\n \n  self.assertRaises(AttributeError, lambda: sentinel.__bases__)\n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.test.testmock.testpatch": ["\n\n\n\nimport os\nimport sys\n\nimport unittest\nfrom unittest.test.testmock import support\nfrom unittest.test.testmock.support import SomeClass, is_instance\n\nfrom unittest.mock import (\nNonCallableMock, CallableMixin, patch, sentinel,\nMagicMock, Mock, NonCallableMagicMock, patch, _patch,\nDEFAULT, call, _get_target\n)\n\n\nbuiltin_string = 'builtins'\n\nPTModule = sys.modules[__name__]\nMODNAME = '%s.PTModule' % __name__\n\n\ndef _get_proxy(obj, get_only=True):\n class Proxy(object):\n  def __getattr__(self, name):\n   return getattr(obj, name)\n if not get_only:\n  def __setattr__(self, name, value):\n   setattr(obj, name, value)\n  def __delattr__(self, name):\n   delattr(obj, name)\n  Proxy.__setattr__ = __setattr__\n  Proxy.__delattr__ = __delattr__\n return Proxy()\n \n \n \nsomething = sentinel.Something\nsomething_else = sentinel.SomethingElse\n\n\nclass Foo(object):\n def __init__(self, a):\n  pass\n def f(self, a):\n  pass\n def g(self):\n  pass\n foo = 'bar'\n \n class Bar(object):\n  def a(self):\n   pass\n   \nfoo_name = '%s.Foo' % __name__\n\n\ndef function(a, b=Foo):\n pass\n \n \nclass Container(object):\n def __init__(self):\n  self.values = {}\n  \n def __getitem__(self, name):\n  return self.values[name]\n  \n def __setitem__(self, name, value):\n  self.values[name] = value\n  \n def __delitem__(self, name):\n  del self.values[name]\n  \n def __iter__(self):\n  return iter(self.values)\n  \n  \n  \nclass PatchTest(unittest.TestCase):\n\n def assertNotCallable(self, obj, magic=True):\n  MockClass = NonCallableMagicMock\n  if not magic:\n   MockClass = NonCallableMock\n   \n  self.assertRaises(TypeError, obj)\n  self.assertTrue(is_instance(obj, MockClass))\n  self.assertFalse(is_instance(obj, CallableMixin))\n  \n  \n def test_single_patchobject(self):\n  class Something(object):\n   attribute = sentinel.Original\n   \n  @patch.object(Something, 'attribute', sentinel.Patched)\n  def test():\n   self.assertEqual(Something.attribute, sentinel.Patched, \"unpatched\")\n   \n  test()\n  self.assertEqual(Something.attribute, sentinel.Original,\n  \"patch not restored\")\n  \n  \n def test_patchobject_with_none(self):\n  class Something(object):\n   attribute = sentinel.Original\n   \n  @patch.object(Something, 'attribute', None)\n  def test():\n   self.assertIsNone(Something.attribute, \"unpatched\")\n   \n  test()\n  self.assertEqual(Something.attribute, sentinel.Original,\n  \"patch not restored\")\n  \n  \n def test_multiple_patchobject(self):\n  class Something(object):\n   attribute = sentinel.Original\n   next_attribute = sentinel.Original2\n   \n  @patch.object(Something, 'attribute', sentinel.Patched)\n  @patch.object(Something, 'next_attribute', sentinel.Patched2)\n  def test():\n   self.assertEqual(Something.attribute, sentinel.Patched,\n   \"unpatched\")\n   self.assertEqual(Something.next_attribute, sentinel.Patched2,\n   \"unpatched\")\n   \n  test()\n  self.assertEqual(Something.attribute, sentinel.Original,\n  \"patch not restored\")\n  self.assertEqual(Something.next_attribute, sentinel.Original2,\n  \"patch not restored\")\n  \n  \n def test_object_lookup_is_quite_lazy(self):\n  global something\n  original = something\n  @patch('%s.something' % __name__, sentinel.Something2)\n  def test():\n   pass\n   \n  try:\n   something = sentinel.replacement_value\n   test()\n   self.assertEqual(something, sentinel.replacement_value)\n  finally:\n   something = original\n   \n   \n def test_patch(self):\n  @patch('%s.something' % __name__, sentinel.Something2)\n  def test():\n   self.assertEqual(PTModule.something, sentinel.Something2,\n   \"unpatched\")\n   \n  test()\n  self.assertEqual(PTModule.something, sentinel.Something,\n  \"patch not restored\")\n  \n  @patch('%s.something' % __name__, sentinel.Something2)\n  @patch('%s.something_else' % __name__, sentinel.SomethingElse)\n  def test():\n   self.assertEqual(PTModule.something, sentinel.Something2,\n   \"unpatched\")\n   self.assertEqual(PTModule.something_else, sentinel.SomethingElse,\n   \"unpatched\")\n   \n  self.assertEqual(PTModule.something, sentinel.Something,\n  \"patch not restored\")\n  self.assertEqual(PTModule.something_else, sentinel.SomethingElse,\n  \"patch not restored\")\n  \n  \n  test()\n  \n  self.assertEqual(PTModule.something, sentinel.Something,\n  \"patch not restored\")\n  self.assertEqual(PTModule.something_else, sentinel.SomethingElse,\n  \"patch not restored\")\n  \n  mock = Mock()\n  mock.return_value = sentinel.Handle\n  @patch('%s.open' % builtin_string, mock)\n  def test():\n   self.assertEqual(open('filename', 'r'), sentinel.Handle,\n   \"open not patched\")\n  test()\n  test()\n  \n  self.assertNotEqual(open, mock, \"patch not restored\")\n  \n  \n def test_patch_class_attribute(self):\n  @patch('%s.SomeClass.class_attribute' % __name__,\n  sentinel.ClassAttribute)\n  def test():\n   self.assertEqual(PTModule.SomeClass.class_attribute,\n   sentinel.ClassAttribute, \"unpatched\")\n  test()\n  \n  self.assertIsNone(PTModule.SomeClass.class_attribute,\n  \"patch not restored\")\n  \n  \n def test_patchobject_with_default_mock(self):\n  class Test(object):\n   something = sentinel.Original\n   something2 = sentinel.Original2\n   \n  @patch.object(Test, 'something')\n  def test(mock):\n   self.assertEqual(mock, Test.something,\n   \"Mock not passed into test function\")\n   self.assertIsInstance(mock, MagicMock,\n   \"patch with two arguments did not create a mock\")\n   \n  test()\n  \n  @patch.object(Test, 'something')\n  @patch.object(Test, 'something2')\n  def test(this1, this2, mock1, mock2):\n   self.assertEqual(this1, sentinel.this1,\n   \"Patched function didn't receive initial argument\")\n   self.assertEqual(this2, sentinel.this2,\n   \"Patched function didn't receive second argument\")\n   self.assertEqual(mock1, Test.something2,\n   \"Mock not passed into test function\")\n   self.assertEqual(mock2, Test.something,\n   \"Second Mock not passed into test function\")\n   self.assertIsInstance(mock2, MagicMock,\n   \"patch with two arguments did not create a mock\")\n   self.assertIsInstance(mock2, MagicMock,\n   \"patch with two arguments did not create a mock\")\n   \n   \n   self.assertNotEqual(outerMock1, mock1, \"unexpected value for mock1\")\n   self.assertNotEqual(outerMock2, mock2, \"unexpected value for mock1\")\n   return mock1, mock2\n   \n  outerMock1 = outerMock2 = None\n  outerMock1, outerMock2 = test(sentinel.this1, sentinel.this2)\n  \n  \n  test(sentinel.this1, sentinel.this2)\n  \n  \n def test_patch_with_spec(self):\n  @patch('%s.SomeClass' % __name__, spec=SomeClass)\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass, MockSomeClass)\n   self.assertTrue(is_instance(SomeClass.wibble, MagicMock))\n   self.assertRaises(AttributeError, lambda: SomeClass.not_wibble)\n   \n  test()\n  \n  \n def test_patchobject_with_spec(self):\n  @patch.object(SomeClass, 'class_attribute', spec=SomeClass)\n  def test(MockAttribute):\n   self.assertEqual(SomeClass.class_attribute, MockAttribute)\n   self.assertTrue(is_instance(SomeClass.class_attribute.wibble,\n   MagicMock))\n   self.assertRaises(AttributeError,\n   lambda: SomeClass.class_attribute.not_wibble)\n   \n  test()\n  \n  \n def test_patch_with_spec_as_list(self):\n  @patch('%s.SomeClass' % __name__, spec=['wibble'])\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass, MockSomeClass)\n   self.assertTrue(is_instance(SomeClass.wibble, MagicMock))\n   self.assertRaises(AttributeError, lambda: SomeClass.not_wibble)\n   \n  test()\n  \n  \n def test_patchobject_with_spec_as_list(self):\n  @patch.object(SomeClass, 'class_attribute', spec=['wibble'])\n  def test(MockAttribute):\n   self.assertEqual(SomeClass.class_attribute, MockAttribute)\n   self.assertTrue(is_instance(SomeClass.class_attribute.wibble,\n   MagicMock))\n   self.assertRaises(AttributeError,\n   lambda: SomeClass.class_attribute.not_wibble)\n   \n  test()\n  \n  \n def test_nested_patch_with_spec_as_list(self):\n \n  @patch('%s.open' % builtin_string)\n  @patch('%s.SomeClass' % __name__, spec=['wibble'])\n  def test(MockSomeClass, MockOpen):\n   self.assertEqual(SomeClass, MockSomeClass)\n   self.assertTrue(is_instance(SomeClass.wibble, MagicMock))\n   self.assertRaises(AttributeError, lambda: SomeClass.not_wibble)\n  test()\n  \n  \n def test_patch_with_spec_as_boolean(self):\n  @patch('%s.SomeClass' % __name__, spec=True)\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass, MockSomeClass)\n   \n   MockSomeClass.wibble\n   \n   self.assertRaises(AttributeError, lambda: MockSomeClass.not_wibble)\n   \n  test()\n  \n  \n def test_patch_object_with_spec_as_boolean(self):\n  @patch.object(PTModule, 'SomeClass', spec=True)\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass, MockSomeClass)\n   \n   MockSomeClass.wibble\n   \n   self.assertRaises(AttributeError, lambda: MockSomeClass.not_wibble)\n   \n  test()\n  \n  \n def test_patch_class_acts_with_spec_is_inherited(self):\n  @patch('%s.SomeClass' % __name__, spec=True)\n  def test(MockSomeClass):\n   self.assertTrue(is_instance(MockSomeClass, MagicMock))\n   instance = MockSomeClass()\n   self.assertNotCallable(instance)\n   \n   instance.wibble\n   \n   self.assertRaises(AttributeError, lambda: instance.not_wibble)\n   \n  test()\n  \n  \n def test_patch_with_create_mocks_non_existent_attributes(self):\n  @patch('%s.frooble' % builtin_string, sentinel.Frooble, create=True)\n  def test():\n   self.assertEqual(frooble, sentinel.Frooble)\n   \n  test()\n  self.assertRaises(NameError, lambda: frooble)\n  \n  \n def test_patchobject_with_create_mocks_non_existent_attributes(self):\n  @patch.object(SomeClass, 'frooble', sentinel.Frooble, create=True)\n  def test():\n   self.assertEqual(SomeClass.frooble, sentinel.Frooble)\n   \n  test()\n  self.assertFalse(hasattr(SomeClass, 'frooble'))\n  \n  \n def test_patch_wont_create_by_default(self):\n  try:\n   @patch('%s.frooble' % builtin_string, sentinel.Frooble)\n   def test():\n    self.assertEqual(frooble, sentinel.Frooble)\n    \n   test()\n  except AttributeError:\n   pass\n  else:\n   self.fail('Patching non existent attributes should fail')\n   \n  self.assertRaises(NameError, lambda: frooble)\n  \n  \n def test_patchobject_wont_create_by_default(self):\n  try:\n   @patch.object(SomeClass, 'frooble', sentinel.Frooble)\n   def test():\n    self.fail('Patching non existent attributes should fail')\n    \n   test()\n  except AttributeError:\n   pass\n  else:\n   self.fail('Patching non existent attributes should fail')\n  self.assertFalse(hasattr(SomeClass, 'frooble'))\n  \n  \n def test_patch_with_static_methods(self):\n  class Foo(object):\n   @staticmethod\n   def woot():\n    return sentinel.Static\n    \n  @patch.object(Foo, 'woot', staticmethod(lambda: sentinel.Patched))\n  def anonymous():\n   self.assertEqual(Foo.woot(), sentinel.Patched)\n  anonymous()\n  \n  self.assertEqual(Foo.woot(), sentinel.Static)\n  \n  \n def test_patch_local(self):\n  foo = sentinel.Foo\n  @patch.object(sentinel, 'Foo', 'Foo')\n  def anonymous():\n   self.assertEqual(sentinel.Foo, 'Foo')\n  anonymous()\n  \n  self.assertEqual(sentinel.Foo, foo)\n  \n  \n def test_patch_slots(self):\n  class Foo(object):\n   __slots__ = ('Foo',)\n   \n  foo = Foo()\n  foo.Foo = sentinel.Foo\n  \n  @patch.object(foo, 'Foo', 'Foo')\n  def anonymous():\n   self.assertEqual(foo.Foo, 'Foo')\n  anonymous()\n  \n  self.assertEqual(foo.Foo, sentinel.Foo)\n  \n  \n def test_patchobject_class_decorator(self):\n  class Something(object):\n   attribute = sentinel.Original\n   \n  class Foo(object):\n   def test_method(other_self):\n    self.assertEqual(Something.attribute, sentinel.Patched,\n    \"unpatched\")\n   def not_test_method(other_self):\n    self.assertEqual(Something.attribute, sentinel.Original,\n    \"non-test method patched\")\n    \n  Foo = patch.object(Something, 'attribute', sentinel.Patched)(Foo)\n  \n  f = Foo()\n  f.test_method()\n  f.not_test_method()\n  \n  self.assertEqual(Something.attribute, sentinel.Original,\n  \"patch not restored\")\n  \n  \n def test_patch_class_decorator(self):\n  class Something(object):\n   attribute = sentinel.Original\n   \n  class Foo(object):\n   def test_method(other_self, mock_something):\n    self.assertEqual(PTModule.something, mock_something,\n    \"unpatched\")\n   def not_test_method(other_self):\n    self.assertEqual(PTModule.something, sentinel.Something,\n    \"non-test method patched\")\n  Foo = patch('%s.something' % __name__)(Foo)\n  \n  f = Foo()\n  f.test_method()\n  f.not_test_method()\n  \n  self.assertEqual(Something.attribute, sentinel.Original,\n  \"patch not restored\")\n  self.assertEqual(PTModule.something, sentinel.Something,\n  \"patch not restored\")\n  \n  \n def test_patchobject_twice(self):\n  class Something(object):\n   attribute = sentinel.Original\n   next_attribute = sentinel.Original2\n   \n  @patch.object(Something, 'attribute', sentinel.Patched)\n  @patch.object(Something, 'attribute', sentinel.Patched)\n  def test():\n   self.assertEqual(Something.attribute, sentinel.Patched, \"unpatched\")\n   \n  test()\n  \n  self.assertEqual(Something.attribute, sentinel.Original,\n  \"patch not restored\")\n  \n  \n def test_patch_dict(self):\n  foo = {'initial': object(), 'other': 'something'}\n  original = foo.copy()\n  \n  @patch.dict(foo)\n  def test():\n   foo['a'] = 3\n   del foo['initial']\n   foo['other'] = 'something else'\n   \n  test()\n  \n  self.assertEqual(foo, original)\n  \n  @patch.dict(foo, {'a': 'b'})\n  def test():\n   self.assertEqual(len(foo), 3)\n   self.assertEqual(foo['a'], 'b')\n   \n  test()\n  \n  self.assertEqual(foo, original)\n  \n  @patch.dict(foo, [('a', 'b')])\n  def test():\n   self.assertEqual(len(foo), 3)\n   self.assertEqual(foo['a'], 'b')\n   \n  test()\n  \n  self.assertEqual(foo, original)\n  \n  \n def test_patch_dict_with_container_object(self):\n  foo = Container()\n  foo['initial'] = object()\n  foo['other'] = 'something'\n  \n  original = foo.values.copy()\n  \n  @patch.dict(foo)\n  def test():\n   foo['a'] = 3\n   del foo['initial']\n   foo['other'] = 'something else'\n   \n  test()\n  \n  self.assertEqual(foo.values, original)\n  \n  @patch.dict(foo, {'a': 'b'})\n  def test():\n   self.assertEqual(len(foo.values), 3)\n   self.assertEqual(foo['a'], 'b')\n   \n  test()\n  \n  self.assertEqual(foo.values, original)\n  \n  \n def test_patch_dict_with_clear(self):\n  foo = {'initial': object(), 'other': 'something'}\n  original = foo.copy()\n  \n  @patch.dict(foo, clear=True)\n  def test():\n   self.assertEqual(foo, {})\n   foo['a'] = 3\n   foo['other'] = 'something else'\n   \n  test()\n  \n  self.assertEqual(foo, original)\n  \n  @patch.dict(foo, {'a': 'b'}, clear=True)\n  def test():\n   self.assertEqual(foo, {'a': 'b'})\n   \n  test()\n  \n  self.assertEqual(foo, original)\n  \n  @patch.dict(foo, [('a', 'b')], clear=True)\n  def test():\n   self.assertEqual(foo, {'a': 'b'})\n   \n  test()\n  \n  self.assertEqual(foo, original)\n  \n  \n def test_patch_dict_with_container_object_and_clear(self):\n  foo = Container()\n  foo['initial'] = object()\n  foo['other'] = 'something'\n  \n  original = foo.values.copy()\n  \n  @patch.dict(foo, clear=True)\n  def test():\n   self.assertEqual(foo.values, {})\n   foo['a'] = 3\n   foo['other'] = 'something else'\n   \n  test()\n  \n  self.assertEqual(foo.values, original)\n  \n  @patch.dict(foo, {'a': 'b'}, clear=True)\n  def test():\n   self.assertEqual(foo.values, {'a': 'b'})\n   \n  test()\n  \n  self.assertEqual(foo.values, original)\n  \n  \n def test_name_preserved(self):\n  foo = {}\n  \n  @patch('%s.SomeClass' % __name__, object())\n  @patch('%s.SomeClass' % __name__, object(), autospec=True)\n  @patch.object(SomeClass, object())\n  @patch.dict(foo)\n  def some_name():\n   pass\n   \n  self.assertEqual(some_name.__name__, 'some_name')\n  \n  \n def test_patch_with_exception(self):\n  foo = {}\n  \n  @patch.dict(foo, {'a': 'b'})\n  def test():\n   raise NameError('Konrad')\n  try:\n   test()\n  except NameError:\n   pass\n  else:\n   self.fail('NameError not raised by test')\n   \n  self.assertEqual(foo, {})\n  \n  \n def test_patch_dict_with_string(self):\n  @patch.dict('os.environ', {'konrad_delong': 'some value'})\n  def test():\n   self.assertIn('konrad_delong', os.environ)\n   \n  test()\n  \n  \n def test_patch_descriptor(self):\n \n \n  return\n  class Nothing(object):\n   foo = None\n   \n  class Something(object):\n   foo = {}\n   \n   @patch.object(Nothing, 'foo', 2)\n   @classmethod\n   def klass(cls):\n    self.assertIs(cls, Something)\n    \n   @patch.object(Nothing, 'foo', 2)\n   @staticmethod\n   def static(arg):\n    return arg\n    \n   @patch.dict(foo)\n   @classmethod\n   def klass_dict(cls):\n    self.assertIs(cls, Something)\n    \n   @patch.dict(foo)\n   @staticmethod\n   def static_dict(arg):\n    return arg\n    \n    \n  self.assertEqual(Something.static('f00'), 'f00')\n  Something.klass()\n  self.assertEqual(Something.static_dict('f00'), 'f00')\n  Something.klass_dict()\n  \n  something = Something()\n  self.assertEqual(something.static('f00'), 'f00')\n  something.klass()\n  self.assertEqual(something.static_dict('f00'), 'f00')\n  something.klass_dict()\n  \n  \n def test_patch_spec_set(self):\n  @patch('%s.SomeClass' % __name__, spec=SomeClass, spec_set=True)\n  def test(MockClass):\n   MockClass.z = 'foo'\n   \n  self.assertRaises(AttributeError, test)\n  \n  @patch.object(support, 'SomeClass', spec=SomeClass, spec_set=True)\n  def test(MockClass):\n   MockClass.z = 'foo'\n   \n  self.assertRaises(AttributeError, test)\n  @patch('%s.SomeClass' % __name__, spec_set=True)\n  def test(MockClass):\n   MockClass.z = 'foo'\n   \n  self.assertRaises(AttributeError, test)\n  \n  @patch.object(support, 'SomeClass', spec_set=True)\n  def test(MockClass):\n   MockClass.z = 'foo'\n   \n  self.assertRaises(AttributeError, test)\n  \n  \n def test_spec_set_inherit(self):\n  @patch('%s.SomeClass' % __name__, spec_set=True)\n  def test(MockClass):\n   instance = MockClass()\n   instance.z = 'foo'\n   \n  self.assertRaises(AttributeError, test)\n  \n  \n def test_patch_start_stop(self):\n  original = something\n  patcher = patch('%s.something' % __name__)\n  self.assertIs(something, original)\n  mock = patcher.start()\n  try:\n   self.assertIsNot(mock, original)\n   self.assertIs(something, mock)\n  finally:\n   patcher.stop()\n  self.assertIs(something, original)\n  \n  \n def test_stop_without_start(self):\n  patcher = patch(foo_name, 'bar', 3)\n  \n  \n  self.assertRaises(RuntimeError, patcher.stop)\n  \n  \n def test_patchobject_start_stop(self):\n  original = something\n  patcher = patch.object(PTModule, 'something', 'foo')\n  self.assertIs(something, original)\n  replaced = patcher.start()\n  try:\n   self.assertEqual(replaced, 'foo')\n   self.assertIs(something, replaced)\n  finally:\n   patcher.stop()\n  self.assertIs(something, original)\n  \n  \n def test_patch_dict_start_stop(self):\n  d = {'foo': 'bar'}\n  original = d.copy()\n  patcher = patch.dict(d, [('spam', 'eggs')], clear=True)\n  self.assertEqual(d, original)\n  \n  patcher.start()\n  try:\n   self.assertEqual(d, {'spam': 'eggs'})\n  finally:\n   patcher.stop()\n  self.assertEqual(d, original)\n  \n  \n def test_patch_dict_class_decorator(self):\n  this = self\n  d = {'spam': 'eggs'}\n  original = d.copy()\n  \n  class Test(object):\n   def test_first(self):\n    this.assertEqual(d, {'foo': 'bar'})\n   def test_second(self):\n    this.assertEqual(d, {'foo': 'bar'})\n    \n  Test = patch.dict(d, {'foo': 'bar'}, clear=True)(Test)\n  self.assertEqual(d, original)\n  \n  test = Test()\n  \n  test.test_first()\n  self.assertEqual(d, original)\n  \n  test.test_second()\n  self.assertEqual(d, original)\n  \n  test = Test()\n  \n  test.test_first()\n  self.assertEqual(d, original)\n  \n  test.test_second()\n  self.assertEqual(d, original)\n  \n  \n def test_get_only_proxy(self):\n  class Something(object):\n   foo = 'foo'\n  class SomethingElse:\n   foo = 'foo'\n   \n  for thing in Something, SomethingElse, Something(), SomethingElse:\n   proxy = _get_proxy(thing)\n   \n   @patch.object(proxy, 'foo', 'bar')\n   def test():\n    self.assertEqual(proxy.foo, 'bar')\n   test()\n   self.assertEqual(proxy.foo, 'foo')\n   self.assertEqual(thing.foo, 'foo')\n   self.assertNotIn('foo', proxy.__dict__)\n   \n   \n def test_get_set_delete_proxy(self):\n  class Something(object):\n   foo = 'foo'\n  class SomethingElse:\n   foo = 'foo'\n   \n  for thing in Something, SomethingElse, Something(), SomethingElse:\n   proxy = _get_proxy(Something, get_only=False)\n   \n   @patch.object(proxy, 'foo', 'bar')\n   def test():\n    self.assertEqual(proxy.foo, 'bar')\n   test()\n   self.assertEqual(proxy.foo, 'foo')\n   self.assertEqual(thing.foo, 'foo')\n   self.assertNotIn('foo', proxy.__dict__)\n   \n   \n def test_patch_keyword_args(self):\n  kwargs = {'side_effect': KeyError, 'foo.bar.return_value': 33,\n  'foo': MagicMock()}\n  \n  patcher = patch(foo_name, **kwargs)\n  mock = patcher.start()\n  patcher.stop()\n  \n  self.assertRaises(KeyError, mock)\n  self.assertEqual(mock.foo.bar(), 33)\n  self.assertIsInstance(mock.foo, MagicMock)\n  \n  \n def test_patch_object_keyword_args(self):\n  kwargs = {'side_effect': KeyError, 'foo.bar.return_value': 33,\n  'foo': MagicMock()}\n  \n  patcher = patch.object(Foo, 'f', **kwargs)\n  mock = patcher.start()\n  patcher.stop()\n  \n  self.assertRaises(KeyError, mock)\n  self.assertEqual(mock.foo.bar(), 33)\n  self.assertIsInstance(mock.foo, MagicMock)\n  \n  \n def test_patch_dict_keyword_args(self):\n  original = {'foo': 'bar'}\n  copy = original.copy()\n  \n  patcher = patch.dict(original, foo=3, bar=4, baz=5)\n  patcher.start()\n  \n  try:\n   self.assertEqual(original, dict(foo=3, bar=4, baz=5))\n  finally:\n   patcher.stop()\n   \n  self.assertEqual(original, copy)\n  \n  \n def test_autospec(self):\n  class Boo(object):\n   def __init__(self, a):\n    pass\n   def f(self, a):\n    pass\n   def g(self):\n    pass\n   foo = 'bar'\n   \n   class Bar(object):\n    def a(self):\n     pass\n     \n  def _test(mock):\n   mock(1)\n   mock.assert_called_with(1)\n   self.assertRaises(TypeError, mock)\n   \n  def _test2(mock):\n   mock.f(1)\n   mock.f.assert_called_with(1)\n   self.assertRaises(TypeError, mock.f)\n   \n   mock.g()\n   mock.g.assert_called_with()\n   self.assertRaises(TypeError, mock.g, 1)\n   \n   self.assertRaises(AttributeError, getattr, mock, 'h')\n   \n   mock.foo.lower()\n   mock.foo.lower.assert_called_with()\n   self.assertRaises(AttributeError, getattr, mock.foo, 'bar')\n   \n   mock.Bar()\n   mock.Bar.assert_called_with()\n   \n   mock.Bar.a()\n   mock.Bar.a.assert_called_with()\n   self.assertRaises(TypeError, mock.Bar.a, 1)\n   \n   mock.Bar().a()\n   mock.Bar().a.assert_called_with()\n   self.assertRaises(TypeError, mock.Bar().a, 1)\n   \n   self.assertRaises(AttributeError, getattr, mock.Bar, 'b')\n   self.assertRaises(AttributeError, getattr, mock.Bar(), 'b')\n   \n  def function(mock):\n   _test(mock)\n   _test2(mock)\n   _test2(mock(1))\n   self.assertIs(mock, Foo)\n   return mock\n   \n  test = patch(foo_name, autospec=True)(function)\n  \n  mock = test()\n  self.assertIsNot(Foo, mock)\n  \n  test()\n  \n  module = sys.modules[__name__]\n  test = patch.object(module, 'Foo', autospec=True)(function)\n  \n  mock = test()\n  self.assertIsNot(Foo, mock)\n  \n  test()\n  \n  \n def test_autospec_function(self):\n  @patch('%s.function' % __name__, autospec=True)\n  def test(mock):\n   function(1)\n   function.assert_called_with(1)\n   function(2, 3)\n   function.assert_called_with(2, 3)\n   \n   self.assertRaises(TypeError, function)\n   self.assertRaises(AttributeError, getattr, function, 'foo')\n   \n  test()\n  \n  \n def test_autospec_keywords(self):\n  @patch('%s.function' % __name__, autospec=True,\n  return_value=3)\n  def test(mock_function):\n  \n   return function(1, 2)\n   \n  result = test()\n  self.assertEqual(result, 3)\n  \n  \n def test_autospec_with_new(self):\n  patcher = patch('%s.function' % __name__, new=3, autospec=True)\n  self.assertRaises(TypeError, patcher.start)\n  \n  module = sys.modules[__name__]\n  patcher = patch.object(module, 'function', new=3, autospec=True)\n  self.assertRaises(TypeError, patcher.start)\n  \n  \n def test_autospec_with_object(self):\n  class Bar(Foo):\n   extra = []\n   \n  patcher = patch(foo_name, autospec=Bar)\n  mock = patcher.start()\n  try:\n   self.assertIsInstance(mock, Bar)\n   self.assertIsInstance(mock.extra, list)\n  finally:\n   patcher.stop()\n   \n   \n def test_autospec_inherits(self):\n  FooClass = Foo\n  patcher = patch(foo_name, autospec=True)\n  mock = patcher.start()\n  try:\n   self.assertIsInstance(mock, FooClass)\n   self.assertIsInstance(mock(3), FooClass)\n  finally:\n   patcher.stop()\n   \n   \n def test_autospec_name(self):\n  patcher = patch(foo_name, autospec=True)\n  mock = patcher.start()\n  \n  try:\n   self.assertIn(\" name='Foo'\", repr(mock))\n   self.assertIn(\" name='Foo.f'\", repr(mock.f))\n   self.assertIn(\" name='Foo()'\", repr(mock(None)))\n   self.assertIn(\" name='Foo().f'\", repr(mock(None).f))\n  finally:\n   patcher.stop()\n   \n   \n def test_tracebacks(self):\n  @patch.object(Foo, 'f', object())\n  def test():\n   raise AssertionError\n  try:\n   test()\n  except:\n   err = sys.exc_info()\n   \n  result = unittest.TextTestResult(None, None, 0)\n  traceback = result._exc_info_to_string(err, self)\n  self.assertIn('raise AssertionError', traceback)\n  \n  \n def test_new_callable_patch(self):\n  patcher = patch(foo_name, new_callable=NonCallableMagicMock)\n  \n  m1 = patcher.start()\n  patcher.stop()\n  m2 = patcher.start()\n  patcher.stop()\n  \n  self.assertIsNot(m1, m2)\n  for mock in m1, m2:\n   self.assertNotCallable(m1)\n   \n   \n def test_new_callable_patch_object(self):\n  patcher = patch.object(Foo, 'f', new_callable=NonCallableMagicMock)\n  \n  m1 = patcher.start()\n  patcher.stop()\n  m2 = patcher.start()\n  patcher.stop()\n  \n  self.assertIsNot(m1, m2)\n  for mock in m1, m2:\n   self.assertNotCallable(m1)\n   \n   \n def test_new_callable_keyword_arguments(self):\n  class Bar(object):\n   kwargs = None\n   def __init__(self, **kwargs):\n    Bar.kwargs = kwargs\n    \n  patcher = patch(foo_name, new_callable=Bar, arg1=1, arg2=2)\n  m = patcher.start()\n  try:\n   self.assertIs(type(m), Bar)\n   self.assertEqual(Bar.kwargs, dict(arg1=1, arg2=2))\n  finally:\n   patcher.stop()\n   \n   \n def test_new_callable_spec(self):\n  class Bar(object):\n   kwargs = None\n   def __init__(self, **kwargs):\n    Bar.kwargs = kwargs\n    \n  patcher = patch(foo_name, new_callable=Bar, spec=Bar)\n  patcher.start()\n  try:\n   self.assertEqual(Bar.kwargs, dict(spec=Bar))\n  finally:\n   patcher.stop()\n   \n  patcher = patch(foo_name, new_callable=Bar, spec_set=Bar)\n  patcher.start()\n  try:\n   self.assertEqual(Bar.kwargs, dict(spec_set=Bar))\n  finally:\n   patcher.stop()\n   \n   \n def test_new_callable_create(self):\n  non_existent_attr = '%s.weeeee' % foo_name\n  p = patch(non_existent_attr, new_callable=NonCallableMock)\n  self.assertRaises(AttributeError, p.start)\n  \n  p = patch(non_existent_attr, new_callable=NonCallableMock,\n  create=True)\n  m = p.start()\n  try:\n   self.assertNotCallable(m, magic=False)\n  finally:\n   p.stop()\n   \n   \n def test_new_callable_incompatible_with_new(self):\n  self.assertRaises(\n  ValueError, patch, foo_name, new=object(), new_callable=MagicMock\n  )\n  self.assertRaises(\n  ValueError, patch.object, Foo, 'f', new=object(),\n  new_callable=MagicMock\n  )\n  \n  \n def test_new_callable_incompatible_with_autospec(self):\n  self.assertRaises(\n  ValueError, patch, foo_name, new_callable=MagicMock,\n  autospec=True\n  )\n  self.assertRaises(\n  ValueError, patch.object, Foo, 'f', new_callable=MagicMock,\n  autospec=True\n  )\n  \n  \n def test_new_callable_inherit_for_mocks(self):\n  class MockSub(Mock):\n   pass\n   \n  MockClasses = (\n  NonCallableMock, NonCallableMagicMock, MagicMock, Mock, MockSub\n  )\n  for Klass in MockClasses:\n   for arg in 'spec', 'spec_set':\n    kwargs = {arg: True}\n    p = patch(foo_name, new_callable=Klass, **kwargs)\n    m = p.start()\n    try:\n     instance = m.return_value\n     self.assertRaises(AttributeError, getattr, instance, 'x')\n    finally:\n     p.stop()\n     \n     \n def test_new_callable_inherit_non_mock(self):\n  class NotAMock(object):\n   def __init__(self, spec):\n    self.spec = spec\n    \n  p = patch(foo_name, new_callable=NotAMock, spec=True)\n  m = p.start()\n  try:\n   self.assertTrue(is_instance(m, NotAMock))\n   self.assertRaises(AttributeError, getattr, m, 'return_value')\n  finally:\n   p.stop()\n   \n  self.assertEqual(m.spec, Foo)\n  \n  \n def test_new_callable_class_decorating(self):\n  test = self\n  original = Foo\n  class SomeTest(object):\n  \n   def _test(self, mock_foo):\n    test.assertIsNot(Foo, original)\n    test.assertIs(Foo, mock_foo)\n    test.assertIsInstance(Foo, SomeClass)\n    \n   def test_two(self, mock_foo):\n    self._test(mock_foo)\n   def test_one(self, mock_foo):\n    self._test(mock_foo)\n    \n  SomeTest = patch(foo_name, new_callable=SomeClass)(SomeTest)\n  SomeTest().test_one()\n  SomeTest().test_two()\n  self.assertIs(Foo, original)\n  \n  \n def test_patch_multiple(self):\n  original_foo = Foo\n  original_f = Foo.f\n  original_g = Foo.g\n  \n  patcher1 = patch.multiple(foo_name, f=1, g=2)\n  patcher2 = patch.multiple(Foo, f=1, g=2)\n  \n  for patcher in patcher1, patcher2:\n   patcher.start()\n   try:\n    self.assertIs(Foo, original_foo)\n    self.assertEqual(Foo.f, 1)\n    self.assertEqual(Foo.g, 2)\n   finally:\n    patcher.stop()\n    \n   self.assertIs(Foo, original_foo)\n   self.assertEqual(Foo.f, original_f)\n   self.assertEqual(Foo.g, original_g)\n   \n   \n  @patch.multiple(foo_name, f=3, g=4)\n  def test():\n   self.assertIs(Foo, original_foo)\n   self.assertEqual(Foo.f, 3)\n   self.assertEqual(Foo.g, 4)\n   \n  test()\n  \n  \n def test_patch_multiple_no_kwargs(self):\n  self.assertRaises(ValueError, patch.multiple, foo_name)\n  self.assertRaises(ValueError, patch.multiple, Foo)\n  \n  \n def test_patch_multiple_create_mocks(self):\n  original_foo = Foo\n  original_f = Foo.f\n  original_g = Foo.g\n  \n  @patch.multiple(foo_name, f=DEFAULT, g=3, foo=DEFAULT)\n  def test(f, foo):\n   self.assertIs(Foo, original_foo)\n   self.assertIs(Foo.f, f)\n   self.assertEqual(Foo.g, 3)\n   self.assertIs(Foo.foo, foo)\n   self.assertTrue(is_instance(f, MagicMock))\n   self.assertTrue(is_instance(foo, MagicMock))\n   \n  test()\n  self.assertEqual(Foo.f, original_f)\n  self.assertEqual(Foo.g, original_g)\n  \n  \n def test_patch_multiple_create_mocks_different_order(self):\n \n  original_f = Foo.f\n  original_g = Foo.g\n  \n  patcher = patch.object(Foo, 'f', 3)\n  patcher.attribute_name = 'f'\n  \n  other = patch.object(Foo, 'g', DEFAULT)\n  other.attribute_name = 'g'\n  patcher.additional_patchers = [other]\n  \n  @patcher\n  def test(g):\n   self.assertIs(Foo.g, g)\n   self.assertEqual(Foo.f, 3)\n   \n  test()\n  self.assertEqual(Foo.f, original_f)\n  self.assertEqual(Foo.g, original_g)\n  \n  \n def test_patch_multiple_stacked_decorators(self):\n  original_foo = Foo\n  original_f = Foo.f\n  original_g = Foo.g\n  \n  @patch.multiple(foo_name, f=DEFAULT)\n  @patch.multiple(foo_name, foo=DEFAULT)\n  @patch(foo_name + '.g')\n  def test1(g, **kwargs):\n   _test(g, **kwargs)\n   \n  @patch.multiple(foo_name, f=DEFAULT)\n  @patch(foo_name + '.g')\n  @patch.multiple(foo_name, foo=DEFAULT)\n  def test2(g, **kwargs):\n   _test(g, **kwargs)\n   \n  @patch(foo_name + '.g')\n  @patch.multiple(foo_name, f=DEFAULT)\n  @patch.multiple(foo_name, foo=DEFAULT)\n  def test3(g, **kwargs):\n   _test(g, **kwargs)\n   \n  def _test(g, **kwargs):\n   f = kwargs.pop('f')\n   foo = kwargs.pop('foo')\n   self.assertFalse(kwargs)\n   \n   self.assertIs(Foo, original_foo)\n   self.assertIs(Foo.f, f)\n   self.assertIs(Foo.g, g)\n   self.assertIs(Foo.foo, foo)\n   self.assertTrue(is_instance(f, MagicMock))\n   self.assertTrue(is_instance(g, MagicMock))\n   self.assertTrue(is_instance(foo, MagicMock))\n   \n  test1()\n  test2()\n  test3()\n  self.assertEqual(Foo.f, original_f)\n  self.assertEqual(Foo.g, original_g)\n  \n  \n def test_patch_multiple_create_mocks_patcher(self):\n  original_foo = Foo\n  original_f = Foo.f\n  original_g = Foo.g\n  \n  patcher = patch.multiple(foo_name, f=DEFAULT, g=3, foo=DEFAULT)\n  \n  result = patcher.start()\n  try:\n   f = result['f']\n   foo = result['foo']\n   self.assertEqual(set(result), set(['f', 'foo']))\n   \n   self.assertIs(Foo, original_foo)\n   self.assertIs(Foo.f, f)\n   self.assertIs(Foo.foo, foo)\n   self.assertTrue(is_instance(f, MagicMock))\n   self.assertTrue(is_instance(foo, MagicMock))\n  finally:\n   patcher.stop()\n   \n  self.assertEqual(Foo.f, original_f)\n  self.assertEqual(Foo.g, original_g)\n  \n  \n def test_patch_multiple_decorating_class(self):\n  test = self\n  original_foo = Foo\n  original_f = Foo.f\n  original_g = Foo.g\n  \n  class SomeTest(object):\n  \n   def _test(self, f, foo):\n    test.assertIs(Foo, original_foo)\n    test.assertIs(Foo.f, f)\n    test.assertEqual(Foo.g, 3)\n    test.assertIs(Foo.foo, foo)\n    test.assertTrue(is_instance(f, MagicMock))\n    test.assertTrue(is_instance(foo, MagicMock))\n    \n   def test_two(self, f, foo):\n    self._test(f, foo)\n   def test_one(self, f, foo):\n    self._test(f, foo)\n    \n  SomeTest = patch.multiple(\n  foo_name, f=DEFAULT, g=3, foo=DEFAULT\n  )(SomeTest)\n  \n  thing = SomeTest()\n  thing.test_one()\n  thing.test_two()\n  \n  self.assertEqual(Foo.f, original_f)\n  self.assertEqual(Foo.g, original_g)\n  \n  \n def test_patch_multiple_create(self):\n  patcher = patch.multiple(Foo, blam='blam')\n  self.assertRaises(AttributeError, patcher.start)\n  \n  patcher = patch.multiple(Foo, blam='blam', create=True)\n  patcher.start()\n  try:\n   self.assertEqual(Foo.blam, 'blam')\n  finally:\n   patcher.stop()\n   \n  self.assertFalse(hasattr(Foo, 'blam'))\n  \n  \n def test_patch_multiple_spec_set(self):\n \n \n  patcher = patch.multiple(Foo, foo=DEFAULT, spec_set=['a', 'b'])\n  result = patcher.start()\n  try:\n   self.assertEqual(Foo.foo, result['foo'])\n   Foo.foo.a(1)\n   Foo.foo.b(2)\n   Foo.foo.a.assert_called_with(1)\n   Foo.foo.b.assert_called_with(2)\n   self.assertRaises(AttributeError, setattr, Foo.foo, 'c', None)\n  finally:\n   patcher.stop()\n   \n   \n def test_patch_multiple_new_callable(self):\n  class Thing(object):\n   pass\n   \n  patcher = patch.multiple(\n  Foo, f=DEFAULT, g=DEFAULT, new_callable=Thing\n  )\n  result = patcher.start()\n  try:\n   self.assertIs(Foo.f, result['f'])\n   self.assertIs(Foo.g, result['g'])\n   self.assertIsInstance(Foo.f, Thing)\n   self.assertIsInstance(Foo.g, Thing)\n   self.assertIsNot(Foo.f, Foo.g)\n  finally:\n   patcher.stop()\n   \n   \n def test_nested_patch_failure(self):\n  original_f = Foo.f\n  original_g = Foo.g\n  \n  @patch.object(Foo, 'g', 1)\n  @patch.object(Foo, 'missing', 1)\n  @patch.object(Foo, 'f', 1)\n  def thing1():\n   pass\n   \n  @patch.object(Foo, 'missing', 1)\n  @patch.object(Foo, 'g', 1)\n  @patch.object(Foo, 'f', 1)\n  def thing2():\n   pass\n   \n  @patch.object(Foo, 'g', 1)\n  @patch.object(Foo, 'f', 1)\n  @patch.object(Foo, 'missing', 1)\n  def thing3():\n   pass\n   \n  for func in thing1, thing2, thing3:\n   self.assertRaises(AttributeError, func)\n   self.assertEqual(Foo.f, original_f)\n   self.assertEqual(Foo.g, original_g)\n   \n   \n def test_new_callable_failure(self):\n  original_f = Foo.f\n  original_g = Foo.g\n  original_foo = Foo.foo\n  \n  def crasher():\n   raise NameError('crasher')\n   \n  @patch.object(Foo, 'g', 1)\n  @patch.object(Foo, 'foo', new_callable=crasher)\n  @patch.object(Foo, 'f', 1)\n  def thing1():\n   pass\n   \n  @patch.object(Foo, 'foo', new_callable=crasher)\n  @patch.object(Foo, 'g', 1)\n  @patch.object(Foo, 'f', 1)\n  def thing2():\n   pass\n   \n  @patch.object(Foo, 'g', 1)\n  @patch.object(Foo, 'f', 1)\n  @patch.object(Foo, 'foo', new_callable=crasher)\n  def thing3():\n   pass\n   \n  for func in thing1, thing2, thing3:\n   self.assertRaises(NameError, func)\n   self.assertEqual(Foo.f, original_f)\n   self.assertEqual(Foo.g, original_g)\n   self.assertEqual(Foo.foo, original_foo)\n   \n   \n def test_patch_multiple_failure(self):\n  original_f = Foo.f\n  original_g = Foo.g\n  \n  patcher = patch.object(Foo, 'f', 1)\n  patcher.attribute_name = 'f'\n  \n  good = patch.object(Foo, 'g', 1)\n  good.attribute_name = 'g'\n  \n  bad = patch.object(Foo, 'missing', 1)\n  bad.attribute_name = 'missing'\n  \n  for additionals in [good, bad], [bad, good]:\n   patcher.additional_patchers = additionals\n   \n   @patcher\n   def func():\n    pass\n    \n   self.assertRaises(AttributeError, func)\n   self.assertEqual(Foo.f, original_f)\n   self.assertEqual(Foo.g, original_g)\n   \n   \n def test_patch_multiple_new_callable_failure(self):\n  original_f = Foo.f\n  original_g = Foo.g\n  original_foo = Foo.foo\n  \n  def crasher():\n   raise NameError('crasher')\n   \n  patcher = patch.object(Foo, 'f', 1)\n  patcher.attribute_name = 'f'\n  \n  good = patch.object(Foo, 'g', 1)\n  good.attribute_name = 'g'\n  \n  bad = patch.object(Foo, 'foo', new_callable=crasher)\n  bad.attribute_name = 'foo'\n  \n  for additionals in [good, bad], [bad, good]:\n   patcher.additional_patchers = additionals\n   \n   @patcher\n   def func():\n    pass\n    \n   self.assertRaises(NameError, func)\n   self.assertEqual(Foo.f, original_f)\n   self.assertEqual(Foo.g, original_g)\n   self.assertEqual(Foo.foo, original_foo)\n   \n   \n def test_patch_multiple_string_subclasses(self):\n  Foo = type('Foo', (str,), {'fish': 'tasty'})\n  foo = Foo()\n  @patch.multiple(foo, fish='nearly gone')\n  def test():\n   self.assertEqual(foo.fish, 'nearly gone')\n   \n  test()\n  self.assertEqual(foo.fish, 'tasty')\n  \n  \n @patch('unittest.mock.patch.TEST_PREFIX', 'foo')\n def test_patch_test_prefix(self):\n  class Foo(object):\n   thing = 'original'\n   \n   def foo_one(self):\n    return self.thing\n   def foo_two(self):\n    return self.thing\n   def test_one(self):\n    return self.thing\n   def test_two(self):\n    return self.thing\n    \n  Foo = patch.object(Foo, 'thing', 'changed')(Foo)\n  \n  foo = Foo()\n  self.assertEqual(foo.foo_one(), 'changed')\n  self.assertEqual(foo.foo_two(), 'changed')\n  self.assertEqual(foo.test_one(), 'original')\n  self.assertEqual(foo.test_two(), 'original')\n  \n  \n @patch('unittest.mock.patch.TEST_PREFIX', 'bar')\n def test_patch_dict_test_prefix(self):\n  class Foo(object):\n   def bar_one(self):\n    return dict(the_dict)\n   def bar_two(self):\n    return dict(the_dict)\n   def test_one(self):\n    return dict(the_dict)\n   def test_two(self):\n    return dict(the_dict)\n    \n  the_dict = {'key': 'original'}\n  Foo = patch.dict(the_dict, key='changed')(Foo)\n  \n  foo =Foo()\n  self.assertEqual(foo.bar_one(), {'key': 'changed'})\n  self.assertEqual(foo.bar_two(), {'key': 'changed'})\n  self.assertEqual(foo.test_one(), {'key': 'original'})\n  self.assertEqual(foo.test_two(), {'key': 'original'})\n  \n  \n def test_patch_with_spec_mock_repr(self):\n  for arg in ('spec', 'autospec', 'spec_set'):\n   p = patch('%s.SomeClass' % __name__, **{arg: True})\n   m = p.start()\n   try:\n    self.assertIn(\" name='SomeClass'\", repr(m))\n    self.assertIn(\" name='SomeClass.class_attribute'\",\n    repr(m.class_attribute))\n    self.assertIn(\" name='SomeClass()'\", repr(m()))\n    self.assertIn(\" name='SomeClass().class_attribute'\",\n    repr(m().class_attribute))\n   finally:\n    p.stop()\n    \n    \n def test_patch_nested_autospec_repr(self):\n  with patch('unittest.test.testmock.support', autospec=True) as m:\n   self.assertIn(\" name='support.SomeClass.wibble()'\",\n   repr(m.SomeClass.wibble()))\n   self.assertIn(\" name='support.SomeClass().wibble()'\",\n   repr(m.SomeClass().wibble()))\n   \n   \n   \n def test_mock_calls_with_patch(self):\n  for arg in ('spec', 'autospec', 'spec_set'):\n   p = patch('%s.SomeClass' % __name__, **{arg: True})\n   m = p.start()\n   try:\n    m.wibble()\n    \n    kalls = [call.wibble()]\n    self.assertEqual(m.mock_calls, kalls)\n    self.assertEqual(m.method_calls, kalls)\n    self.assertEqual(m.wibble.mock_calls, [call()])\n    \n    result = m()\n    kalls.append(call())\n    self.assertEqual(m.mock_calls, kalls)\n    \n    result.wibble()\n    kalls.append(call().wibble())\n    self.assertEqual(m.mock_calls, kalls)\n    \n    self.assertEqual(result.mock_calls, [call.wibble()])\n    self.assertEqual(result.wibble.mock_calls, [call()])\n    self.assertEqual(result.method_calls, [call.wibble()])\n   finally:\n    p.stop()\n    \n    \n def test_patch_imports_lazily(self):\n  sys.modules.pop('squizz', None)\n  \n  p1 = patch('squizz.squozz')\n  self.assertRaises(ImportError, p1.start)\n  \n  squizz = Mock()\n  squizz.squozz = 6\n  sys.modules['squizz'] = squizz\n  p1 = patch('squizz.squozz')\n  squizz.squozz = 3\n  p1.start()\n  p1.stop()\n  self.assertEqual(squizz.squozz, 3)\n  \n  \n def test_patch_propogrates_exc_on_exit(self):\n  class holder:\n   exc_info = None, None, None\n   \n  class custom_patch(_patch):\n   def __exit__(self, etype=None, val=None, tb=None):\n    _patch.__exit__(self, etype, val, tb)\n    holder.exc_info = etype, val, tb\n   stop = __exit__\n   \n  def with_custom_patch(target):\n   getter, attribute = _get_target(target)\n   return custom_patch(\n   getter, attribute, DEFAULT, None, False, None,\n   None, None, {}\n   )\n   \n  @with_custom_patch('squizz.squozz')\n  def test(mock):\n   raise RuntimeError\n   \n  self.assertRaises(RuntimeError, test)\n  self.assertIs(holder.exc_info[0], RuntimeError)\n  self.assertIsNotNone(holder.exc_info[1],\n  'exception value not propgated')\n  self.assertIsNotNone(holder.exc_info[2],\n  'exception traceback not propgated')\n  \n  \n def test_create_and_specs(self):\n  for kwarg in ('spec', 'spec_set', 'autospec'):\n   p = patch('%s.doesnotexist' % __name__, create=True,\n   **{kwarg: True})\n   self.assertRaises(TypeError, p.start)\n   self.assertRaises(NameError, lambda: doesnotexist)\n   \n   \n   p = patch(MODNAME, create=True, **{kwarg: True})\n   p.start()\n   p.stop()\n   \n   \n def test_multiple_specs(self):\n  original = PTModule\n  for kwarg in ('spec', 'spec_set'):\n   p = patch(MODNAME, autospec=0, **{kwarg: 0})\n   self.assertRaises(TypeError, p.start)\n   self.assertIs(PTModule, original)\n   \n  for kwarg in ('spec', 'autospec'):\n   p = patch(MODNAME, spec_set=0, **{kwarg: 0})\n   self.assertRaises(TypeError, p.start)\n   self.assertIs(PTModule, original)\n   \n  for kwarg in ('spec_set', 'autospec'):\n   p = patch(MODNAME, spec=0, **{kwarg: 0})\n   self.assertRaises(TypeError, p.start)\n   self.assertIs(PTModule, original)\n   \n   \n def test_specs_false_instead_of_none(self):\n  p = patch(MODNAME, spec=False, spec_set=False, autospec=False)\n  mock = p.start()\n  try:\n  \n   mock.does_not_exist\n   mock.does_not_exist = 3\n  finally:\n   p.stop()\n   \n   \n def test_falsey_spec(self):\n  for kwarg in ('spec', 'autospec', 'spec_set'):\n   p = patch(MODNAME, **{kwarg: 0})\n   m = p.start()\n   try:\n    self.assertRaises(AttributeError, getattr, m, 'doesnotexit')\n   finally:\n    p.stop()\n    \n    \n def test_spec_set_true(self):\n  for kwarg in ('spec', 'autospec'):\n   p = patch(MODNAME, spec_set=True, **{kwarg: True})\n   m = p.start()\n   try:\n    self.assertRaises(AttributeError, setattr, m,\n    'doesnotexist', 'something')\n    self.assertRaises(AttributeError, getattr, m, 'doesnotexist')\n   finally:\n    p.stop()\n    \n    \n def test_callable_spec_as_list(self):\n  spec = ('__call__',)\n  p = patch(MODNAME, spec=spec)\n  m = p.start()\n  try:\n   self.assertTrue(callable(m))\n  finally:\n   p.stop()\n   \n   \n def test_not_callable_spec_as_list(self):\n  spec = ('foo', 'bar')\n  p = patch(MODNAME, spec=spec)\n  m = p.start()\n  try:\n   self.assertFalse(callable(m))\n  finally:\n   p.stop()\n   \n   \n def test_patch_stopall(self):\n  unlink = os.unlink\n  chdir = os.chdir\n  path = os.path\n  patch('os.unlink', something).start()\n  patch('os.chdir', something_else).start()\n  \n  @patch('os.path')\n  def patched(mock_path):\n   patch.stopall()\n   self.assertIs(os.path, mock_path)\n   self.assertIs(os.unlink, unlink)\n   self.assertIs(os.chdir, chdir)\n   \n  patched()\n  self.assertIs(os.path, path)\n  \n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest": ["\"\"\n\n__all__ = ['TestResult', 'TestCase', 'TestSuite',\n'TextTestRunner', 'TestLoader', 'FunctionTestCase', 'main',\n'defaultTestLoader', 'SkipTest', 'skip', 'skipIf', 'skipUnless',\n'expectedFailure', 'TextTestResult', 'installHandler',\n'registerResult', 'removeResult', 'removeHandler']\n\n\n__all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])\n\n__unittest = True\n\nfrom .result import TestResult\nfrom .case import (TestCase, FunctionTestCase, SkipTest, skip, skipIf,\nskipUnless, expectedFailure)\nfrom .suite import BaseTestSuite, TestSuite\nfrom .loader import (TestLoader, defaultTestLoader, makeSuite, getTestCaseNames,\nfindTestCases)\nfrom .main import TestProgram, main\nfrom .runner import TextTestRunner, TextTestResult\nfrom .signals import installHandler, registerResult, removeResult, removeHandler\n\n\n_TextTestResult = TextTestResult\n", 1], "unittest.test.test_program": ["import io\n\nimport os\nimport sys\nimport unittest\n\n\nclass Test_TestProgram(unittest.TestCase):\n\n def test_discovery_from_dotted_path(self):\n  loader = unittest.TestLoader()\n  \n  tests = [self]\n  expectedPath = os.path.abspath(os.path.dirname(unittest.test.__file__))\n  \n  self.wasRun = False\n  def _find_tests(start_dir, pattern):\n   self.wasRun = True\n   self.assertEqual(start_dir, expectedPath)\n   return tests\n  loader._find_tests = _find_tests\n  suite = loader.discover('unittest.test')\n  self.assertTrue(self.wasRun)\n  self.assertEqual(suite._tests, tests)\n  \n  \n def testNoExit(self):\n  result = object()\n  test = object()\n  \n  class FakeRunner(object):\n   def run(self, test):\n    self.test = test\n    return result\n    \n  runner = FakeRunner()\n  \n  oldParseArgs = unittest.TestProgram.parseArgs\n  def restoreParseArgs():\n   unittest.TestProgram.parseArgs = oldParseArgs\n  unittest.TestProgram.parseArgs = lambda *args: None\n  self.addCleanup(restoreParseArgs)\n  \n  def removeTest():\n   del unittest.TestProgram.test\n  unittest.TestProgram.test = test\n  self.addCleanup(removeTest)\n  \n  program = unittest.TestProgram(testRunner=runner, exit=False, verbosity=2)\n  \n  self.assertEqual(program.result, result)\n  self.assertEqual(runner.test, test)\n  self.assertEqual(program.verbosity, 2)\n  \n class FooBar(unittest.TestCase):\n  def testPass(self):\n   assert True\n  def testFail(self):\n   assert False\n   \n class FooBarLoader(unittest.TestLoader):\n  \"\"\n  def loadTestsFromModule(self, module):\n   return self.suiteClass(\n   [self.loadTestsFromTestCase(Test_TestProgram.FooBar)])\n   \n   \n def test_NonExit(self):\n  program = unittest.main(exit=False,\n  argv=[\"foobar\"],\n  testRunner=unittest.TextTestRunner(stream=io.StringIO()),\n  testLoader=self.FooBarLoader())\n  self.assertTrue(hasattr(program, 'result'))\n  \n  \n def test_Exit(self):\n  self.assertRaises(\n  SystemExit,\n  unittest.main,\n  argv=[\"foobar\"],\n  testRunner=unittest.TextTestRunner(stream=io.StringIO()),\n  exit=True,\n  testLoader=self.FooBarLoader())\n  \n  \n def test_ExitAsDefault(self):\n  self.assertRaises(\n  SystemExit,\n  unittest.main,\n  argv=[\"foobar\"],\n  testRunner=unittest.TextTestRunner(stream=io.StringIO()),\n  testLoader=self.FooBarLoader())\n  \n  \nclass InitialisableProgram(unittest.TestProgram):\n exit = False\n result = None\n verbosity = 1\n defaultTest = None\n testRunner = None\n testLoader = unittest.defaultTestLoader\n module = '__main__'\n progName = 'test'\n test = 'test'\n def __init__(self, *args):\n  pass\n  \nRESULT = object()\n\nclass FakeRunner(object):\n initArgs = None\n test = None\n raiseError = False\n \n def __init__(self, **kwargs):\n  FakeRunner.initArgs = kwargs\n  if FakeRunner.raiseError:\n   FakeRunner.raiseError = False\n   raise TypeError\n   \n def run(self, test):\n  FakeRunner.test = test\n  return RESULT\n  \nclass TestCommandLineArgs(unittest.TestCase):\n\n def setUp(self):\n  self.program = InitialisableProgram()\n  self.program.createTests = lambda: None\n  FakeRunner.initArgs = None\n  FakeRunner.test = None\n  FakeRunner.raiseError = False\n  \n def testVerbosity(self):\n  program = self.program\n  \n  for opt in '-q', '--quiet':\n   program.verbosity = 1\n   program.parseArgs([None, opt])\n   self.assertEqual(program.verbosity, 0)\n   \n  for opt in '-v', '--verbose':\n   program.verbosity = 1\n   program.parseArgs([None, opt])\n   self.assertEqual(program.verbosity, 2)\n   \n def testBufferCatchFailfast(self):\n  program = self.program\n  for arg, attr in (('buffer', 'buffer'), ('failfast', 'failfast'),\n  ('catch', 'catchbreak')):\n   if attr == 'catch' and not hasInstallHandler:\n    continue\n    \n   short_opt = '-%s' % arg[0]\n   long_opt = '--%s' % arg\n   for opt in short_opt, long_opt:\n    setattr(program, attr, None)\n    \n    program.parseArgs([None, opt])\n    self.assertTrue(getattr(program, attr))\n    \n   for opt in short_opt, long_opt:\n    not_none = object()\n    setattr(program, attr, not_none)\n    \n    program.parseArgs([None, opt])\n    self.assertEqual(getattr(program, attr), not_none)\n    \n def testWarning(self):\n  \"\"\n  \n  class FakeTP(unittest.TestProgram):\n   def parseArgs(self, *args, **kw): pass\n   def runTests(self, *args, **kw): pass\n  warnoptions = sys.warnoptions[:]\n  try:\n   sys.warnoptions[:] = []\n   \n   self.assertEqual(FakeTP().warnings, 'default')\n   \n   self.assertEqual(FakeTP(warnings='ignore').warnings, 'ignore')\n   sys.warnoptions[:] = ['somevalue']\n   \n   \n   self.assertEqual(FakeTP().warnings, None)\n   self.assertEqual(FakeTP(warnings='ignore').warnings, 'ignore')\n  finally:\n   sys.warnoptions[:] = warnoptions\n   \n def testRunTestsRunnerClass(self):\n  program = self.program\n  \n  program.testRunner = FakeRunner\n  program.verbosity = 'verbosity'\n  program.failfast = 'failfast'\n  program.buffer = 'buffer'\n  program.warnings = 'warnings'\n  \n  program.runTests()\n  \n  self.assertEqual(FakeRunner.initArgs, {'verbosity': 'verbosity',\n  'failfast': 'failfast',\n  'buffer': 'buffer',\n  'warnings': 'warnings'})\n  self.assertEqual(FakeRunner.test, 'test')\n  self.assertIs(program.result, RESULT)\n  \n def testRunTestsRunnerInstance(self):\n  program = self.program\n  \n  program.testRunner = FakeRunner()\n  FakeRunner.initArgs = None\n  \n  program.runTests()\n  \n  \n  self.assertIsNone(FakeRunner.initArgs)\n  \n  self.assertEqual(FakeRunner.test, 'test')\n  self.assertIs(program.result, RESULT)\n  \n def testRunTestsOldRunnerClass(self):\n  program = self.program\n  \n  FakeRunner.raiseError = True\n  program.testRunner = FakeRunner\n  program.verbosity = 'verbosity'\n  program.failfast = 'failfast'\n  program.buffer = 'buffer'\n  program.test = 'test'\n  \n  program.runTests()\n  \n  \n  \n  self.assertEqual(FakeRunner.initArgs, {})\n  self.assertEqual(FakeRunner.test, 'test')\n  self.assertIs(program.result, RESULT)\n  \n def testCatchBreakInstallsHandler(self):\n  module = sys.modules['unittest.main']\n  original = module.installHandler\n  def restore():\n   module.installHandler = original\n  self.addCleanup(restore)\n  \n  self.installed = False\n  def fakeInstallHandler():\n   self.installed = True\n  module.installHandler = fakeInstallHandler\n  \n  program = self.program\n  program.catchbreak = True\n  \n  program.testRunner = FakeRunner\n  \n  program.runTests()\n  self.assertTrue(self.installed)\n  \n def _patch_isfile(self, names, exists=True):\n  def isfile(path):\n   return path in names\n  original = os.path.isfile\n  os.path.isfile = isfile\n  def restore():\n   os.path.isfile = original\n  self.addCleanup(restore)\n  \n  \n def testParseArgsFileNames(self):\n \n  program = self.program\n  argv = ['progname', 'foo.py', 'bar.Py', 'baz.PY', 'wing.txt']\n  self._patch_isfile(argv)\n  \n  program.createTests = lambda: None\n  program.parseArgs(argv)\n  \n  \n  \n  expected = ['foo', 'bar', 'baz', 'wing.txt']\n  self.assertEqual(program.testNames, expected)\n  \n  \n def testParseArgsFilePaths(self):\n  program = self.program\n  argv = ['progname', 'foo/bar/baz.py', 'green\\\\red.py']\n  self._patch_isfile(argv)\n  \n  program.createTests = lambda: None\n  program.parseArgs(argv)\n  \n  expected = ['foo.bar.baz', 'green.red']\n  self.assertEqual(program.testNames, expected)\n  \n  \n def testParseArgsNonExistentFiles(self):\n  program = self.program\n  argv = ['progname', 'foo/bar/baz.py', 'green\\\\red.py']\n  self._patch_isfile([])\n  \n  program.createTests = lambda: None\n  program.parseArgs(argv)\n  \n  self.assertEqual(program.testNames, argv[1:])\n  \n def testParseArgsAbsolutePathsThatCanBeConverted(self):\n  cur_dir = os.getcwd()\n  program = self.program\n  def _join(name):\n   return os.path.join(cur_dir, name)\n  argv = ['progname', _join('foo/bar/baz.py'), _join('green\\\\red.py')]\n  self._patch_isfile(argv)\n  \n  program.createTests = lambda: None\n  program.parseArgs(argv)\n  \n  expected = ['foo.bar.baz', 'green.red']\n  self.assertEqual(program.testNames, expected)\n  \n def testParseArgsAbsolutePathsThatCannotBeConverted(self):\n  program = self.program\n  \n  argv = ['progname', '/foo/bar/baz.py', '/green/red.py']\n  self._patch_isfile(argv)\n  \n  program.createTests = lambda: None\n  program.parseArgs(argv)\n  \n  self.assertEqual(program.testNames, argv[1:])\n  \n  \n  \n  \n  \n  \n  \n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.test.support": ["import unittest\n\n\nclass TestEquality(object):\n \"\"\n \n \n def test_eq(self):\n  for obj_1, obj_2 in self.eq_pairs:\n   self.assertEqual(obj_1, obj_2)\n   self.assertEqual(obj_2, obj_1)\n   \n   \n def test_ne(self):\n  for obj_1, obj_2 in self.ne_pairs:\n   self.assertNotEqual(obj_1, obj_2)\n   self.assertNotEqual(obj_2, obj_1)\n   \nclass TestHashing(object):\n \"\"\n \n \n def test_hash(self):\n  for obj_1, obj_2 in self.eq_pairs:\n   try:\n    if not hash(obj_1) == hash(obj_2):\n     self.fail(\"%r and %r do not hash equal\" % (obj_1, obj_2))\n   except KeyboardInterrupt:\n    raise\n   except Exception as e:\n    self.fail(\"Problem hashing %r and %r: %s\" % (obj_1, obj_2, e))\n    \n  for obj_1, obj_2 in self.ne_pairs:\n   try:\n    if hash(obj_1) == hash(obj_2):\n     self.fail(\"%s and %s hash equal, but shouldn't\" %\n     (obj_1, obj_2))\n   except KeyboardInterrupt:\n    raise\n   except Exception as e:\n    self.fail(\"Problem hashing %s and %s: %s\" % (obj_1, obj_2, e))\n    \n    \nclass LoggingResult(unittest.TestResult):\n def __init__(self, log):\n  self._events = log\n  super().__init__()\n  \n def startTest(self, test):\n  self._events.append('startTest')\n  super().startTest(test)\n  \n def startTestRun(self):\n  self._events.append('startTestRun')\n  super(LoggingResult, self).startTestRun()\n  \n def stopTest(self, test):\n  self._events.append('stopTest')\n  super().stopTest(test)\n  \n def stopTestRun(self):\n  self._events.append('stopTestRun')\n  super(LoggingResult, self).stopTestRun()\n  \n def addFailure(self, *args):\n  self._events.append('addFailure')\n  super().addFailure(*args)\n  \n def addSuccess(self, *args):\n  self._events.append('addSuccess')\n  super(LoggingResult, self).addSuccess(*args)\n  \n def addError(self, *args):\n  self._events.append('addError')\n  super().addError(*args)\n  \n def addSkip(self, *args):\n  self._events.append('addSkip')\n  super(LoggingResult, self).addSkip(*args)\n  \n def addExpectedFailure(self, *args):\n  self._events.append('addExpectedFailure')\n  super(LoggingResult, self).addExpectedFailure(*args)\n  \n def addUnexpectedSuccess(self, *args):\n  self._events.append('addUnexpectedSuccess')\n  super(LoggingResult, self).addUnexpectedSuccess(*args)\n  \n  \nclass ResultWithNoStartTestRunStopTestRun(object):\n \"\"\n \n def __init__(self):\n  self.failures = []\n  self.errors = []\n  self.testsRun = 0\n  self.skipped = []\n  self.expectedFailures = []\n  self.unexpectedSuccesses = []\n  self.shouldStop = False\n  \n def startTest(self, test):\n  pass\n  \n def stopTest(self, test):\n  pass\n  \n def addError(self, test):\n  pass\n  \n def addFailure(self, test):\n  pass\n  \n def addSuccess(self, test):\n  pass\n  \n def wasSuccessful(self):\n  return True\n"], "test.support": ["\"\"\n\nif __name__ != 'test.support':\n raise ImportError('support must be imported from the test package')\n \nimport contextlib\nimport errno\nimport functools\nimport gc\nimport socket\nimport sys\nimport os\nimport platform\nimport shutil\nimport warnings\nimport unittest\nimport importlib\nimport collections.abc\nimport re\nimport subprocess\nimport imp\nimport time\nimport sysconfig\nimport fnmatch\nimport logging.handlers\nimport struct\nimport tempfile\nimport _testcapi\n\ntry:\n import _thread, threading\nexcept ImportError:\n _thread = None\n threading = None\n \n \n \n \n \n \n \nmultiprocessing = None\n\ntry:\n import zlib\nexcept ImportError:\n zlib = None\n \ntry:\n import bz2\nexcept ImportError:\n bz2 = None\n \ntry:\n import lzma\nexcept ImportError:\n lzma = None\n \n__all__ = [\n\"Error\", \"TestFailed\", \"ResourceDenied\", \"import_module\", \"verbose\",\n\"use_resources\", \"max_memuse\", \"record_original_stdout\",\n\"get_original_stdout\", \"unload\", \"unlink\", \"rmtree\", \"forget\",\n\"is_resource_enabled\", \"requires\", \"requires_freebsd_version\",\n\"requires_linux_version\", \"requires_mac_ver\", \"find_unused_port\",\n\"bind_port\", \"IPV6_ENABLED\", \"is_jython\", \"TESTFN\", \"HOST\", \"SAVEDCWD\",\n\"temp_cwd\", \"findfile\", \"create_empty_file\", \"sortdict\",\n\"check_syntax_error\", \"open_urlresource\", \"check_warnings\", \"CleanImport\",\n\"EnvironmentVarGuard\", \"TransientResource\", \"captured_stdout\",\n\"captured_stdin\", \"captured_stderr\", \"time_out\", \"socket_peer_reset\",\n\"ioerror_peer_reset\", \"run_with_locale\", 'temp_umask',\n\"transient_internet\", \"set_memlimit\", \"bigmemtest\", \"bigaddrspacetest\",\n\"BasicTestRunner\", \"run_unittest\", \"run_doctest\", \"threading_setup\",\n\"threading_cleanup\", \"reap_children\", \"cpython_only\", \"check_impl_detail\",\n\"get_attribute\", \"swap_item\", \"swap_attr\", \"requires_IEEE_754\",\n\"TestHandler\", \"Matcher\", \"can_symlink\", \"skip_unless_symlink\",\n\"skip_unless_xattr\", \"import_fresh_module\", \"requires_zlib\",\n\"PIPE_MAX_SIZE\", \"failfast\", \"anticipate_failure\", \"run_with_tz\",\n\"requires_bz2\", \"requires_lzma\", \"suppress_crash_popup\",\n]\n\nclass Error(Exception):\n \"\"\n \nclass TestFailed(Error):\n \"\"\n \nclass ResourceDenied(unittest.SkipTest):\n \"\"\n \n@contextlib.contextmanager\ndef _ignore_deprecated_imports(ignore=True):\n \"\"\n if ignore:\n  with warnings.catch_warnings():\n   warnings.filterwarnings(\"ignore\", \".+ (module|package)\",\n   DeprecationWarning)\n   yield\n else:\n  yield\n  \n  \ndef import_module(name, deprecated=False):\n \"\"\n with _ignore_deprecated_imports(deprecated):\n  try:\n   return importlib.import_module(name)\n  except ImportError as msg:\n   raise unittest.SkipTest(str(msg))\n   \n   \ndef _save_and_remove_module(name, orig_modules):\n \"\"\n \n if name not in sys.modules:\n  __import__(name)\n  del sys.modules[name]\n for modname in list(sys.modules):\n  if modname == name or modname.startswith(name + '.'):\n   orig_modules[modname] = sys.modules[modname]\n   del sys.modules[modname]\n   \ndef _save_and_block_module(name, orig_modules):\n \"\"\n saved = True\n try:\n  orig_modules[name] = sys.modules[name]\n except KeyError:\n  saved = False\n sys.modules[name] = None\n return saved\n \n \ndef anticipate_failure(condition):\n \"\"\n if condition:\n  return unittest.expectedFailure\n return lambda f: f\n \n \ndef import_fresh_module(name, fresh=(), blocked=(), deprecated=False):\n \"\"\n \n \n with _ignore_deprecated_imports(deprecated):\n \n \n  orig_modules = {}\n  names_to_remove = []\n  _save_and_remove_module(name, orig_modules)\n  try:\n   for fresh_name in fresh:\n    _save_and_remove_module(fresh_name, orig_modules)\n   for blocked_name in blocked:\n    if not _save_and_block_module(blocked_name, orig_modules):\n     names_to_remove.append(blocked_name)\n   fresh_module = importlib.import_module(name)\n  except ImportError:\n   fresh_module = None\n  finally:\n   for orig_name, module in orig_modules.items():\n    sys.modules[orig_name] = module\n   for name_to_remove in names_to_remove:\n    del sys.modules[name_to_remove]\n  return fresh_module\n  \n  \ndef get_attribute(obj, name):\n \"\"\n try:\n  attribute = getattr(obj, name)\n except AttributeError:\n  raise unittest.SkipTest(\"object %r has no attribute %r\" % (obj, name))\n else:\n  return attribute\n  \nverbose = 1 \nuse_resources = None \nmax_memuse = 0 \n\nreal_max_memuse = 0\nfailfast = False\nmatch_tests = None\n\n\n\n\n_original_stdout = None\ndef record_original_stdout(stdout):\n global _original_stdout\n _original_stdout = stdout\n \ndef get_original_stdout():\n return _original_stdout or sys.stdout\n \ndef unload(name):\n try:\n  del sys.modules[name]\n except KeyError:\n  pass\n  \nif sys.platform.startswith(\"win\"):\n def _waitfor(func, pathname, waitall=False):\n \n  func(pathname)\n  \n  if waitall:\n   dirname = pathname\n  else:\n   dirname, name = os.path.split(pathname)\n   dirname = dirname or '.'\n   \n   \n   \n   \n   \n   \n  timeout = 0.001\n  while timeout < 1.0:\n  \n  \n  \n  \n  \n  \n  \n   L = os.listdir(dirname)\n   if not (L if waitall else name in L):\n    return\n    \n   time.sleep(timeout)\n   timeout *= 2\n  warnings.warn('tests may fail, delete still pending for ' + pathname,\n  RuntimeWarning, stacklevel=4)\n  \n def _unlink(filename):\n  _waitfor(os.unlink, filename)\n  \n def _rmdir(dirname):\n  _waitfor(os.rmdir, dirname)\n  \n def _rmtree(path):\n  def _rmtree_inner(path):\n   for name in os.listdir(path):\n    fullname = os.path.join(path, name)\n    if os.path.isdir(fullname):\n     _waitfor(_rmtree_inner, fullname, waitall=True)\n     os.rmdir(fullname)\n    else:\n     os.unlink(fullname)\n  _waitfor(_rmtree_inner, path, waitall=True)\n  _waitfor(os.rmdir, path)\nelse:\n _unlink = os.unlink\n _rmdir = os.rmdir\n _rmtree = shutil.rmtree\n \ndef unlink(filename):\n try:\n  _unlink(filename)\n except OSError as error:\n \n  if error.errno not in (errno.ENOENT, errno.ENOTDIR):\n   raise\n   \ndef rmdir(dirname):\n try:\n  _rmdir(dirname)\n except OSError as error:\n \n  if error.errno != errno.ENOENT:\n   raise\n   \ndef rmtree(path):\n try:\n  _rmtree(path)\n except OSError as error:\n  if error.errno != errno.ENOENT:\n   raise\n   \ndef make_legacy_pyc(source):\n \"\"\n pyc_file = imp.cache_from_source(source)\n up_one = os.path.dirname(os.path.abspath(source))\n legacy_pyc = os.path.join(up_one, source + ('c' if __debug__ else 'o'))\n os.rename(pyc_file, legacy_pyc)\n return legacy_pyc\n \ndef forget(modname):\n \"\"\n unload(modname)\n for dirname in sys.path:\n  source = os.path.join(dirname, modname + '.py')\n  \n  \n  unlink(source + 'c')\n  unlink(source + 'o')\n  unlink(imp.cache_from_source(source, debug_override=True))\n  unlink(imp.cache_from_source(source, debug_override=False))\n  \n  \n  \nif sys.platform.startswith('win'):\n import ctypes\n import ctypes.wintypes\n def _is_gui_available():\n  UOI_FLAGS = 1\n  WSF_VISIBLE = 0x0001\n  class USEROBJECTFLAGS(ctypes.Structure):\n   _fields_ = [(\"fInherit\", ctypes.wintypes.BOOL),\n   (\"fReserved\", ctypes.wintypes.BOOL),\n   (\"dwFlags\", ctypes.wintypes.DWORD)]\n  dll = ctypes.windll.user32\n  h = dll.GetProcessWindowStation()\n  if not h:\n   raise ctypes.WinError()\n  uof = USEROBJECTFLAGS()\n  needed = ctypes.wintypes.DWORD()\n  res = dll.GetUserObjectInformationW(h,\n  UOI_FLAGS,\n  ctypes.byref(uof),\n  ctypes.sizeof(uof),\n  ctypes.byref(needed))\n  if not res:\n   raise ctypes.WinError()\n  return bool(uof.dwFlags & WSF_VISIBLE)\nelse:\n def _is_gui_available():\n  return True\n  \ndef is_resource_enabled(resource):\n \"\"\n return use_resources is not None and resource in use_resources\n \ndef requires(resource, msg=None):\n \"\"\n if resource == 'gui' and not _is_gui_available():\n  raise unittest.SkipTest(\"Cannot use the 'gui' resource\")\n  \n  \n if sys._getframe(1).f_globals.get(\"__name__\") == \"__main__\":\n  return\n if not is_resource_enabled(resource):\n  if msg is None:\n   msg = \"Use of the %r resource not enabled\" % resource\n  raise ResourceDenied(msg)\n  \ndef _requires_unix_version(sysname, min_version):\n \"\"\n def decorator(func):\n  @functools.wraps(func)\n  def wrapper(*args, **kw):\n   if platform.system() == sysname:\n    version_txt = platform.release().split('-', 1)[0]\n    try:\n     version = tuple(map(int, version_txt.split('.')))\n    except ValueError:\n     pass\n    else:\n     if version < min_version:\n      min_version_txt = '.'.join(map(str, min_version))\n      raise unittest.SkipTest(\n      \"%s version %s or higher required, not %s\"\n      % (sysname, min_version_txt, version_txt))\n  return wrapper\n return decorator\n \ndef requires_freebsd_version(*min_version):\n \"\"\n return _requires_unix_version('FreeBSD', min_version)\n \ndef requires_linux_version(*min_version):\n \"\"\n return _requires_unix_version('Linux', min_version)\n \ndef requires_mac_ver(*min_version):\n \"\"\n def decorator(func):\n  @functools.wraps(func)\n  def wrapper(*args, **kw):\n   if sys.platform == 'darwin':\n    version_txt = platform.mac_ver()[0]\n    try:\n     version = tuple(map(int, version_txt.split('.')))\n    except ValueError:\n     pass\n    else:\n     if version < min_version:\n      min_version_txt = '.'.join(map(str, min_version))\n      raise unittest.SkipTest(\n      \"Mac OS X %s or higher required, not %s\"\n      % (min_version_txt, version_txt))\n   return func(*args, **kw)\n  wrapper.min_version = min_version\n  return wrapper\n return decorator\n \n \nHOST = 'localhost'\n\ndef find_unused_port(family=socket.AF_INET, socktype=socket.SOCK_STREAM):\n \"\"\n \n tempsock = socket.socket(family, socktype)\n port = bind_port(tempsock)\n tempsock.close()\n del tempsock\n return port\n \ndef bind_port(sock, host=HOST):\n \"\"\n \n if sock.family == socket.AF_INET and sock.type == socket.SOCK_STREAM:\n  if hasattr(socket, 'SO_REUSEADDR'):\n   if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) == 1:\n    raise TestFailed(\"tests should never set the SO_REUSEADDR \" \"socket option on TCP/IP sockets!\")\n  if hasattr(socket, 'SO_REUSEPORT'):\n   if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 1:\n    raise TestFailed(\"tests should never set the SO_REUSEPORT \" \"socket option on TCP/IP sockets!\")\n  if hasattr(socket, 'SO_EXCLUSIVEADDRUSE'):\n   sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)\n   \n sock.bind((host, 0))\n port = sock.getsockname()[1]\n return port\n \ndef _is_ipv6_enabled():\n \"\"\n if socket.has_ipv6:\n  sock = None\n  try:\n   sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n   sock.bind(('::1', 0))\n   return True\n  except (socket.error, socket.gaierror):\n   pass\n  finally:\n   if sock:\n    sock.close()\n return False\n \nIPV6_ENABLED = _is_ipv6_enabled()\n\n\n\n\n\nPIPE_MAX_SIZE = 3 * 1000 * 1000\n\n\n\nrequires_IEEE_754 = unittest.skipUnless(\nfloat.__getformat__(\"double\").startswith(\"IEEE\"),\n\"test requires IEEE 754 doubles\")\n\nrequires_zlib = unittest.skipUnless(zlib, 'requires zlib')\n\nrequires_bz2 = unittest.skipUnless(bz2, 'requires bz2')\n\nrequires_lzma = unittest.skipUnless(lzma, 'requires lzma')\n\nis_jython = sys.platform.startswith('java')\n\n\nif os.name == 'java':\n\n TESTFN = '$test'\nelse:\n TESTFN = '@test'\n \n \n \nTESTFN = \"{}_{}_tmp\".format(TESTFN, os.getpid())\n\n\n\nFS_NONASCII = None\nfor character in (\n\n\n\n\n\n'\\u00E6',\n\n'\\u0130',\n\n'\\u0141',\n\n'\\u03C6',\n\n'\\u041A',\n\n'\\u05D0',\n\n'\\u060C',\n\n'\\u062A',\n\n'\\u0E01',\n\n\n\n\n\n\n'\\u00A0',\n\n'\\u20AC',\n):\n try:\n  os.fsdecode(os.fsencode(character))\n except UnicodeError:\n  pass\n else:\n  FS_NONASCII = character\n  break\n  \n  \nTESTFN_UNICODE = TESTFN + \"-\\xe0\\xf2\\u0258\\u0141\\u011f\"\nif sys.platform == 'darwin':\n\n\n\n import unicodedata\n TESTFN_UNICODE = unicodedata.normalize('NFD', TESTFN_UNICODE)\nTESTFN_ENCODING = sys.getfilesystemencoding()\n\n\n\n\nTESTFN_UNENCODABLE = None\nif os.name in ('nt', 'ce'):\n\n if sys.getwindowsversion().platform >= 2:\n \n \n  TESTFN_UNENCODABLE = TESTFN + \"-\\u5171\\u0141\\u2661\\u0363\\uDC80\"\n  try:\n   TESTFN_UNENCODABLE.encode(TESTFN_ENCODING)\n  except UnicodeEncodeError:\n   pass\n  else:\n   print('WARNING: The filename %r CAN be encoded by the filesystem encoding (%s). '\n   'Unicode filename tests may not be effective'\n   % (TESTFN_UNENCODABLE, TESTFN_ENCODING))\n   TESTFN_UNENCODABLE = None\n   \nelif sys.platform != 'darwin':\n try:\n \n  \"\".decode(TESTFN_ENCODING)\n except UnicodeDecodeError:\n \n  TESTFN_UNENCODABLE = TESTFN + b'-\\xff'.decode(TESTFN_ENCODING, 'surrogateescape')\n else:\n \n \n  pass\n  \n  \n  \n  \n  \n  \n  \nTESTFN_UNDECODABLE = None\n\"\"\nif FS_NONASCII:\n TESTFN_NONASCII = TESTFN + '-' + FS_NONASCII\nelse:\n TESTFN_NONASCII = None\n \n \nSAVEDCWD = os.getcwd()\n\n@contextlib.contextmanager\ndef temp_cwd(name='tempcwd', quiet=False, path=None):\n \"\"\n saved_dir = os.getcwd()\n is_temporary = False\n if path is None:\n  path = name\n  try:\n   os.mkdir(name)\n   is_temporary = True\n  except OSError:\n   if not quiet:\n    raise\n   warnings.warn('tests may fail, unable to create temp CWD ' + name,\n   RuntimeWarning, stacklevel=3)\n try:\n  os.chdir(path)\n except OSError:\n  if not quiet:\n   raise\n  warnings.warn('tests may fail, unable to change the CWD to ' + path,\n  RuntimeWarning, stacklevel=3)\n try:\n  yield os.getcwd()\n finally:\n  os.chdir(saved_dir)\n  if is_temporary:\n   rmtree(name)\n   \n   \nif hasattr(os, \"umask\"):\n @contextlib.contextmanager\n def temp_umask(umask):\n  \"\"\n  oldmask = os.umask(umask)\n  try:\n   yield\n  finally:\n   os.umask(oldmask)\n   \n   \ndef findfile(file, here=__file__, subdir=None):\n \"\"\n if os.path.isabs(file):\n  return file\n if subdir is not None:\n  file = os.path.join(subdir, file)\n path = sys.path\n path = [os.path.dirname(here)] + path\n for dn in path:\n  fn = os.path.join(dn, file)\n  if os.path.exists(fn): return fn\n return file\n \ndef create_empty_file(filename):\n \"\"\n fd = os.open(filename, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)\n os.close(fd)\n \ndef sortdict(dict):\n \"\"\n items = sorted(dict.items())\n reprpairs = [\"%r: %r\" % pair for pair in items]\n withcommas = \", \".join(reprpairs)\n return \"{%s}\" % withcommas\n \ndef make_bad_fd():\n \"\"\n file = open(TESTFN, \"wb\")\n try:\n  return file.fileno()\n finally:\n  file.close()\n  unlink(TESTFN)\n  \ndef check_syntax_error(testcase, statement):\n testcase.assertRaises(SyntaxError, compile, statement,\n '<test string>', 'exec')\n \ndef open_urlresource(url, *args, **kw):\n import urllib.request, urllib.parse\n \n check = kw.pop('check', None)\n \n filename = urllib.parse.urlparse(url)[2].split('/')[-1] \n \n fn = os.path.join(os.path.dirname(__file__), \"data\", filename)\n \n def check_valid_file(fn):\n  f = open(fn, *args, **kw)\n  if check is None:\n   return f\n  elif check(f):\n   f.seek(0)\n   return f\n  f.close()\n  \n if os.path.exists(fn):\n  f = check_valid_file(fn)\n  if f is not None:\n   return f\n  unlink(fn)\n  \n  \n requires('urlfetch')\n \n print('\\tfetching %s ...' % url, file=get_original_stdout())\n f = urllib.request.urlopen(url, timeout=15)\n try:\n  with open(fn, \"wb\") as out:\n   s = f.read()\n   while s:\n    out.write(s)\n    s = f.read()\n finally:\n  f.close()\n  \n f = check_valid_file(fn)\n if f is not None:\n  return f\n raise TestFailed('invalid resource %r' % fn)\n \n \nclass WarningsRecorder(object):\n \"\"\n def __init__(self, warnings_list):\n  self._warnings = warnings_list\n  self._last = 0\n  \n def __getattr__(self, attr):\n  if len(self._warnings) > self._last:\n   return getattr(self._warnings[-1], attr)\n  elif attr in warnings.WarningMessage._WARNING_DETAILS:\n   return None\n  raise AttributeError(\"%r has no attribute %r\" % (self, attr))\n  \n @property\n def warnings(self):\n  return self._warnings[self._last:]\n  \n def reset(self):\n  self._last = len(self._warnings)\n  \n  \ndef _filterwarnings(filters, quiet=False):\n \"\"\n \n \n frame = sys._getframe(2)\n registry = frame.f_globals.get('__warningregistry__')\n if registry:\n  registry.clear()\n with warnings.catch_warnings(record=True) as w:\n \n \n \n  sys.modules['warnings'].simplefilter(\"always\")\n  yield WarningsRecorder(w)\n  \n reraise = list(w)\n missing = []\n for msg, cat in filters:\n  seen = False\n  for w in reraise[:]:\n   warning = w.message\n   \n   if (re.match(msg, str(warning), re.I) and\n   issubclass(warning.__class__, cat)):\n    seen = True\n    reraise.remove(w)\n  if not seen and not quiet:\n  \n   missing.append((msg, cat.__name__))\n if reraise:\n  raise AssertionError(\"unhandled warning %s\" % reraise[0])\n if missing:\n  raise AssertionError(\"filter (%r, %s) did not catch any warning\" %\n  missing[0])\n  \n  \n@contextlib.contextmanager\ndef check_warnings(*filters, **kwargs):\n \"\"\n quiet = kwargs.get('quiet')\n if not filters:\n  filters = ((\"\", Warning),)\n  \n  if quiet is None:\n   quiet = True\n return _filterwarnings(filters, quiet)\n \n \nclass CleanImport(object):\n \"\"\n \n def __init__(self, *module_names):\n  self.original_modules = sys.modules.copy()\n  for module_name in module_names:\n   if module_name in sys.modules:\n    module = sys.modules[module_name]\n    \n    \n    \n    \n    if module.__name__ != module_name:\n     del sys.modules[module.__name__]\n    del sys.modules[module_name]\n    \n def __enter__(self):\n  return self\n  \n def __exit__(self, *ignore_exc):\n  sys.modules.update(self.original_modules)\n  \n  \nclass EnvironmentVarGuard(collections.abc.MutableMapping):\n\n \"\"\n \n def __init__(self):\n  self._environ = os.environ\n  self._changed = {}\n  \n def __getitem__(self, envvar):\n  return self._environ[envvar]\n  \n def __setitem__(self, envvar, value):\n \n  if envvar not in self._changed:\n   self._changed[envvar] = self._environ.get(envvar)\n  self._environ[envvar] = value\n  \n def __delitem__(self, envvar):\n \n  if envvar not in self._changed:\n   self._changed[envvar] = self._environ.get(envvar)\n  if envvar in self._environ:\n   del self._environ[envvar]\n   \n def keys(self):\n  return self._environ.keys()\n  \n def __iter__(self):\n  return iter(self._environ)\n  \n def __len__(self):\n  return len(self._environ)\n  \n def set(self, envvar, value):\n  self[envvar] = value\n  \n def unset(self, envvar):\n  del self[envvar]\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, *ignore_exc):\n  for (k, v) in self._changed.items():\n   if v is None:\n    if k in self._environ:\n     del self._environ[k]\n   else:\n    self._environ[k] = v\n  os.environ = self._environ\n  \n  \nclass DirsOnSysPath(object):\n \"\"\n \n def __init__(self, *paths):\n  self.original_value = sys.path[:]\n  self.original_object = sys.path\n  sys.path.extend(paths)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, *ignore_exc):\n  sys.path = self.original_object\n  sys.path[:] = self.original_value\n  \n  \nclass TransientResource(object):\n\n \"\"\n \n def __init__(self, exc, **kwargs):\n  self.exc = exc\n  self.attrs = kwargs\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, type_=None, value=None, traceback=None):\n  \"\"\n  if type_ is not None and issubclass(self.exc, type_):\n   for attr, attr_value in self.attrs.items():\n    if not hasattr(value, attr):\n     break\n    if getattr(value, attr) != attr_value:\n     break\n   else:\n    raise ResourceDenied(\"an optional resource is not available\")\n    \n    \n    \n    \ntime_out = TransientResource(IOError, errno=errno.ETIMEDOUT)\nsocket_peer_reset = TransientResource(socket.error, errno=errno.ECONNRESET)\nioerror_peer_reset = TransientResource(IOError, errno=errno.ECONNRESET)\n\n\n@contextlib.contextmanager\ndef transient_internet(resource_name, *, timeout=30.0, errnos=()):\n \"\"\n default_errnos = [\n ('ECONNREFUSED', 111),\n ('ECONNRESET', 104),\n ('EHOSTUNREACH', 113),\n ('ENETUNREACH', 101),\n ('ETIMEDOUT', 110),\n ]\n default_gai_errnos = [\n ('EAI_AGAIN', -3),\n ('EAI_FAIL', -4),\n ('EAI_NONAME', -2),\n ('EAI_NODATA', -5),\n \n ('WSANO_DATA', 11004),\n ]\n \n denied = ResourceDenied(\"Resource %r is not available\" % resource_name)\n captured_errnos = errnos\n gai_errnos = []\n if not captured_errnos:\n  captured_errnos = [getattr(errno, name, num)\n  for (name, num) in default_errnos]\n  gai_errnos = [getattr(socket, name, num)\n  for (name, num) in default_gai_errnos]\n  \n def filter_error(err):\n  n = getattr(err, 'errno', None)\n  if (isinstance(err, socket.timeout) or\n  (isinstance(err, socket.gaierror) and n in gai_errnos) or\n  n in captured_errnos):\n   if not verbose:\n    sys.stderr.write(denied.args[0] + \"\\n\")\n   raise denied from err\n   \n old_timeout = socket.getdefaulttimeout()\n try:\n  if timeout is not None:\n   socket.setdefaulttimeout(timeout)\n  yield\n except IOError as err:\n \n \n  while True:\n   a = err.args\n   if len(a) >= 1 and isinstance(a[0], IOError):\n    err = a[0]\n    \n    \n    \n   elif len(a) >= 2 and isinstance(a[1], IOError):\n    err = a[1]\n   else:\n    break\n  filter_error(err)\n  raise\n  \n  \n finally:\n  socket.setdefaulttimeout(old_timeout)\n  \n  \n@contextlib.contextmanager\ndef captured_output(stream_name):\n \"\"\n import io\n orig_stdout = getattr(sys, stream_name)\n setattr(sys, stream_name, io.StringIO())\n try:\n  yield getattr(sys, stream_name)\n finally:\n  setattr(sys, stream_name, orig_stdout)\n  \ndef captured_stdout():\n \"\"\n return captured_output(\"stdout\")\n \ndef captured_stderr():\n return captured_output(\"stderr\")\n \ndef captured_stdin():\n return captured_output(\"stdin\")\n \n \ndef gc_collect():\n \"\"\n gc.collect()\n if is_jython:\n  time.sleep(0.1)\n gc.collect()\n gc.collect()\n \n@contextlib.contextmanager\ndef disable_gc():\n have_gc = gc.isenabled()\n gc.disable()\n try:\n  yield\n finally:\n  if have_gc:\n   gc.enable()\n   \n   \ndef python_is_optimized():\n \"\"\n cflags = sysconfig.get_config_var('PY_CFLAGS') or ''\n final_opt = \"\"\n for opt in cflags.split():\n  if opt.startswith('-O'):\n   final_opt = opt\n return final_opt != '' and final_opt != '-O0'\n \n \n_header = 'nP'\n_align = '0n'\nif hasattr(sys, \"gettotalrefcount\"):\n _header = '2P' + _header\n _align = '0P'\n_vheader = _header + 'n'\n\ndef calcobjsize(fmt):\n return struct.calcsize(_header + fmt + _align)\n \ndef calcvobjsize(fmt):\n return struct.calcsize(_vheader + fmt + _align)\n \n \n_TPFLAGS_HAVE_GC = 1<<14\n_TPFLAGS_HEAPTYPE = 1<<9\n\ndef check_sizeof(test, o, size):\n result = sys.getsizeof(o)\n \n if ((type(o) == type) and (o.__flags__ & _TPFLAGS_HEAPTYPE) or ((type(o) != type) and (type(o).__flags__ & _TPFLAGS_HAVE_GC))):\n  size += _testcapi.SIZEOF_PYGC_HEAD\n msg = 'wrong size for %s: got %d, expected %d' % (type(o), result, size)\n test.assertEqual(result, size, msg)\n \n \n \n \n \ndef run_with_locale(catstr, *locales):\n def decorator(func):\n  def inner(*args, **kwds):\n   try:\n    import locale\n    category = getattr(locale, catstr)\n    orig_locale = locale.setlocale(category)\n   except AttributeError:\n   \n    raise\n   except:\n   \n    locale = orig_locale = None\n   else:\n    for loc in locales:\n     try:\n      locale.setlocale(category, loc)\n      break\n     except:\n      pass\n      \n      \n   try:\n    return func(*args, **kwds)\n   finally:\n    if locale and orig_locale:\n     locale.setlocale(category, orig_locale)\n  inner.__name__ = func.__name__\n  inner.__doc__ = func.__doc__\n  return inner\n return decorator\n \n \n \n \n \ndef run_with_tz(tz):\n def decorator(func):\n  def inner(*args, **kwds):\n   try:\n    tzset = time.tzset\n   except AttributeError:\n    raise unittest.SkipTest(\"tzset required\")\n   if 'TZ' in os.environ:\n    orig_tz = os.environ['TZ']\n   else:\n    orig_tz = None\n   os.environ['TZ'] = tz\n   tzset()\n   \n   \n   try:\n    return func(*args, **kwds)\n   finally:\n    if orig_tz is None:\n     del os.environ['TZ']\n    else:\n     os.environ['TZ'] = orig_tz\n    time.tzset()\n    \n  inner.__name__ = func.__name__\n  inner.__doc__ = func.__doc__\n  return inner\n return decorator\n \n \n \n \n \n \n \n_1M = 1024*1024\n_1G = 1024 * _1M\n_2G = 2 * _1G\n_4G = 4 * _1G\n\nMAX_Py_ssize_t = sys.maxsize\n\ndef set_memlimit(limit):\n global max_memuse\n global real_max_memuse\n sizes = {\n 'k': 1024,\n 'm': _1M,\n 'g': _1G,\n 't': 1024*_1G,\n }\n m = re.match(r'(\\d+(\\.\\d+)?) (K|M|G|T)b?$', limit,\n re.IGNORECASE | re.VERBOSE)\n if m is None:\n  raise ValueError('Invalid memory limit %r' % (limit,))\n memlimit = int(float(m.group(1)) * sizes[m.group(3).lower()])\n real_max_memuse = memlimit\n if memlimit > MAX_Py_ssize_t:\n  memlimit = MAX_Py_ssize_t\n if memlimit < _2G - 1:\n  raise ValueError('Memory limit %r too low to be useful' % (limit,))\n max_memuse = memlimit\n \nclass _MemoryWatchdog:\n \"\"\n \n def __init__(self):\n  self.procfile = '/proc/{pid}/statm'.format(pid=os.getpid())\n  self.started = False\n  \n def start(self):\n  try:\n   f = open(self.procfile, 'r')\n  except OSError as e:\n   warnings.warn('/proc not available for stats: {}'.format(e),\n   RuntimeWarning)\n   sys.stderr.flush()\n   return\n   \n  watchdog_script = findfile(\"memory_watchdog.py\")\n  self.mem_watchdog = subprocess.Popen([sys.executable, watchdog_script],\n  stdin=f, stderr=subprocess.DEVNULL)\n  f.close()\n  self.started = True\n  \n def stop(self):\n  if self.started:\n   self.mem_watchdog.terminate()\n   self.mem_watchdog.wait()\n   \n   \ndef bigmemtest(size, memuse, dry_run=True):\n \"\"\n def decorator(f):\n  def wrapper(self):\n   size = wrapper.size\n   memuse = wrapper.memuse\n   if not real_max_memuse:\n    maxsize = 5147\n   else:\n    maxsize = size\n    \n   if ((real_max_memuse or not dry_run)\n   and real_max_memuse < maxsize * memuse):\n    raise unittest.SkipTest(\n    \"not enough memory: %.1fG minimum needed\"\n    % (size * memuse / (1024 ** 3)))\n    \n   if real_max_memuse and verbose:\n    print()\n    print(\" ... expected peak memory use: {peak:.1f}G\"\n    .format(peak=size * memuse / (1024 ** 3)))\n    watchdog = _MemoryWatchdog()\n    watchdog.start()\n   else:\n    watchdog = None\n    \n   try:\n    return f(self, maxsize)\n   finally:\n    if watchdog:\n     watchdog.stop()\n     \n  wrapper.size = size\n  wrapper.memuse = memuse\n  return wrapper\n return decorator\n \ndef bigaddrspacetest(f):\n \"\"\n def wrapper(self):\n  if max_memuse < MAX_Py_ssize_t:\n   if MAX_Py_ssize_t >= 2**63 - 1 and max_memuse >= 2**31:\n    raise unittest.SkipTest(\n    \"not enough memory: try a 32-bit build instead\")\n   else:\n    raise unittest.SkipTest(\n    \"not enough memory: %.1fG minimum needed\"\n    % (MAX_Py_ssize_t / (1024 ** 3)))\n  else:\n   return f(self)\n return wrapper\n \n \n \n \nclass BasicTestRunner:\n def run(self, test):\n  result = unittest.TestResult()\n  test(result)\n  return result\n  \ndef _id(obj):\n return obj\n \ndef requires_resource(resource):\n if resource == 'gui' and not _is_gui_available():\n  return unittest.skip(\"resource 'gui' is not available\")\n if is_resource_enabled(resource):\n  return _id\n else:\n  return unittest.skip(\"resource {0!r} is not enabled\".format(resource))\n  \ndef cpython_only(test):\n \"\"\n return impl_detail(cpython=True)(test)\n \ndef impl_detail(msg=None, **guards):\n if check_impl_detail(**guards):\n  return _id\n if msg is None:\n  guardnames, default = _parse_guards(guards)\n  if default:\n   msg = \"implementation detail not available on {0}\"\n  else:\n   msg = \"implementation detail specific to {0}\"\n  guardnames = sorted(guardnames.keys())\n  msg = msg.format(' or '.join(guardnames))\n return unittest.skip(msg)\n \ndef _parse_guards(guards):\n\n if not guards:\n  return ({'cpython': True}, False)\n is_true = list(guards.values())[0]\n assert list(guards.values()) == [is_true] * len(guards) \n return (guards, not is_true)\n \n \n \ndef check_impl_detail(**guards):\n \"\"\n guards, default = _parse_guards(guards)\n return guards.get(platform.python_implementation().lower(), default)\n \n \ndef no_tracing(func):\n \"\"\n if not hasattr(sys, 'gettrace'):\n  return func\n else:\n  @functools.wraps(func)\n  def wrapper(*args, **kwargs):\n   original_trace = sys.gettrace()\n   try:\n    sys.settrace(None)\n    return func(*args, **kwargs)\n   finally:\n    sys.settrace(original_trace)\n  return wrapper\n  \n  \ndef refcount_test(test):\n \"\"\n return no_tracing(cpython_only(test))\n \n \ndef _filter_suite(suite, pred):\n \"\"\n newtests = []\n for test in suite._tests:\n  if isinstance(test, unittest.TestSuite):\n   _filter_suite(test, pred)\n   newtests.append(test)\n  else:\n   if pred(test):\n    newtests.append(test)\n suite._tests = newtests\n \ndef _run_suite(suite):\n \"\"\n if verbose:\n  runner = unittest.TextTestRunner(sys.stdout, verbosity=2,\n  failfast=failfast)\n else:\n  runner = BasicTestRunner()\n  \n result = runner.run(suite)\n if not result.wasSuccessful():\n  if len(result.errors) == 1 and not result.failures:\n   err = result.errors[0][1]\n  elif len(result.failures) == 1 and not result.errors:\n   err = result.failures[0][1]\n  else:\n   err = \"multiple errors occurred\"\n   if not verbose: err += \"; run in verbose mode for details\"\n  raise TestFailed(err)\n  \n  \ndef run_unittest(*classes):\n \"\"\n valid_types = (unittest.TestSuite, unittest.TestCase)\n suite = unittest.TestSuite()\n for cls in classes:\n  if isinstance(cls, str):\n   if cls in sys.modules:\n    suite.addTest(unittest.findTestCases(sys.modules[cls]))\n   else:\n    raise ValueError(\"str arguments must be keys in sys.modules\")\n  elif isinstance(cls, valid_types):\n   suite.addTest(cls)\n  else:\n   suite.addTest(unittest.makeSuite(cls))\n def case_pred(test):\n  if match_tests is None:\n   return True\n  for name in test.id().split(\".\"):\n   if fnmatch.fnmatchcase(name, match_tests):\n    return True\n  return False\n _filter_suite(suite, case_pred)\n _run_suite(suite)\n \n \n \n \nHAVE_DOCSTRINGS = (check_impl_detail(cpython=False) or\nsys.platform == 'win32' or\nsysconfig.get_config_var('WITH_DOC_STRINGS'))\n\nrequires_docstrings = unittest.skipUnless(HAVE_DOCSTRINGS,\n\"test requires docstrings\")\n\n\n\n\n\ndef run_doctest(module, verbosity=None, optionflags=0):\n \"\"\n \n import doctest\n \n if verbosity is None:\n  verbosity = verbose\n else:\n  verbosity = None\n  \n f, t = doctest.testmod(module, verbose=verbosity, optionflags=optionflags)\n if f:\n  raise TestFailed(\"%d of %d doctests failed\" % (f, t))\n if verbose:\n  print('doctest (%s) ... %d tests with zero failures' %\n  (module.__name__, t))\n return f, t\n \n \n \n \n \ndef modules_setup():\n return sys.modules.copy(),\n \ndef modules_cleanup(oldmodules):\n\n\n\n encodings = [(k, v) for k, v in sys.modules.items()\n if k.startswith('encodings.')]\n sys.modules.clear()\n sys.modules.update(encodings)\n \n \n \n \n \n \n sys.modules.update(oldmodules)\n \n \n \n \n \n \n \n \n \n \n \n \ndef threading_setup():\n if _thread:\n  return _thread._count(), threading._dangling.copy()\n else:\n  return 1, ()\n  \ndef threading_cleanup(*original_values):\n if not _thread:\n  return\n _MAX_COUNT = 10\n for count in range(_MAX_COUNT):\n  values = _thread._count(), threading._dangling\n  if values == original_values:\n   break\n  time.sleep(0.1)\n  gc_collect()\n  \n  \ndef reap_threads(func):\n \"\"\n if not _thread:\n  return func\n  \n @functools.wraps(func)\n def decorator(*args):\n  key = threading_setup()\n  try:\n   return func(*args)\n  finally:\n   threading_cleanup(*key)\n return decorator\n \ndef reap_children():\n \"\"\n \n \n \n if hasattr(os, 'waitpid'):\n  any_process = -1\n  while True:\n   try:\n   \n    pid, status = os.waitpid(any_process, os.WNOHANG)\n    if pid == 0:\n     break\n   except:\n    break\n    \n@contextlib.contextmanager\ndef swap_attr(obj, attr, new_val):\n \"\"\n if hasattr(obj, attr):\n  real_val = getattr(obj, attr)\n  setattr(obj, attr, new_val)\n  try:\n   yield\n  finally:\n   setattr(obj, attr, real_val)\n else:\n  setattr(obj, attr, new_val)\n  try:\n   yield\n  finally:\n   delattr(obj, attr)\n   \n@contextlib.contextmanager\ndef swap_item(obj, item, new_val):\n \"\"\n if item in obj:\n  real_val = obj[item]\n  obj[item] = new_val\n  try:\n   yield\n  finally:\n   obj[item] = real_val\n else:\n  obj[item] = new_val\n  try:\n   yield\n  finally:\n   del obj[item]\n   \ndef strip_python_stderr(stderr):\n \"\"\n stderr = re.sub(br\"\\[\\d+ refs\\]\\r?\\n?\", b\"\", stderr).strip()\n return stderr\n \ndef args_from_interpreter_flags():\n \"\"\n return subprocess._args_from_interpreter_flags()\n \n \n \n \n \nclass TestHandler(logging.handlers.BufferingHandler):\n def __init__(self, matcher):\n \n \n \n \n \n  logging.handlers.BufferingHandler.__init__(self, 0)\n  self.matcher = matcher\n  \n def shouldFlush(self):\n  return False\n  \n def emit(self, record):\n  self.format(record)\n  self.buffer.append(record.__dict__)\n  \n def matches(self, **kwargs):\n  \"\"\n  result = False\n  for d in self.buffer:\n   if self.matcher.matches(d, **kwargs):\n    result = True\n    break\n  return result\n  \nclass Matcher(object):\n\n _partial_matches = ('msg', 'message')\n \n def matches(self, d, **kwargs):\n  \"\"\n  result = True\n  for k in kwargs:\n   v = kwargs[k]\n   dv = d.get(k)\n   if not self.match_value(k, dv, v):\n    result = False\n    break\n  return result\n  \n def match_value(self, k, dv, v):\n  \"\"\n  if type(v) != type(dv):\n   result = False\n  elif type(dv) is not str or k not in self._partial_matches:\n   result = (v == dv)\n  else:\n   result = dv.find(v) >= 0\n  return result\n  \n  \n_can_symlink = None\ndef can_symlink():\n global _can_symlink\n if _can_symlink is not None:\n  return _can_symlink\n symlink_path = TESTFN + \"can_symlink\"\n try:\n  os.symlink(TESTFN, symlink_path)\n  can = True\n except (OSError, NotImplementedError, AttributeError):\n  can = False\n else:\n  os.remove(symlink_path)\n _can_symlink = can\n return can\n \ndef skip_unless_symlink(test):\n \"\"\n ok = can_symlink()\n msg = \"Requires functional symlink implementation\"\n return test if ok else unittest.skip(msg)(test)\n \n_can_xattr = None\ndef can_xattr():\n global _can_xattr\n if _can_xattr is not None:\n  return _can_xattr\n if not hasattr(os, \"setxattr\"):\n  can = False\n else:\n  tmp_fp, tmp_name = tempfile.mkstemp()\n  try:\n   with open(TESTFN, \"wb\") as fp:\n    try:\n    \n    \n     os.setxattr(tmp_fp, b\"user.test\", b\"\")\n     os.setxattr(fp.fileno(), b\"user.test\", b\"\")\n     \n     kernel_version = platform.release()\n     m = re.match(\"2.6.(\\d{1,2})\", kernel_version)\n     can = m is None or int(m.group(1)) >= 39\n    except OSError:\n     can = False\n  finally:\n   unlink(TESTFN)\n   unlink(tmp_name)\n _can_xattr = can\n return can\n \ndef skip_unless_xattr(test):\n \"\"\n ok = can_xattr()\n msg = \"no non-broken extended attribute support\"\n return test if ok else unittest.skip(msg)(test)\n \n \nif sys.platform.startswith('win'):\n @contextlib.contextmanager\n def suppress_crash_popup():\n  \"\"\n  \n  \n  \n  import ctypes\n  k32 = ctypes.windll.kernel32\n  SEM_NOGPFAULTERRORBOX = 0x02\n  old_error_mode = k32.SetErrorMode(SEM_NOGPFAULTERRORBOX)\n  k32.SetErrorMode(old_error_mode | SEM_NOGPFAULTERRORBOX)\n  try:\n   yield\n  finally:\n   k32.SetErrorMode(old_error_mode)\nelse:\n\n @contextlib.contextmanager\n def suppress_crash_popup():\n  yield\n  \n  \ndef patch(test_instance, object_to_patch, attr_name, new_value):\n \"\"\n \n \n getattr(object_to_patch, attr_name)\n \n \n attr_is_local = False\n try:\n  old_value = object_to_patch.__dict__[attr_name]\n except (AttributeError, KeyError):\n  old_value = getattr(object_to_patch, attr_name, None)\n else:\n  attr_is_local = True\n  \n  \n def cleanup():\n  if attr_is_local:\n   setattr(object_to_patch, attr_name, old_value)\n  else:\n   delattr(object_to_patch, attr_name)\n   \n test_instance.addCleanup(cleanup)\n \n \n setattr(object_to_patch, attr_name, new_value)\n \n"], "unittest.test.test_discovery": ["import os\nimport re\nimport sys\n\nimport unittest\n\n\nclass TestableTestProgram(unittest.TestProgram):\n module = '__main__'\n exit = True\n defaultTest = failfast = catchbreak = buffer = None\n verbosity = 1\n progName = ''\n testRunner = testLoader = None\n \n def __init__(self):\n  pass\n  \n  \nclass TestDiscovery(unittest.TestCase):\n\n\n def test_get_name_from_path(self):\n  loader = unittest.TestLoader()\n  loader._top_level_dir = '/foo'\n  name = loader._get_name_from_path('/foo/bar/baz.py')\n  self.assertEqual(name, 'bar.baz')\n  \n  if not __debug__:\n  \n   return\n   \n  with self.assertRaises(AssertionError):\n   loader._get_name_from_path('/bar/baz.py')\n   \n def test_find_tests(self):\n  loader = unittest.TestLoader()\n  \n  original_listdir = os.listdir\n  def restore_listdir():\n   os.listdir = original_listdir\n  original_isfile = os.path.isfile\n  def restore_isfile():\n   os.path.isfile = original_isfile\n  original_isdir = os.path.isdir\n  def restore_isdir():\n   os.path.isdir = original_isdir\n   \n  path_lists = [['test1.py', 'test2.py', 'not_a_test.py', 'test_dir',\n  'test.foo', 'test-not-a-module.py', 'another_dir'],\n  ['test3.py', 'test4.py', ]]\n  os.listdir = lambda path: path_lists.pop(0)\n  self.addCleanup(restore_listdir)\n  \n  def isdir(path):\n   return path.endswith('dir')\n  os.path.isdir = isdir\n  self.addCleanup(restore_isdir)\n  \n  def isfile(path):\n  \n   return not path.endswith('dir') and not 'another_dir' in path\n  os.path.isfile = isfile\n  self.addCleanup(restore_isfile)\n  \n  loader._get_module_from_name = lambda path: path + ' module'\n  loader.loadTestsFromModule = lambda module: module + ' tests'\n  \n  top_level = os.path.abspath('/foo')\n  loader._top_level_dir = top_level\n  suite = list(loader._find_tests(top_level, 'test*.py'))\n  \n  expected = [name + ' module tests' for name in\n  ('test1', 'test2')]\n  expected.extend([('test_dir.%s' % name) + ' module tests' for name in\n  ('test3', 'test4')])\n  self.assertEqual(suite, expected)\n  \n def test_find_tests_with_package(self):\n  loader = unittest.TestLoader()\n  \n  original_listdir = os.listdir\n  def restore_listdir():\n   os.listdir = original_listdir\n  original_isfile = os.path.isfile\n  def restore_isfile():\n   os.path.isfile = original_isfile\n  original_isdir = os.path.isdir\n  def restore_isdir():\n   os.path.isdir = original_isdir\n   \n  directories = ['a_directory', 'test_directory', 'test_directory2']\n  path_lists = [directories, [], [], []]\n  os.listdir = lambda path: path_lists.pop(0)\n  self.addCleanup(restore_listdir)\n  \n  os.path.isdir = lambda path: True\n  self.addCleanup(restore_isdir)\n  \n  os.path.isfile = lambda path: os.path.basename(path) not in directories\n  self.addCleanup(restore_isfile)\n  \n  class Module(object):\n   paths = []\n   load_tests_args = []\n   \n   def __init__(self, path):\n    self.path = path\n    self.paths.append(path)\n    if os.path.basename(path) == 'test_directory':\n     def load_tests(loader, tests, pattern):\n      self.load_tests_args.append((loader, tests, pattern))\n      return 'load_tests'\n     self.load_tests = load_tests\n     \n   def __eq__(self, other):\n    return self.path == other.path\n    \n  loader._get_module_from_name = lambda name: Module(name)\n  def loadTestsFromModule(module, use_load_tests):\n   if use_load_tests:\n    raise self.failureException('use_load_tests should be False for packages')\n   return module.path + ' module tests'\n  loader.loadTestsFromModule = loadTestsFromModule\n  \n  loader._top_level_dir = '/foo'\n  \n  \n  suite = list(loader._find_tests('/foo', 'test*'))\n  \n  \n  \n  self.assertEqual(suite,\n  ['load_tests', 'test_directory2' + ' module tests'])\n  self.assertEqual(Module.paths, ['test_directory', 'test_directory2'])\n  \n  \n  self.assertEqual(Module.load_tests_args,\n  [(loader, 'test_directory' + ' module tests', 'test*')])\n  \n def test_discover(self):\n  loader = unittest.TestLoader()\n  \n  original_isfile = os.path.isfile\n  original_isdir = os.path.isdir\n  def restore_isfile():\n   os.path.isfile = original_isfile\n   \n  os.path.isfile = lambda path: False\n  self.addCleanup(restore_isfile)\n  \n  orig_sys_path = sys.path[:]\n  def restore_path():\n   sys.path[:] = orig_sys_path\n  self.addCleanup(restore_path)\n  \n  full_path = os.path.abspath(os.path.normpath('/foo'))\n  with self.assertRaises(ImportError):\n   loader.discover('/foo/bar', top_level_dir='/foo')\n   \n  self.assertEqual(loader._top_level_dir, full_path)\n  self.assertIn(full_path, sys.path)\n  \n  os.path.isfile = lambda path: True\n  os.path.isdir = lambda path: True\n  \n  def restore_isdir():\n   os.path.isdir = original_isdir\n  self.addCleanup(restore_isdir)\n  \n  _find_tests_args = []\n  def _find_tests(start_dir, pattern):\n   _find_tests_args.append((start_dir, pattern))\n   return ['tests']\n  loader._find_tests = _find_tests\n  loader.suiteClass = str\n  \n  suite = loader.discover('/foo/bar/baz', 'pattern', '/foo/bar')\n  \n  top_level_dir = os.path.abspath('/foo/bar')\n  start_dir = os.path.abspath('/foo/bar/baz')\n  self.assertEqual(suite, \"['tests']\")\n  self.assertEqual(loader._top_level_dir, top_level_dir)\n  self.assertEqual(_find_tests_args, [(start_dir, 'pattern')])\n  self.assertIn(top_level_dir, sys.path)\n  \n def test_discover_with_modules_that_fail_to_import(self):\n  loader = unittest.TestLoader()\n  \n  listdir = os.listdir\n  os.listdir = lambda _: ['test_this_does_not_exist.py']\n  isfile = os.path.isfile\n  os.path.isfile = lambda _: True\n  orig_sys_path = sys.path[:]\n  def restore():\n   os.path.isfile = isfile\n   os.listdir = listdir\n   sys.path[:] = orig_sys_path\n  self.addCleanup(restore)\n  \n  suite = loader.discover('.')\n  self.assertIn(os.getcwd(), sys.path)\n  self.assertEqual(suite.countTestCases(), 1)\n  test = list(list(suite)[0])[0] \n  \n  with self.assertRaises(ImportError):\n   test.test_this_does_not_exist()\n   \n def test_command_line_handling_parseArgs(self):\n  program = TestableTestProgram()\n  \n  args = []\n  def do_discovery(argv):\n   args.extend(argv)\n  program._do_discovery = do_discovery\n  program.parseArgs(['something', 'discover'])\n  self.assertEqual(args, [])\n  \n  program.parseArgs(['something', 'discover', 'foo', 'bar'])\n  self.assertEqual(args, ['foo', 'bar'])\n  \n def test_command_line_handling_discover_by_default(self):\n  program = TestableTestProgram()\n  program.module = None\n  \n  self.called = False\n  def do_discovery(argv):\n   self.called = True\n   self.assertEqual(argv, [])\n  program._do_discovery = do_discovery\n  program.parseArgs(['something'])\n  self.assertTrue(self.called)\n  \n def test_command_line_handling_discover_by_default_with_options(self):\n  program = TestableTestProgram()\n  program.module = None\n  \n  args = ['something', '-v', '-b', '-v', '-c', '-f']\n  self.called = False\n  def do_discovery(argv):\n   self.called = True\n   self.assertEqual(argv, args[1:])\n  program._do_discovery = do_discovery\n  program.parseArgs(args)\n  self.assertTrue(self.called)\n  \n  \n def test_command_line_handling_do_discovery_too_many_arguments(self):\n  class Stop(Exception):\n   pass\n  def usageExit():\n   raise Stop\n   \n  program = TestableTestProgram()\n  program.usageExit = usageExit\n  \n  with self.assertRaises(Stop):\n  \n   program._do_discovery(['one', 'two', 'three', 'four'])\n   \n   \n def test_command_line_handling_do_discovery_calls_loader(self):\n  program = TestableTestProgram()\n  \n  class Loader(object):\n   args = []\n   def discover(self, start_dir, pattern, top_level_dir):\n    self.args.append((start_dir, pattern, top_level_dir))\n    return 'tests'\n    \n  program._do_discovery(['-v'], Loader=Loader)\n  self.assertEqual(program.verbosity, 2)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('.', 'test*.py', None)])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['--verbose'], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('.', 'test*.py', None)])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery([], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('.', 'test*.py', None)])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['fish'], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('fish', 'test*.py', None)])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['fish', 'eggs'], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('fish', 'eggs', None)])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['fish', 'eggs', 'ham'], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('fish', 'eggs', 'ham')])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['-s', 'fish'], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('fish', 'test*.py', None)])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['-t', 'fish'], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('.', 'test*.py', 'fish')])\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['-p', 'fish'], Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('.', 'fish', None)])\n  self.assertFalse(program.failfast)\n  self.assertFalse(program.catchbreak)\n  \n  Loader.args = []\n  program = TestableTestProgram()\n  program._do_discovery(['-p', 'eggs', '-s', 'fish', '-v', '-f', '-c'],\n  Loader=Loader)\n  self.assertEqual(program.test, 'tests')\n  self.assertEqual(Loader.args, [('fish', 'eggs', None)])\n  self.assertEqual(program.verbosity, 2)\n  self.assertTrue(program.failfast)\n  self.assertTrue(program.catchbreak)\n  \n def test_detect_module_clash(self):\n  class Module(object):\n   __file__ = 'bar/foo.py'\n  sys.modules['foo'] = Module\n  full_path = os.path.abspath('foo')\n  original_listdir = os.listdir\n  original_isfile = os.path.isfile\n  original_isdir = os.path.isdir\n  \n  def cleanup():\n   os.listdir = original_listdir\n   os.path.isfile = original_isfile\n   os.path.isdir = original_isdir\n   del sys.modules['foo']\n   if full_path in sys.path:\n    sys.path.remove(full_path)\n  self.addCleanup(cleanup)\n  \n  def listdir(_):\n   return ['foo.py']\n  def isfile(_):\n   return True\n  def isdir(_):\n   return True\n  os.listdir = listdir\n  os.path.isfile = isfile\n  os.path.isdir = isdir\n  \n  loader = unittest.TestLoader()\n  \n  mod_dir = os.path.abspath('bar')\n  expected_dir = os.path.abspath('foo')\n  msg = re.escape(r\"'foo' module incorrectly imported from %r. Expected %r. \"\n  \"Is this module globally installed?\" % (mod_dir, expected_dir))\n  self.assertRaisesRegex(\n  ImportError, '^%s$' % msg, loader.discover,\n  start_dir='foo', pattern='foo.py'\n  )\n  self.assertEqual(sys.path[0], full_path)\n  \n  \n def test_discovery_from_dotted_path(self):\n  loader = unittest.TestLoader()\n  \n  tests = [self]\n  expectedPath = os.path.abspath(os.path.dirname(unittest.test.__file__))\n  \n  self.wasRun = False\n  def _find_tests(start_dir, pattern):\n   self.wasRun = True\n   self.assertEqual(start_dir, expectedPath)\n   return tests\n  loader._find_tests = _find_tests\n  suite = loader.discover('unittest.test')\n  self.assertTrue(self.wasRun)\n  self.assertEqual(suite._tests, tests)\n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.runner": ["\"\"\n\nimport sys\nimport time\nimport warnings\n\nfrom . import result\nfrom .signals import registerResult\n\n__unittest = True\n\n\nclass _WritelnDecorator(object):\n \"\"\n def __init__(self,stream):\n  self.stream = stream\n  \n def __getattr__(self, attr):\n  if attr in ('stream', '__getstate__'):\n   raise AttributeError(attr)\n  return getattr(self.stream,attr)\n  \n def writeln(self, arg=None):\n  if arg:\n   self.write(arg)\n  self.write('\\n') \n  \n  \nclass TextTestResult(result.TestResult):\n \"\"\n separator1 = '=' * 70\n separator2 = '-' * 70\n \n def __init__(self, stream, descriptions, verbosity):\n  super(TextTestResult, self).__init__(stream, descriptions, verbosity)\n  self.stream = stream\n  self.showAll = verbosity > 1\n  self.dots = verbosity == 1\n  self.descriptions = descriptions\n  \n def getDescription(self, test):\n  doc_first_line = test.shortDescription()\n  if self.descriptions and doc_first_line:\n   return '\\n'.join((str(test), doc_first_line))\n  else:\n   return str(test)\n   \n def startTest(self, test):\n  super(TextTestResult, self).startTest(test)\n  if self.showAll:\n   self.stream.write(self.getDescription(test))\n   self.stream.write(\" ... \")\n   self.stream.flush()\n   \n def addSuccess(self, test):\n  super(TextTestResult, self).addSuccess(test)\n  if self.showAll:\n   self.stream.writeln(\"ok\")\n  elif self.dots:\n   self.stream.write('.')\n   self.stream.flush()\n   \n def addError(self, test, err):\n  super(TextTestResult, self).addError(test, err)\n  if self.showAll:\n   self.stream.writeln(\"ERROR\")\n  elif self.dots:\n   self.stream.write('E')\n   self.stream.flush()\n   \n def addFailure(self, test, err):\n  super(TextTestResult, self).addFailure(test, err)\n  if self.showAll:\n   self.stream.writeln(\"FAIL\")\n  elif self.dots:\n   self.stream.write('F')\n   self.stream.flush()\n   \n def addSkip(self, test, reason):\n  super(TextTestResult, self).addSkip(test, reason)\n  if self.showAll:\n   self.stream.writeln(\"skipped {0!r}\".format(reason))\n  elif self.dots:\n   self.stream.write(\"s\")\n   self.stream.flush()\n   \n def addExpectedFailure(self, test, err):\n  super(TextTestResult, self).addExpectedFailure(test, err)\n  if self.showAll:\n   self.stream.writeln(\"expected failure\")\n  elif self.dots:\n   self.stream.write(\"x\")\n   self.stream.flush()\n   \n def addUnexpectedSuccess(self, test):\n  super(TextTestResult, self).addUnexpectedSuccess(test)\n  if self.showAll:\n   self.stream.writeln(\"unexpected success\")\n  elif self.dots:\n   self.stream.write(\"u\")\n   self.stream.flush()\n   \n def printErrors(self):\n  if self.dots or self.showAll:\n   self.stream.writeln()\n  self.printErrorList('ERROR', self.errors)\n  self.printErrorList('FAIL', self.failures)\n  \n def printErrorList(self, flavour, errors):\n  for test, err in errors:\n   self.stream.writeln(self.separator1)\n   self.stream.writeln(\"%s: %s\" % (flavour,self.getDescription(test)))\n   self.stream.writeln(self.separator2)\n   self.stream.writeln(\"%s\" % err)\n   \n   \nclass TextTestRunner(object):\n \"\"\n resultclass = TextTestResult\n \n def __init__(self, stream=None, descriptions=True, verbosity=1,\n failfast=False, buffer=False, resultclass=None, warnings=None):\n  if stream is None:\n   stream = sys.stderr\n  self.stream = _WritelnDecorator(stream)\n  self.descriptions = descriptions\n  self.verbosity = verbosity\n  self.failfast = failfast\n  self.buffer = buffer\n  self.warnings = warnings\n  if resultclass is not None:\n   self.resultclass = resultclass\n   \n def _makeResult(self):\n  return self.resultclass(self.stream, self.descriptions, self.verbosity)\n  \n def run(self, test):\n  \"\"\n  result = self._makeResult()\n  registerResult(result)\n  result.failfast = self.failfast\n  result.buffer = self.buffer\n  with warnings.catch_warnings():\n  \n   if self.warnings:\n   \n    warnings.simplefilter(self.warnings)\n    \n    \n    \n    \n    \n    if self.warnings in ['default', 'always']:\n     warnings.filterwarnings('module',\n     category=DeprecationWarning,\n     message='Please use assert\\w+ instead.')\n   startTime = time.time()\n   startTestRun = getattr(result, 'startTestRun', None)\n   if startTestRun is not None:\n    startTestRun()\n   try:\n    test(result)\n   finally:\n    stopTestRun = getattr(result, 'stopTestRun', None)\n    if stopTestRun is not None:\n     stopTestRun()\n   stopTime = time.time()\n  timeTaken = stopTime - startTime\n  result.printErrors()\n  if hasattr(result, 'separator2'):\n   self.stream.writeln(result.separator2)\n  run = result.testsRun\n  self.stream.writeln(\"Ran %d test%s in %.3fs\" %\n  (run, run != 1 and \"s\" or \"\", timeTaken))\n  self.stream.writeln()\n  \n  expectedFails = unexpectedSuccesses = skipped = 0\n  try:\n   results = map(len, (result.expectedFailures,\n   result.unexpectedSuccesses,\n   result.skipped))\n  except AttributeError:\n   pass\n  else:\n   expectedFails, unexpectedSuccesses, skipped = results\n   \n  infos = []\n  if not result.wasSuccessful():\n   self.stream.write(\"FAILED\")\n   failed, errored = len(result.failures), len(result.errors)\n   if failed:\n    infos.append(\"failures=%d\" % failed)\n   if errored:\n    infos.append(\"errors=%d\" % errored)\n  else:\n   self.stream.write(\"OK\")\n  if skipped:\n   infos.append(\"skipped=%d\" % skipped)\n  if expectedFails:\n   infos.append(\"expected failures=%d\" % expectedFails)\n  if unexpectedSuccesses:\n   infos.append(\"unexpected successes=%d\" % unexpectedSuccesses)\n  if infos:\n   self.stream.writeln(\" (%s)\" % (\", \".join(infos),))\n  else:\n   self.stream.write(\"\\n\")\n  return result\n"], "unittest.test.test_break": ["import gc\nimport io\nimport os\nimport sys\nimport signal\nimport weakref\n\nimport unittest\n\n\n@unittest.skipUnless(hasattr(os, 'kill'), \"Test requires os.kill\")\n@unittest.skipIf(sys.platform ==\"win32\", \"Test cannot run on Windows\")\n@unittest.skipIf(sys.platform == 'freebsd6', \"Test kills regrtest on freebsd6 \"\n\"if threads have been used\")\nclass TestBreak(unittest.TestCase):\n\n def setUp(self):\n  self._default_handler = signal.getsignal(signal.SIGINT)\n  \n def tearDown(self):\n  signal.signal(signal.SIGINT, self._default_handler)\n  unittest.signals._results = weakref.WeakKeyDictionary()\n  unittest.signals._interrupt_handler = None\n  \n  \n def testInstallHandler(self):\n  default_handler = signal.getsignal(signal.SIGINT)\n  unittest.installHandler()\n  self.assertNotEqual(signal.getsignal(signal.SIGINT), default_handler)\n  \n  try:\n   pid = os.getpid()\n   os.kill(pid, signal.SIGINT)\n  except KeyboardInterrupt:\n   self.fail(\"KeyboardInterrupt not handled\")\n   \n  self.assertTrue(unittest.signals._interrupt_handler.called)\n  \n def testRegisterResult(self):\n  result = unittest.TestResult()\n  unittest.registerResult(result)\n  \n  for ref in unittest.signals._results:\n   if ref is result:\n    break\n   elif ref is not result:\n    self.fail(\"odd object in result set\")\n  else:\n   self.fail(\"result not found\")\n   \n   \n def testInterruptCaught(self):\n  default_handler = signal.getsignal(signal.SIGINT)\n  \n  result = unittest.TestResult()\n  unittest.installHandler()\n  unittest.registerResult(result)\n  \n  self.assertNotEqual(signal.getsignal(signal.SIGINT), default_handler)\n  \n  def test(result):\n   pid = os.getpid()\n   os.kill(pid, signal.SIGINT)\n   result.breakCaught = True\n   self.assertTrue(result.shouldStop)\n   \n  try:\n   test(result)\n  except KeyboardInterrupt:\n   self.fail(\"KeyboardInterrupt not handled\")\n  self.assertTrue(result.breakCaught)\n  \n  \n def testSecondInterrupt(self):\n  result = unittest.TestResult()\n  unittest.installHandler()\n  unittest.registerResult(result)\n  \n  def test(result):\n   pid = os.getpid()\n   os.kill(pid, signal.SIGINT)\n   result.breakCaught = True\n   self.assertTrue(result.shouldStop)\n   os.kill(pid, signal.SIGINT)\n   self.fail(\"Second KeyboardInterrupt not raised\")\n   \n  try:\n   test(result)\n  except KeyboardInterrupt:\n   pass\n  else:\n   self.fail(\"Second KeyboardInterrupt not raised\")\n  self.assertTrue(result.breakCaught)\n  \n  \n def testTwoResults(self):\n  unittest.installHandler()\n  \n  result = unittest.TestResult()\n  unittest.registerResult(result)\n  new_handler = signal.getsignal(signal.SIGINT)\n  \n  result2 = unittest.TestResult()\n  unittest.registerResult(result2)\n  self.assertEqual(signal.getsignal(signal.SIGINT), new_handler)\n  \n  result3 = unittest.TestResult()\n  \n  def test(result):\n   pid = os.getpid()\n   os.kill(pid, signal.SIGINT)\n   \n  try:\n   test(result)\n  except KeyboardInterrupt:\n   self.fail(\"KeyboardInterrupt not handled\")\n   \n  self.assertTrue(result.shouldStop)\n  self.assertTrue(result2.shouldStop)\n  self.assertFalse(result3.shouldStop)\n  \n  \n def testHandlerReplacedButCalled(self):\n \n \n \n  unittest.installHandler()\n  \n  handler = signal.getsignal(signal.SIGINT)\n  def new_handler(frame, signum):\n   handler(frame, signum)\n  signal.signal(signal.SIGINT, new_handler)\n  \n  try:\n   pid = os.getpid()\n   os.kill(pid, signal.SIGINT)\n  except KeyboardInterrupt:\n   pass\n  else:\n   self.fail(\"replaced but delegated handler doesn't raise interrupt\")\n   \n def testRunner(self):\n \n \n  runner = unittest.TextTestRunner(stream=io.StringIO())\n  \n  result = runner.run(unittest.TestSuite())\n  self.assertIn(result, unittest.signals._results)\n  \n def testWeakReferences(self):\n \n  result = unittest.TestResult()\n  unittest.registerResult(result)\n  \n  ref = weakref.ref(result)\n  del result\n  \n  \n  gc.collect();gc.collect()\n  self.assertIsNone(ref())\n  \n  \n def testRemoveResult(self):\n  result = unittest.TestResult()\n  unittest.registerResult(result)\n  \n  unittest.installHandler()\n  self.assertTrue(unittest.removeResult(result))\n  \n  \n  self.assertFalse(unittest.removeResult(unittest.TestResult()))\n  \n  try:\n   pid = os.getpid()\n   os.kill(pid, signal.SIGINT)\n  except KeyboardInterrupt:\n   pass\n   \n  self.assertFalse(result.shouldStop)\n  \n def testMainInstallsHandler(self):\n  failfast = object()\n  test = object()\n  verbosity = object()\n  result = object()\n  default_handler = signal.getsignal(signal.SIGINT)\n  \n  class FakeRunner(object):\n   initArgs = []\n   runArgs = []\n   def __init__(self, *args, **kwargs):\n    self.initArgs.append((args, kwargs))\n   def run(self, test):\n    self.runArgs.append(test)\n    return result\n    \n  class Program(unittest.TestProgram):\n   def __init__(self, catchbreak):\n    self.exit = False\n    self.verbosity = verbosity\n    self.failfast = failfast\n    self.catchbreak = catchbreak\n    self.testRunner = FakeRunner\n    self.test = test\n    self.result = None\n    \n  p = Program(False)\n  p.runTests()\n  \n  self.assertEqual(FakeRunner.initArgs, [((), {'buffer': None,\n  'verbosity': verbosity,\n  'failfast': failfast,\n  'warnings': None})])\n  self.assertEqual(FakeRunner.runArgs, [test])\n  self.assertEqual(p.result, result)\n  \n  self.assertEqual(signal.getsignal(signal.SIGINT), default_handler)\n  \n  FakeRunner.initArgs = []\n  FakeRunner.runArgs = []\n  p = Program(True)\n  p.runTests()\n  \n  self.assertEqual(FakeRunner.initArgs, [((), {'buffer': None,\n  'verbosity': verbosity,\n  'failfast': failfast,\n  'warnings': None})])\n  self.assertEqual(FakeRunner.runArgs, [test])\n  self.assertEqual(p.result, result)\n  \n  self.assertNotEqual(signal.getsignal(signal.SIGINT), default_handler)\n  \n def testRemoveHandler(self):\n  default_handler = signal.getsignal(signal.SIGINT)\n  unittest.installHandler()\n  unittest.removeHandler()\n  self.assertEqual(signal.getsignal(signal.SIGINT), default_handler)\n  \n  \n  unittest.removeHandler()\n  self.assertEqual(signal.getsignal(signal.SIGINT), default_handler)\n  \n def testRemoveHandlerAsDecorator(self):\n  default_handler = signal.getsignal(signal.SIGINT)\n  unittest.installHandler()\n  \n  @unittest.removeHandler\n  def test():\n   self.assertEqual(signal.getsignal(signal.SIGINT), default_handler)\n   \n  test()\n  self.assertNotEqual(signal.getsignal(signal.SIGINT), default_handler)\n"], "unittest.test._test_warnings": ["\n\n\"\"\n\nimport sys\nimport unittest\nimport warnings\n\ndef warnfun():\n warnings.warn('rw', RuntimeWarning)\n \nclass TestWarnings(unittest.TestCase):\n\n\n def test_assert(self):\n  self.assertEquals(2+2, 4)\n  self.assertEquals(2*2, 4)\n  self.assertEquals(2**2, 4)\n  \n def test_fail(self):\n  self.failUnless(1)\n  self.failUnless(True)\n  \n def test_other_unittest(self):\n  self.assertAlmostEqual(2+2, 4)\n  self.assertNotAlmostEqual(4+4, 2)\n  \n  \n def test_deprecation(self):\n  warnings.warn('dw', DeprecationWarning)\n  warnings.warn('dw', DeprecationWarning)\n  warnings.warn('dw', DeprecationWarning)\n  \n def test_import(self):\n  warnings.warn('iw', ImportWarning)\n  warnings.warn('iw', ImportWarning)\n  warnings.warn('iw', ImportWarning)\n  \n  \n def test_warning(self):\n  warnings.warn('uw')\n  warnings.warn('uw')\n  warnings.warn('uw')\n  \n  \n  \n def test_function(self):\n \n  warnfun()\n  warnfun()\n  warnfun()\n  \n  \n  \nif __name__ == '__main__':\n with warnings.catch_warnings(record=True) as ws:\n \n  if len(sys.argv) == 2:\n   unittest.main(exit=False, warnings=sys.argv.pop())\n  else:\n   unittest.main(exit=False)\n   \n   \n for w in ws:\n  print(w.message)\n"], "unittest.result": ["\"\"\n\nimport io\nimport sys\nimport traceback\n\nfrom . import util\nfrom functools import wraps\n\n__unittest = True\n\ndef failfast(method):\n @wraps(method)\n def inner(self, *args, **kw):\n  if getattr(self, 'failfast', False):\n   self.stop()\n  return method(self, *args, **kw)\n return inner\n \nSTDOUT_LINE = '\\nStdout:\\n%s'\nSTDERR_LINE = '\\nStderr:\\n%s'\n\n\nclass TestResult(object):\n \"\"\n _previousTestClass = None\n _testRunEntered = False\n _moduleSetUpFailed = False\n def __init__(self, stream=None, descriptions=None, verbosity=None):\n  self.failfast = False\n  self.failures = []\n  self.errors = []\n  self.testsRun = 0\n  self.skipped = []\n  self.expectedFailures = []\n  self.unexpectedSuccesses = []\n  self.shouldStop = False\n  self.buffer = False\n  self._stdout_buffer = None\n  self._stderr_buffer = None\n  self._original_stdout = sys.stdout\n  self._original_stderr = sys.stderr\n  self._mirrorOutput = False\n  \n def printErrors(self):\n  \"\"\n  \n  pass\n  \n def startTest(self, test):\n  \"\"\n  self.testsRun += 1\n  self._mirrorOutput = False\n  self._setupStdout()\n  \n def _setupStdout(self):\n  if self.buffer:\n   if self._stderr_buffer is None:\n    self._stderr_buffer = io.StringIO()\n    self._stdout_buffer = io.StringIO()\n   sys.stdout = self._stdout_buffer\n   sys.stderr = self._stderr_buffer\n   \n def startTestRun(self):\n  \"\"\n  \n def stopTest(self, test):\n  \"\"\n  self._restoreStdout()\n  self._mirrorOutput = False\n  \n def _restoreStdout(self):\n  if self.buffer:\n   if self._mirrorOutput:\n    output = sys.stdout.getvalue()\n    error = sys.stderr.getvalue()\n    if output:\n     if not output.endswith('\\n'):\n      output += '\\n'\n     self._original_stdout.write(STDOUT_LINE % output)\n    if error:\n     if not error.endswith('\\n'):\n      error += '\\n'\n     self._original_stderr.write(STDERR_LINE % error)\n     \n   sys.stdout = self._original_stdout\n   sys.stderr = self._original_stderr\n   self._stdout_buffer.seek(0)\n   self._stdout_buffer.truncate()\n   self._stderr_buffer.seek(0)\n   self._stderr_buffer.truncate()\n   \n def stopTestRun(self):\n  \"\"\n  \n @failfast\n def addError(self, test, err):\n  \"\"\n  self.errors.append((test, self._exc_info_to_string(err, test)))\n  self._mirrorOutput = True\n  \n @failfast\n def addFailure(self, test, err):\n  \"\"\n  self.failures.append((test, self._exc_info_to_string(err, test)))\n  self._mirrorOutput = True\n  \n def addSuccess(self, test):\n  \"\"\n  pass\n  \n def addSkip(self, test, reason):\n  \"\"\n  self.skipped.append((test, reason))\n  \n def addExpectedFailure(self, test, err):\n  \"\"\n  self.expectedFailures.append(\n  (test, self._exc_info_to_string(err, test)))\n  \n @failfast\n def addUnexpectedSuccess(self, test):\n  \"\"\n  self.unexpectedSuccesses.append(test)\n  \n def wasSuccessful(self):\n  \"\"\n  return len(self.failures) == len(self.errors) == 0\n  \n def stop(self):\n  \"\"\n  self.shouldStop = True\n  \n def _exc_info_to_string(self, err, test):\n  \"\"\n  exctype, value, tb = err\n  \n  while tb and self._is_relevant_tb_level(tb):\n   tb = tb.tb_next\n   \n  if exctype is test.failureException:\n  \n   length = self._count_relevant_tb_levels(tb)\n   msgLines = traceback.format_exception(exctype, value, tb, length)\n  else:\n   msgLines = traceback.format_exception(exctype, value, tb)\n   \n  if self.buffer:\n   output = sys.stdout.getvalue()\n   error = sys.stderr.getvalue()\n   if output:\n    if not output.endswith('\\n'):\n     output += '\\n'\n    msgLines.append(STDOUT_LINE % output)\n   if error:\n    if not error.endswith('\\n'):\n     error += '\\n'\n    msgLines.append(STDERR_LINE % error)\n  return ''.join(msgLines)\n  \n  \n def _is_relevant_tb_level(self, tb):\n \n \n  return True \n  \n def _count_relevant_tb_levels(self, tb):\n  length = 0\n  while tb and not self._is_relevant_tb_level(tb):\n   length += 1\n   tb = tb.tb_next\n  return length\n  \n def __repr__(self):\n  return (\"<%s run=%i errors=%i failures=%i>\" %\n  (util.strclass(self.__class__), self.testsRun, len(self.errors),\n  len(self.failures)))\n"], "unittest.test": ["import os\nimport sys\nimport unittest\n\n\nhere = os.path.dirname(__file__)\nloader = unittest.defaultTestLoader\n\ndef suite():\n suite = unittest.TestSuite()\n for fn in os.listdir(here):\n  if fn.startswith(\"test\") and fn.endswith(\".py\"):\n   modname = \"unittest.test.\" + fn[:-3]\n   __import__(modname)\n   module = sys.modules[modname]\n   suite.addTest(loader.loadTestsFromModule(module))\n suite.addTest(loader.loadTestsFromName('unittest.test.testmock'))\n return suite\n \n \nif __name__ == \"__main__\":\n unittest.main(defaultTest=\"suite\")\n", 1], "test": ["\n", 1], "unittest.main": ["\"\"\n\nimport sys\nimport optparse\nimport os\n\nfrom . import loader, runner\nfrom .signals import installHandler\n\n__unittest = True\n\nFAILFAST = \"  -f, --failfast   Stop on first failure\\n\"\nCATCHBREAK = \"  -c, --catch      Catch control-C and display results\\n\"\nBUFFEROUTPUT = \"  -b, --buffer     Buffer stdout and stderr during test runs\\n\"\n\nUSAGE_AS_MAIN = \"\"\"\\\nUsage: %(progName)s [options] [tests]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n%(failfast)s%(catchbreak)s%(buffer)s\nExamples:\n  %(progName)s test_module               - run tests from test_module\n  %(progName)s module.TestClass          - run tests from module.TestClass\n  %(progName)s module.Class.test_method  - run specified test method\n\n[tests] can be a list of any number of test modules, classes and test\nmethods.\n\nAlternative Usage: %(progName)s discover [options]\n\nOptions:\n  -v, --verbose    Verbose output\n%(failfast)s%(catchbreak)s%(buffer)s  -s directory     Directory to start discovery ('.' default)\n  -p pattern       Pattern to match test files ('test*.py' default)\n  -t directory     Top level directory of project (default to\n                   start directory)\n\nFor test discovery all test modules must be importable from the top\nlevel directory of the project.\n\"\"\"\n\nUSAGE_FROM_MODULE = \"\"\"\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n%(failfast)s%(catchbreak)s%(buffer)s\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite 'MyTestSuite'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all 'test*' test methods\n                                               in MyTestCase\n\"\"\"\n\ndef _convert_name(name):\n\n\n\n\n if os.path.isfile(name) and name.lower().endswith('.py'):\n  if os.path.isabs(name):\n   rel_path = os.path.relpath(name, os.getcwd())\n   if os.path.isabs(rel_path) or rel_path.startswith(os.pardir):\n    return name\n   name = rel_path\n   \n   \n  return name[:-3].replace('\\\\', '.').replace('/', '.')\n return name\n \ndef _convert_names(names):\n return [_convert_name(name) for name in names]\n \n \nclass TestProgram(object):\n \"\"\n USAGE = USAGE_FROM_MODULE\n \n \n failfast = catchbreak = buffer = progName = warnings = None\n \n def __init__(self, module='__main__', defaultTest=None, argv=None,\n testRunner=None, testLoader=loader.defaultTestLoader,\n exit=True, verbosity=1, failfast=None, catchbreak=None,\n buffer=None, warnings=None):\n  if isinstance(module, str):\n   self.module = __import__(module)\n   for part in module.split('.')[1:]:\n    self.module = getattr(self.module, part)\n  else:\n   self.module = module\n  if argv is None:\n   argv = sys.argv\n   \n  self.exit = exit\n  self.failfast = failfast\n  self.catchbreak = catchbreak\n  self.verbosity = verbosity\n  self.buffer = buffer\n  if warnings is None and not sys.warnoptions:\n  \n  \n  \n   self.warnings = 'default'\n  else:\n  \n  \n  \n  \n  \n   self.warnings = warnings\n  self.defaultTest = defaultTest\n  self.testRunner = testRunner\n  self.testLoader = testLoader\n  self.progName = os.path.basename(argv[0])\n  self.parseArgs(argv)\n  self.runTests()\n  \n def usageExit(self, msg=None):\n  if msg:\n   print(msg)\n  usage = {'progName': self.progName, 'catchbreak': '', 'failfast': '',\n  'buffer': ''}\n  if self.failfast != False:\n   usage['failfast'] = FAILFAST\n  if self.catchbreak != False:\n   usage['catchbreak'] = CATCHBREAK\n  if self.buffer != False:\n   usage['buffer'] = BUFFEROUTPUT\n  print(self.USAGE % usage)\n  sys.exit(2)\n  \n def parseArgs(self, argv):\n  if ((len(argv) > 1 and argv[1].lower() == 'discover') or\n  (len(argv) == 1 and self.module is None)):\n   self._do_discovery(argv[2:])\n   return\n   \n  parser = self._getOptParser()\n  options, args = parser.parse_args(argv[1:])\n  self._setAttributesFromOptions(options)\n  \n  if len(args) == 0 and self.module is None:\n  \n  \n  \n   self._do_discovery(argv[1:])\n   return\n   \n  if len(args) == 0 and self.defaultTest is None:\n  \n   self.testNames = None\n  elif len(args) > 0:\n   self.testNames = _convert_names(args)\n   if __name__ == '__main__':\n   \n    self.module = None\n  else:\n   self.testNames = (self.defaultTest,)\n  self.createTests()\n  \n def createTests(self):\n  if self.testNames is None:\n   self.test = self.testLoader.loadTestsFromModule(self.module)\n  else:\n   self.test = self.testLoader.loadTestsFromNames(self.testNames,\n   self.module)\n   \n def _getOptParser(self):\n  import optparse\n  parser = optparse.OptionParser()\n  parser.prog = self.progName\n  parser.add_option('-v', '--verbose', dest='verbose', default=False,\n  help='Verbose output', action='store_true')\n  parser.add_option('-q', '--quiet', dest='quiet', default=False,\n  help='Quiet output', action='store_true')\n  \n  if self.failfast != False:\n   parser.add_option('-f', '--failfast', dest='failfast', default=False,\n   help='Stop on first fail or error',\n   action='store_true')\n  if self.catchbreak != False:\n   parser.add_option('-c', '--catch', dest='catchbreak', default=False,\n   help='Catch ctrl-C and display results so far',\n   action='store_true')\n  if self.buffer != False:\n   parser.add_option('-b', '--buffer', dest='buffer', default=False,\n   help='Buffer stdout and stderr during tests',\n   action='store_true')\n  return parser\n  \n def _setAttributesFromOptions(self, options):\n \n \n  if self.failfast is None:\n   self.failfast = options.failfast\n  if self.catchbreak is None:\n   self.catchbreak = options.catchbreak\n  if self.buffer is None:\n   self.buffer = options.buffer\n   \n  if options.verbose:\n   self.verbosity = 2\n  elif options.quiet:\n   self.verbosity = 0\n   \n def _addDiscoveryOptions(self, parser):\n  parser.add_option('-s', '--start-directory', dest='start', default='.',\n  help=\"Directory to start discovery ('.' default)\")\n  parser.add_option('-p', '--pattern', dest='pattern', default='test*.py',\n  help=\"Pattern to match tests ('test*.py' default)\")\n  parser.add_option('-t', '--top-level-directory', dest='top', default=None,\n  help='Top level directory of project (defaults to start directory)')\n  \n def _do_discovery(self, argv, Loader=None):\n  if Loader is None:\n   Loader = lambda: self.testLoader\n   \n   \n  self.progName = '%s discover' % self.progName\n  parser = self._getOptParser()\n  self._addDiscoveryOptions(parser)\n  \n  options, args = parser.parse_args(argv)\n  if len(args) > 3:\n   self.usageExit()\n   \n  for name, value in zip(('start', 'pattern', 'top'), args):\n   setattr(options, name, value)\n   \n  self._setAttributesFromOptions(options)\n  \n  start_dir = options.start\n  pattern = options.pattern\n  top_level_dir = options.top\n  \n  loader = Loader()\n  self.test = loader.discover(start_dir, pattern, top_level_dir)\n  \n def runTests(self):\n  if self.catchbreak:\n   installHandler()\n  if self.testRunner is None:\n   self.testRunner = runner.TextTestRunner\n  if isinstance(self.testRunner, type):\n   try:\n    testRunner = self.testRunner(verbosity=self.verbosity,\n    failfast=self.failfast,\n    buffer=self.buffer,\n    warnings=self.warnings)\n   except TypeError:\n   \n    testRunner = self.testRunner()\n  else:\n  \n   testRunner = self.testRunner\n  self.result = testRunner.run(self.test)\n  if self.exit:\n   sys.exit(not self.result.wasSuccessful())\n   \nmain = TestProgram\n"], "test.regrtest": ["\n\n\"\"\n\n\nimport importlib\n\nimport builtins\nimport faulthandler\nimport getopt\nimport io\nimport json\nimport logging\nimport os\nimport platform\nimport random\nimport re\nimport shutil\nimport signal\nimport sys\nimport sysconfig\nimport tempfile\nimport time\nimport traceback\nimport unittest\nimport warnings\nfrom inspect import isabstract\n\ntry:\n import threading\nexcept ImportError:\n threading = None\ntry:\n import multiprocessing.process\nexcept ImportError:\n multiprocessing = None\n \n \n \n \n \n \n \n \n \n \n \n \nfor module in sys.modules.values():\n if hasattr(module, '__path__'):\n  module.__path__ = [os.path.abspath(path) for path in module.__path__]\n if hasattr(module, '__file__'):\n  module.__file__ = os.path.abspath(module.__file__)\n  \n  \n  \n  \n  \n  \n  \n  \nif sys.platform == 'darwin':\n try:\n  import resource\n except ImportError:\n  pass\n else:\n  soft, hard = resource.getrlimit(resource.RLIMIT_STACK)\n  newsoft = min(hard, max(soft, 1024*2048))\n  resource.setrlimit(resource.RLIMIT_STACK, (newsoft, hard))\n  \n  \nPASSED = 1\nFAILED = 0\nENV_CHANGED = -1\nSKIPPED = -2\nRESOURCE_DENIED = -3\nINTERRUPTED = -4\nCHILD_ERROR = -5 \n\nfrom test import support\n\nRESOURCE_NAMES = ('audio', 'curses', 'largefile', 'network',\n'decimal', 'cpu', 'subprocess', 'urlfetch', 'gui')\n\nTEMPDIR = os.path.abspath(tempfile.gettempdir())\n\ndef usage(msg):\n print(msg, file=sys.stderr)\n print(\"Use --help for usage\", file=sys.stderr)\n sys.exit(2)\n \n \ndef main(tests=None, testdir=None, verbose=0, quiet=False,\nexclude=False, single=0, randomize=False, fromfile=None,\nfindleaks=False, use_resources=None, trace=False, coverdir='coverage',\nrunleaks=False, huntrleaks=False, verbose2=False, print_slow=False,\nrandom_seed=None, use_mp=None, verbose3=False, forever=False,\nheader=False, failfast=False, match_tests=None):\n \"\"\n \n \n faulthandler.enable(all_threads=True)\n \n \n signals = []\n if hasattr(signal, 'SIGALRM'):\n  signals.append(signal.SIGALRM)\n if hasattr(signal, 'SIGUSR1'):\n  signals.append(signal.SIGUSR1)\n for signum in signals:\n  faulthandler.register(signum, chain=True)\n  \n replace_stdout()\n \n support.record_original_stdout(sys.stdout)\n try:\n  opts, args = getopt.getopt(sys.argv[1:], 'hvqxsoS:rf:lu:t:TD:NLR:FdwWM:nj:Gm:',\n  ['help', 'verbose', 'verbose2', 'verbose3', 'quiet',\n  'exclude', 'single', 'slow', 'randomize', 'fromfile=', 'findleaks',\n  'use=', 'threshold=', 'coverdir=', 'nocoverdir',\n  'runleaks', 'huntrleaks=', 'memlimit=', 'randseed=',\n  'multiprocess=', 'coverage', 'slaveargs=', 'forever', 'debug',\n  'start=', 'nowindows', 'header', 'testdir=', 'timeout=', 'wait',\n  'failfast', 'match=', 'next='])\n except getopt.error as msg:\n  usage(msg)\n  \n  \n if random_seed is None:\n  random_seed = random.randrange(10000000)\n if use_resources is None:\n  use_resources = []\n debug = False\n start = None\n timeout = None\n for o, a in opts:\n  if o in ('-h', '--help'):\n   print(__doc__)\n   return\n  elif o in ('-v', '--verbose'):\n   verbose += 1\n  elif o in ('-w', '--verbose2'):\n   verbose2 = True\n  elif o in ('-d', '--debug'):\n   debug = True\n  elif o in ('-W', '--verbose3'):\n   verbose3 = True\n  elif o in ('-G', '--failfast'):\n   failfast = True\n  elif o in ('-q', '--quiet'):\n   quiet = True;\n   verbose = 0\n  elif o in ('-x', '--exclude'):\n   exclude = True\n  elif o in ('-S', '--start'):\n   start = a\n  elif o in ('-s', '--single'):\n   single = 1\n  elif o == '--next':\n   single = int(a)\n  elif o in ('-o', '--slow'):\n   print_slow = True\n  elif o in ('-r', '--randomize'):\n   randomize = True\n  elif o == '--randseed':\n   random_seed = int(a)\n  elif o in ('-f', '--fromfile'):\n   fromfile = a\n  elif o in ('-m', '--match'):\n   match_tests = a\n  elif o in ('-l', '--findleaks'):\n   findleaks = True\n  elif o in ('-L', '--runleaks'):\n   runleaks = True\n  elif o in ('-t', '--threshold'):\n   import gc\n   gc.set_threshold(int(a))\n  elif o in ('-T', '--coverage'):\n   trace = True\n  elif o in ('-D', '--coverdir'):\n  \n  \n   coverdir = os.path.join(support.SAVEDCWD, a)\n  elif o in ('-N', '--nocoverdir'):\n   coverdir = None\n  elif o in ('-R', '--huntrleaks'):\n   huntrleaks = a.split(':')\n   if len(huntrleaks) not in (2, 3):\n    print(a, huntrleaks)\n    usage('-R takes 2 or 3 colon-separated arguments')\n   if not huntrleaks[0]:\n    huntrleaks[0] = 5\n   else:\n    huntrleaks[0] = int(huntrleaks[0])\n   if not huntrleaks[1]:\n    huntrleaks[1] = 4\n   else:\n    huntrleaks[1] = int(huntrleaks[1])\n   if len(huntrleaks) == 2 or not huntrleaks[2]:\n    huntrleaks[2:] = [\"reflog.txt\"]\n    \n    \n   warm_caches()\n  elif o in ('-M', '--memlimit'):\n   support.set_memlimit(a)\n  elif o in ('-u', '--use'):\n   u = [x.lower() for x in a.split(',')]\n   for r in u:\n    if r == 'all':\n     use_resources[:] = RESOURCE_NAMES\n     continue\n    if r == 'none':\n     del use_resources[:]\n     continue\n    remove = False\n    if r[0] == '-':\n     remove = True\n     r = r[1:]\n    if r not in RESOURCE_NAMES:\n     usage('Invalid -u/--use option: ' + a)\n    if remove:\n     if r in use_resources:\n      use_resources.remove(r)\n    elif r not in use_resources:\n     use_resources.append(r)\n  elif o in ('-n', '--nowindows'):\n   import msvcrt\n   msvcrt.SetErrorMode(msvcrt.SEM_FAILCRITICALERRORS|\n   msvcrt.SEM_NOALIGNMENTFAULTEXCEPT|\n   msvcrt.SEM_NOGPFAULTERRORBOX|\n   msvcrt.SEM_NOOPENFILEERRORBOX)\n   try:\n    msvcrt.CrtSetReportMode\n   except AttributeError:\n   \n    pass\n   else:\n    for m in [msvcrt.CRT_WARN, msvcrt.CRT_ERROR, msvcrt.CRT_ASSERT]:\n     msvcrt.CrtSetReportMode(m, msvcrt.CRTDBG_MODE_FILE)\n     msvcrt.CrtSetReportFile(m, msvcrt.CRTDBG_FILE_STDERR)\n  elif o in ('-F', '--forever'):\n   forever = True\n  elif o in ('-j', '--multiprocess'):\n   use_mp = int(a)\n   if use_mp <= 0:\n    try:\n     import multiprocessing\n     \n     use_mp = 2 + multiprocessing.cpu_count()\n    except (ImportError, NotImplementedError):\n     use_mp = 3\n   if use_mp == 1:\n    use_mp = None\n  elif o == '--header':\n   header = True\n  elif o == '--slaveargs':\n   args, kwargs = json.loads(a)\n   try:\n    result = runtest(*args, **kwargs)\n   except KeyboardInterrupt:\n    result = INTERRUPTED, ''\n   except BaseException as e:\n    traceback.print_exc()\n    result = CHILD_ERROR, str(e)\n   sys.stdout.flush()\n   print() \n   print(json.dumps(result))\n   sys.exit(0)\n  elif o == '--testdir':\n  \n  \n   testdir = os.path.join(support.SAVEDCWD, a)\n  elif o == '--timeout':\n   if hasattr(faulthandler, 'dump_tracebacks_later'):\n    timeout = float(a)\n    if timeout <= 0:\n     timeout = None\n   else:\n    print(\"Warning: The timeout option requires \"\n    \"faulthandler.dump_tracebacks_later\")\n    timeout = None\n  elif o == '--wait':\n   input(\"Press any key to continue...\")\n  else:\n   print((\"No handler for option {}.  Please report this as a bug \"\n   \"at http://bugs.python.org.\").format(o), file=sys.stderr)\n   sys.exit(1)\n if single and fromfile:\n  usage(\"-s and -f don't go together!\")\n if use_mp and trace:\n  usage(\"-T and -j don't go together!\")\n if use_mp and findleaks:\n  usage(\"-l and -j don't go together!\")\n if use_mp and support.max_memuse:\n  usage(\"-M and -j don't go together!\")\n if failfast and not (verbose or verbose3):\n  usage(\"-G/--failfast needs either -v or -W\")\n  \n good = []\n bad = []\n skipped = []\n resource_denieds = []\n environment_changed = []\n interrupted = False\n \n if findleaks:\n  try:\n   import gc\n  except ImportError:\n   print('No GC available, disabling findleaks.')\n   findleaks = False\n  else:\n  \n  \n  \n  \n   found_garbage = []\n   \n if single:\n  filename = os.path.join(TEMPDIR, 'pynexttest')\n  try:\n   fp = open(filename, 'r')\n   next_test = fp.read().strip()\n   tests = [next_test]\n   fp.close()\n  except IOError:\n   pass\n   \n if fromfile:\n  tests = []\n  fp = open(os.path.join(support.SAVEDCWD, fromfile))\n  count_pat = re.compile(r'\\[\\s*\\d+/\\s*\\d+\\]')\n  for line in fp:\n   line = count_pat.sub('', line)\n   guts = line.split() \n   if guts and not guts[0].startswith('#'):\n    tests.extend(guts)\n  fp.close()\n  \n  \n removepy(args)\n removepy(tests)\n \n stdtests = STDTESTS[:]\n nottests = NOTTESTS.copy()\n if exclude:\n  for arg in args:\n   if arg in stdtests:\n    stdtests.remove(arg)\n   nottests.add(arg)\n  args = []\n  \n  \n if verbose or header or not (quiet or single != 1 or tests or args):\n \n  print(\"==\", platform.python_implementation(), *sys.version.split())\n  print(\"==  \", platform.platform(aliased=True),\n  \"%s-endian\" % sys.byteorder)\n  print(\"==  \", os.getcwd())\n  print(\"Testing with flags:\", sys.flags)\n  \n  \n  \n if testdir:\n  alltests = findtests(testdir, list(), set())\n else:\n  alltests = findtests(testdir, stdtests, nottests)\n  \n selected = tests or args or alltests\n if single:\n  first_selected = selected[0]\n  index_selected = alltests.index(first_selected)\n  if index_selected + single > len(alltests):\n   single = len(alltests) - index_selected\n  selected = alltests[index_selected:index_selected+single]\n  try:\n   next_single_test = alltests[index_selected+single]\n  except IndexError:\n   next_single_test = None\n   \n if start:\n  try:\n   del selected[:selected.index(start)]\n  except ValueError:\n   print(\"Couldn't find starting test (%s), using all tests\" % start)\n if randomize:\n  random.seed(random_seed)\n  print(\"Using random seed\", random_seed)\n  random.shuffle(selected)\n if trace:\n  import trace, tempfile\n  tracer = trace.Trace(ignoredirs=[sys.base_prefix, sys.base_exec_prefix,\n  tempfile.gettempdir()],\n  trace=False, count=True)\n  \n test_times = []\n support.verbose = verbose \n support.use_resources = use_resources\n save_modules = sys.modules.keys()\n \n def accumulate_result(test, result):\n  ok, test_time = result\n  test_times.append((test_time, test))\n  if ok == PASSED:\n   good.append(test)\n  elif ok == FAILED:\n   bad.append(test)\n  elif ok == ENV_CHANGED:\n   environment_changed.append(test)\n  elif ok == SKIPPED:\n   skipped.append(test)\n  elif ok == RESOURCE_DENIED:\n   skipped.append(test)\n   resource_denieds.append(test)\n   \n if forever:\n  def test_forever(tests=list(selected)):\n   while True:\n    for test in tests:\n     yield test\n     if bad:\n      return\n  tests = test_forever()\n  test_count = ''\n  test_count_width = 3\n else:\n  tests = iter(selected)\n  test_count = '/{}'.format(len(selected))\n  test_count_width = len(test_count) - 1\n  \n if use_mp:\n  try:\n   from threading import Thread\n  except ImportError:\n   print(\"Multiprocess option requires thread support\")\n   sys.exit(2)\n  from queue import Queue\n  from subprocess import Popen, PIPE\n  debug_output_pat = re.compile(r\"\\[\\d+ refs\\]$\")\n  output = Queue()\n  pending = MultiprocessTests(tests)\n  opt_args = support.args_from_interpreter_flags()\n  base_cmd = [sys.executable] + opt_args + ['-m', 'test.regrtest']\n  def work():\n  \n   try:\n    while True:\n     try:\n      test = next(pending)\n     except StopIteration:\n      output.put((None, None, None, None))\n      return\n     args_tuple = (\n     (test, verbose, quiet),\n     dict(huntrleaks=huntrleaks, use_resources=use_resources,\n     debug=debug, output_on_failure=verbose3,\n     timeout=timeout, failfast=failfast,\n     match_tests=match_tests)\n     )\n     \n     \n     \n     \n     popen = Popen(base_cmd + ['--slaveargs', json.dumps(args_tuple)],\n     stdout=PIPE, stderr=PIPE,\n     universal_newlines=True,\n     close_fds=(os.name != 'nt'),\n     cwd=support.SAVEDCWD)\n     stdout, stderr = popen.communicate()\n     retcode = popen.wait()\n     \n     \n     stderr = debug_output_pat.sub(\"\", stderr)\n     stdout, _, result = stdout.strip().rpartition(\"\\n\")\n     if retcode != 0:\n      result = (CHILD_ERROR, \"Exit code %s\" % retcode)\n      output.put((test, stdout.rstrip(), stderr.rstrip(), result))\n      return\n     if not result:\n      output.put((None, None, None, None))\n      return\n     result = json.loads(result)\n     output.put((test, stdout.rstrip(), stderr.rstrip(), result))\n   except BaseException:\n    output.put((None, None, None, None))\n    raise\n  workers = [Thread(target=work) for i in range(use_mp)]\n  for worker in workers:\n   worker.start()\n  finished = 0\n  test_index = 1\n  try:\n   while finished < use_mp:\n    test, stdout, stderr, result = output.get()\n    if test is None:\n     finished += 1\n     continue\n    accumulate_result(test, result)\n    if not quiet:\n     fmt = \"[{1:{0}}{2}/{3}] {4}\" if bad else \"[{1:{0}}{2}] {4}\"\n     print(fmt.format(\n     test_count_width, test_index, test_count,\n     len(bad), test))\n    if stdout:\n     print(stdout)\n    if stderr:\n     print(stderr, file=sys.stderr)\n    sys.stdout.flush()\n    sys.stderr.flush()\n    if result[0] == INTERRUPTED:\n     raise KeyboardInterrupt\n    if result[0] == CHILD_ERROR:\n     raise Exception(\"Child error on {}: {}\".format(test, result[1]))\n    test_index += 1\n  except KeyboardInterrupt:\n   interrupted = True\n   pending.interrupted = True\n  for worker in workers:\n   worker.join()\n else:\n  for test_index, test in enumerate(tests, 1):\n   if not quiet:\n    fmt = \"[{1:{0}}{2}/{3}] {4}\" if bad else \"[{1:{0}}{2}] {4}\"\n    print(fmt.format(\n    test_count_width, test_index, test_count, len(bad), test))\n    sys.stdout.flush()\n   if trace:\n   \n   \n    tracer.runctx('runtest(test, verbose, quiet, timeout=timeout)',\n    globals=globals(), locals=vars())\n   else:\n    try:\n     result = runtest(test, verbose, quiet, huntrleaks, debug,\n     output_on_failure=verbose3,\n     timeout=timeout, failfast=failfast,\n     match_tests=match_tests)\n     accumulate_result(test, result)\n    except KeyboardInterrupt:\n     interrupted = True\n     break\n    except:\n     raise\n   if findleaks:\n    gc.collect()\n    if gc.garbage:\n     print(\"Warning: test created\", len(gc.garbage), end=' ')\n     print(\"uncollectable object(s).\")\n     \n     \n     found_garbage.extend(gc.garbage)\n     del gc.garbage[:]\n     \n   for module in sys.modules.keys():\n    if module not in save_modules and module.startswith(\"test.\"):\n     support.unload(module)\n     \n if interrupted:\n \n  print()\n  print(\"Test suite interrupted by signal SIGINT.\")\n  omitted = set(selected) - set(good) - set(bad) - set(skipped)\n  print(count(len(omitted), \"test\"), \"omitted:\")\n  printlist(omitted)\n if good and not quiet:\n  if not bad and not skipped and not interrupted and len(good) > 1:\n   print(\"All\", end=' ')\n  print(count(len(good), \"test\"), \"OK.\")\n if print_slow:\n  test_times.sort(reverse=True)\n  print(\"10 slowest tests:\")\n  for time, test in test_times[:10]:\n   print(\"%s: %.1fs\" % (test, time))\n if bad:\n  bad = sorted(set(bad) - set(environment_changed))\n  if bad:\n   print(count(len(bad), \"test\"), \"failed:\")\n   printlist(bad)\n if environment_changed:\n  print(\"{} altered the execution environment:\".format(\n  count(len(environment_changed), \"test\")))\n  printlist(environment_changed)\n if skipped and not quiet:\n  print(count(len(skipped), \"test\"), \"skipped:\")\n  printlist(skipped)\n  \n  e = _ExpectedSkips()\n  plat = sys.platform\n  if e.isvalid():\n   surprise = set(skipped) - e.getexpected() - set(resource_denieds)\n   if surprise:\n    print(count(len(surprise), \"skip\"), \"unexpected on\", plat + \":\")\n    printlist(surprise)\n   else:\n    print(\"Those skips are all expected on\", plat + \".\")\n  else:\n   print(\"Ask someone to teach regrtest.py about which tests are\")\n   print(\"expected to get skipped on\", plat + \".\")\n   \n if verbose2 and bad:\n  print(\"Re-running failed tests in verbose mode\")\n  for test in bad:\n   print(\"Re-running test %r in verbose mode\" % test)\n   sys.stdout.flush()\n   try:\n    verbose = True\n    ok = runtest(test, True, quiet, huntrleaks, debug, timeout=timeout)\n   except KeyboardInterrupt:\n   \n    print()\n    break\n   except:\n    raise\n    \n if single:\n  if next_single_test:\n   with open(filename, 'w') as fp:\n    fp.write(next_single_test + '\\n')\n  else:\n   os.unlink(filename)\n   \n if trace:\n  r = tracer.results()\n  r.write_results(show_missing=True, summary=True, coverdir=coverdir)\n  \n if runleaks:\n  os.system(\"leaks %d\" % os.getpid())\n  \n sys.exit(len(bad) > 0 or interrupted)\n \n \n \n \nSTDTESTS = [\n'test_grammar',\n'test_opcodes',\n'test_dict',\n'test_builtin',\n'test_exceptions',\n'test_types',\n'test_unittest',\n'test_doctest',\n'test_doctest2',\n'test_support'\n]\n\n\nNOTTESTS = set()\n\ndef findtests(testdir=None, stdtests=STDTESTS, nottests=NOTTESTS):\n \"\"\n testdir = findtestdir(testdir)\n names = os.listdir(testdir)\n tests = []\n others = set(stdtests) | nottests\n for name in names:\n  mod, ext = os.path.splitext(name)\n  if mod[:5] == \"test_\" and ext in (\".py\", \"\") and mod not in others:\n   tests.append(mod)\n return stdtests + sorted(tests)\n \n \nclass MultiprocessTests(object):\n\n \"\"\n \n def __init__(self, tests):\n  self.interrupted = False\n  self.lock = threading.Lock()\n  self.tests = tests\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  with self.lock:\n   if self.interrupted:\n    raise StopIteration('tests interrupted')\n   return next(self.tests)\n   \ndef replace_stdout():\n \"\"\n import atexit\n \n stdout = sys.stdout\n sys.stdout = open(stdout.fileno(), 'w',\n encoding=stdout.encoding,\n errors=\"backslashreplace\",\n closefd=False,\n newline='\\n')\n \n def restore_stdout():\n  sys.stdout.close()\n  sys.stdout = stdout\n atexit.register(restore_stdout)\n \ndef runtest(test, verbose, quiet,\nhuntrleaks=False, debug=False, use_resources=None,\noutput_on_failure=False, failfast=False, match_tests=None,\ntimeout=None):\n \"\"\n \n if use_resources is not None:\n  support.use_resources = use_resources\n use_timeout = (timeout is not None)\n if use_timeout:\n  faulthandler.dump_tracebacks_later(timeout, exit=True)\n try:\n  support.match_tests = match_tests\n  if failfast:\n   support.failfast = True\n  if output_on_failure:\n   support.verbose = True\n   \n   \n   \n   \n   if runtest.stringio is None:\n    stream = io.StringIO()\n    runtest.stringio = stream\n   else:\n    stream = runtest.stringio\n    stream.seek(0)\n    stream.truncate()\n    \n   orig_stdout = sys.stdout\n   orig_stderr = sys.stderr\n   try:\n    sys.stdout = stream\n    sys.stderr = stream\n    result = runtest_inner(test, verbose, quiet, huntrleaks,\n    debug, display_failure=False)\n    if result[0] == FAILED:\n     output = stream.getvalue()\n     orig_stderr.write(output)\n     orig_stderr.flush()\n   finally:\n    sys.stdout = orig_stdout\n    sys.stderr = orig_stderr\n  else:\n   support.verbose = verbose \n   result = runtest_inner(test, verbose, quiet, huntrleaks, debug,\n   display_failure=not verbose)\n  return result\n finally:\n  if use_timeout:\n   faulthandler.cancel_dump_tracebacks_later()\n  cleanup_test_droppings(test, verbose)\nruntest.stringio = None\n\n\n\n\n\n\n\n\n\nclass saved_test_environment:\n \"\"\n \n changed = False\n \n def __init__(self, testname, verbose=0, quiet=False):\n  self.testname = testname\n  self.verbose = verbose\n  self.quiet = quiet\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n resources = ('sys.argv', 'cwd', 'sys.stdin', 'sys.stdout', 'sys.stderr',\n 'os.environ', 'sys.path', 'sys.path_hooks', '__import__',\n 'warnings.filters', 'asyncore.socket_map',\n 'logging._handlers', 'logging._handlerList', 'sys.gettrace',\n 'sys.warnoptions', 'threading._dangling',\n 'multiprocessing.process._dangling',\n 'sysconfig._CONFIG_VARS', 'sysconfig._INSTALL_SCHEMES',\n 'support.TESTFN',\n )\n \n def get_sys_argv(self):\n  return id(sys.argv), sys.argv, sys.argv[:]\n def restore_sys_argv(self, saved_argv):\n  sys.argv = saved_argv[1]\n  sys.argv[:] = saved_argv[2]\n  \n def get_cwd(self):\n  return os.getcwd()\n def restore_cwd(self, saved_cwd):\n  os.chdir(saved_cwd)\n  \n def get_sys_stdout(self):\n  return sys.stdout\n def restore_sys_stdout(self, saved_stdout):\n  sys.stdout = saved_stdout\n  \n def get_sys_stderr(self):\n  return sys.stderr\n def restore_sys_stderr(self, saved_stderr):\n  sys.stderr = saved_stderr\n  \n def get_sys_stdin(self):\n  return sys.stdin\n def restore_sys_stdin(self, saved_stdin):\n  sys.stdin = saved_stdin\n  \n def get_os_environ(self):\n  return id(os.environ), os.environ, dict(os.environ)\n def restore_os_environ(self, saved_environ):\n  os.environ = saved_environ[1]\n  os.environ.clear()\n  os.environ.update(saved_environ[2])\n  \n def get_sys_path(self):\n  return id(sys.path), sys.path, sys.path[:]\n def restore_sys_path(self, saved_path):\n  sys.path = saved_path[1]\n  sys.path[:] = saved_path[2]\n  \n def get_sys_path_hooks(self):\n  return id(sys.path_hooks), sys.path_hooks, sys.path_hooks[:]\n def restore_sys_path_hooks(self, saved_hooks):\n  sys.path_hooks = saved_hooks[1]\n  sys.path_hooks[:] = saved_hooks[2]\n  \n def get_sys_gettrace(self):\n  return sys.gettrace()\n def restore_sys_gettrace(self, trace_fxn):\n  sys.settrace(trace_fxn)\n  \n def get___import__(self):\n  return builtins.__import__\n def restore___import__(self, import_):\n  builtins.__import__ = import_\n  \n def get_warnings_filters(self):\n  return id(warnings.filters), warnings.filters, warnings.filters[:]\n def restore_warnings_filters(self, saved_filters):\n  warnings.filters = saved_filters[1]\n  warnings.filters[:] = saved_filters[2]\n  \n def get_asyncore_socket_map(self):\n  asyncore = sys.modules.get('asyncore')\n  \n  return asyncore and asyncore.socket_map.copy() or {}\n def restore_asyncore_socket_map(self, saved_map):\n  asyncore = sys.modules.get('asyncore')\n  if asyncore is not None:\n   asyncore.close_all(ignore_all=True)\n   asyncore.socket_map.update(saved_map)\n   \n def get_shutil_archive_formats(self):\n \n \n \n  return shutil._ARCHIVE_FORMATS, shutil._ARCHIVE_FORMATS.copy()\n def restore_shutil_archive_formats(self, saved):\n  shutil._ARCHIVE_FORMATS = saved[0]\n  shutil._ARCHIVE_FORMATS.clear()\n  shutil._ARCHIVE_FORMATS.update(saved[1])\n  \n def get_shutil_unpack_formats(self):\n  return shutil._UNPACK_FORMATS, shutil._UNPACK_FORMATS.copy()\n def restore_shutil_unpack_formats(self, saved):\n  shutil._UNPACK_FORMATS = saved[0]\n  shutil._UNPACK_FORMATS.clear()\n  shutil._UNPACK_FORMATS.update(saved[1])\n  \n def get_logging__handlers(self):\n \n  return id(logging._handlers), logging._handlers, logging._handlers.copy()\n def restore_logging__handlers(self, saved_handlers):\n \n  pass\n  \n def get_logging__handlerList(self):\n \n  return id(logging._handlerList), logging._handlerList, logging._handlerList[:]\n def restore_logging__handlerList(self, saved_handlerList):\n \n  pass\n  \n def get_sys_warnoptions(self):\n  return id(sys.warnoptions), sys.warnoptions, sys.warnoptions[:]\n def restore_sys_warnoptions(self, saved_options):\n  sys.warnoptions = saved_options[1]\n  sys.warnoptions[:] = saved_options[2]\n  \n  \n  \n def get_threading__dangling(self):\n  if not threading:\n   return None\n   \n  return threading._dangling.copy()\n def restore_threading__dangling(self, saved):\n  if not threading:\n   return\n  threading._dangling.clear()\n  threading._dangling.update(saved)\n  \n  \n def get_multiprocessing_process__dangling(self):\n  if not multiprocessing:\n   return None\n   \n  return multiprocessing.process._dangling.copy()\n def restore_multiprocessing_process__dangling(self, saved):\n  if not multiprocessing:\n   return\n  multiprocessing.process._dangling.clear()\n  multiprocessing.process._dangling.update(saved)\n  \n def get_sysconfig__CONFIG_VARS(self):\n \n  sysconfig.get_config_var('prefix')\n  return (id(sysconfig._CONFIG_VARS), sysconfig._CONFIG_VARS,\n  dict(sysconfig._CONFIG_VARS))\n def restore_sysconfig__CONFIG_VARS(self, saved):\n  sysconfig._CONFIG_VARS = saved[1]\n  sysconfig._CONFIG_VARS.clear()\n  sysconfig._CONFIG_VARS.update(saved[2])\n  \n def get_sysconfig__INSTALL_SCHEMES(self):\n  return (id(sysconfig._INSTALL_SCHEMES), sysconfig._INSTALL_SCHEMES,\n  sysconfig._INSTALL_SCHEMES.copy())\n def restore_sysconfig__INSTALL_SCHEMES(self, saved):\n  sysconfig._INSTALL_SCHEMES = saved[1]\n  sysconfig._INSTALL_SCHEMES.clear()\n  sysconfig._INSTALL_SCHEMES.update(saved[2])\n  \n def get_support_TESTFN(self):\n  if os.path.isfile(support.TESTFN):\n   result = 'f'\n  elif os.path.isdir(support.TESTFN):\n   result = 'd'\n  else:\n   result = None\n  return result\n def restore_support_TESTFN(self, saved_value):\n  if saved_value is None:\n   if os.path.isfile(support.TESTFN):\n    os.unlink(support.TESTFN)\n   elif os.path.isdir(support.TESTFN):\n    shutil.rmtree(support.TESTFN)\n    \n def resource_info(self):\n  for name in self.resources:\n   method_suffix = name.replace('.', '_')\n   get_name = 'get_' + method_suffix\n   restore_name = 'restore_' + method_suffix\n   yield name, getattr(self, get_name), getattr(self, restore_name)\n   \n def __enter__(self):\n  self.saved_values = dict((name, get()) for name, get, restore\n  in self.resource_info())\n  return self\n  \n def __exit__(self, exc_type, exc_val, exc_tb):\n  saved_values = self.saved_values\n  del self.saved_values\n  for name, get, restore in self.resource_info():\n   current = get()\n   original = saved_values.pop(name)\n   \n   if current != original:\n    self.changed = True\n    restore(original)\n    if not self.quiet:\n     print(\"Warning -- {} was modified by {}\".format(\n     name, self.testname),\n     file=sys.stderr)\n     if self.verbose > 1:\n      print(\"  Before: {}\\n  After:  {} \".format(\n      original, current),\n      file=sys.stderr)\n  return False\n  \n  \ndef runtest_inner(test, verbose, quiet,\nhuntrleaks=False, debug=False, display_failure=True):\n support.unload(test)\n \n test_time = 0.0\n refleak = False \n try:\n  if test.startswith('test.'):\n   abstest = test\n  else:\n  \n   abstest = 'test.' + test\n  with saved_test_environment(test, verbose, quiet) as environment:\n   start_time = time.time()\n   the_package = __import__(abstest, globals(), locals(), [])\n   the_module = getattr(the_package, test)\n   \n   \n   test_runner = getattr(the_module, \"test_main\", None)\n   if test_runner is None:\n    tests = unittest.TestLoader().loadTestsFromModule(the_module)\n    test_runner = lambda: support.run_unittest(tests)\n   test_runner()\n   if huntrleaks:\n    refleak = dash_R(the_module, test, test_runner,\n    huntrleaks)\n   test_time = time.time() - start_time\n except support.ResourceDenied as msg:\n  if not quiet:\n   print(test, \"skipped --\", msg)\n   sys.stdout.flush()\n  return RESOURCE_DENIED, test_time\n except unittest.SkipTest as msg:\n  if not quiet:\n   print(test, \"skipped --\", msg)\n   sys.stdout.flush()\n  return SKIPPED, test_time\n except KeyboardInterrupt:\n  raise\n except support.TestFailed as msg:\n  if display_failure:\n   print(\"test\", test, \"failed --\", msg, file=sys.stderr)\n  else:\n   print(\"test\", test, \"failed\", file=sys.stderr)\n  sys.stderr.flush()\n  return FAILED, test_time\n except:\n  msg = traceback.format_exc()\n  print(\"test\", test, \"crashed --\", msg, file=sys.stderr)\n  sys.stderr.flush()\n  return FAILED, test_time\n else:\n  if refleak:\n   return FAILED, test_time\n  if environment.changed:\n   return ENV_CHANGED, test_time\n  return PASSED, test_time\n  \ndef cleanup_test_droppings(testname, verbose):\n import shutil\n import stat\n import gc\n \n \n \n \n gc.collect()\n \n \n \n \n \n \n \n for name in (support.TESTFN,\n \"db_home\",\n ):\n  if not os.path.exists(name):\n   continue\n   \n  if os.path.isdir(name):\n   kind, nuker = \"directory\", shutil.rmtree\n  elif os.path.isfile(name):\n   kind, nuker = \"file\", os.unlink\n  else:\n   raise SystemError(\"os.path says %r exists but is neither \"\n   \"directory nor file\" % name)\n   \n  if verbose:\n   print(\"%r left behind %s %r\" % (testname, kind, name))\n  try:\n  \n  \n   if (hasattr(os, 'chmod')):\n    os.chmod(name, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n   nuker(name)\n  except Exception as msg:\n   print((\"%r left behind %s %r and it couldn't be \"\n   \"removed: %s\" % (testname, kind, name, msg)), file=sys.stderr)\n   \ndef dash_R(the_module, test, indirect_test, huntrleaks):\n \"\"\n \n import copyreg\n import collections.abc\n \n if not hasattr(sys, 'gettotalrefcount'):\n  raise Exception(\"Tracking reference leaks requires a debug build \"\n  \"of Python\")\n  \n  \n fs = warnings.filters[:]\n ps = copyreg.dispatch_table.copy()\n pic = sys.path_importer_cache.copy()\n try:\n  import zipimport\n except ImportError:\n  zdc = None \n else:\n  zdc = zipimport._zip_directory_cache.copy()\n abcs = {}\n for abc in [getattr(collections.abc, a) for a in collections.abc.__all__]:\n  if not isabstract(abc):\n   continue\n  for obj in abc.__subclasses__() + [abc]:\n   abcs[obj] = obj._abc_registry.copy()\n   \n if indirect_test:\n  def run_the_test():\n   indirect_test()\n else:\n  def run_the_test():\n   del sys.modules[the_module.__name__]\n   exec('import ' + the_module.__name__)\n   \n deltas = []\n nwarmup, ntracked, fname = huntrleaks\n fname = os.path.join(support.SAVEDCWD, fname)\n repcount = nwarmup + ntracked\n print(\"beginning\", repcount, \"repetitions\", file=sys.stderr)\n print((\"1234567890\"*(repcount//10 + 1))[:repcount], file=sys.stderr)\n sys.stderr.flush()\n dash_R_cleanup(fs, ps, pic, zdc, abcs)\n for i in range(repcount):\n  rc_before = sys.gettotalrefcount()\n  run_the_test()\n  sys.stderr.write('.')\n  sys.stderr.flush()\n  dash_R_cleanup(fs, ps, pic, zdc, abcs)\n  rc_after = sys.gettotalrefcount()\n  if i >= nwarmup:\n   deltas.append(rc_after - rc_before)\n print(file=sys.stderr)\n if any(deltas):\n  msg = '%s leaked %s references, sum=%s' % (test, deltas, sum(deltas))\n  print(msg, file=sys.stderr)\n  sys.stderr.flush()\n  with open(fname, \"a\") as refrep:\n   print(msg, file=refrep)\n   refrep.flush()\n  return True\n return False\n \ndef dash_R_cleanup(fs, ps, pic, zdc, abcs):\n import gc, copyreg\n import _strptime, linecache\n import urllib.parse, urllib.request, mimetypes, doctest\n import struct, filecmp, collections.abc\n from distutils.dir_util import _path_created\n from weakref import WeakSet\n \n \n for mod in sys.modules.values():\n  if hasattr(mod, '__warningregistry__'):\n   del mod.__warningregistry__\n   \n   \n warnings.filters[:] = fs\n copyreg.dispatch_table.clear()\n copyreg.dispatch_table.update(ps)\n sys.path_importer_cache.clear()\n sys.path_importer_cache.update(pic)\n try:\n  import zipimport\n except ImportError:\n  pass \n else:\n  zipimport._zip_directory_cache.clear()\n  zipimport._zip_directory_cache.update(zdc)\n  \n  \n sys._clear_type_cache()\n \n \n for abc in [getattr(collections.abc, a) for a in collections.abc.__all__]:\n  if not isabstract(abc):\n   continue\n  for obj in abc.__subclasses__() + [abc]:\n   obj._abc_registry = abcs.get(obj, WeakSet()).copy()\n   obj._abc_cache.clear()\n   obj._abc_negative_cache.clear()\n   \n   \n   \n for stream in (sys.stdout, sys.stderr, sys.__stdout__, sys.__stderr__):\n  if stream is not None:\n   stream.flush()\n   \n   \n _path_created.clear()\n re.purge()\n _strptime._regex_cache.clear()\n urllib.parse.clear_cache()\n urllib.request.urlcleanup()\n linecache.clearcache()\n mimetypes._default_mime_types()\n filecmp._cache.clear()\n struct._clearcache()\n doctest.master = None\n try:\n  import ctypes\n except ImportError:\n \n  pass\n else:\n  ctypes._reset_cache()\n  \n  \n gc.collect()\n \ndef warm_caches():\n\n s = bytes(range(256))\n for i in range(256):\n  s[i:i+1]\n  \n x = [chr(i) for i in range(256)]\n \n x = list(range(-5, 257))\n \ndef findtestdir(path=None):\n return path or os.path.dirname(__file__) or os.curdir\n \ndef removepy(names):\n if not names:\n  return\n for idx, name in enumerate(names):\n  basename, ext = os.path.splitext(name)\n  if ext == '.py':\n   names[idx] = basename\n   \ndef count(n, word):\n if n == 1:\n  return \"%d %s\" % (n, word)\n else:\n  return \"%d %ss\" % (n, word)\n  \ndef printlist(x, width=70, indent=4):\n \"\"\n \n from textwrap import fill\n blanks = ' ' * indent\n \n print(fill(' '.join(str(elt) for elt in sorted(x)), width,\n initial_indent=blanks, subsequent_indent=blanks))\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n_expectations = (\n('win32',\n\"\"\"\n        test__locale\n        test_crypt\n        test_curses\n        test_dbm\n        test_devpoll\n        test_fcntl\n        test_fork1\n        test_epoll\n        test_dbm_gnu\n        test_dbm_ndbm\n        test_grp\n        test_ioctl\n        test_largefile\n        test_kqueue\n        test_openpty\n        test_ossaudiodev\n        test_pipes\n        test_poll\n        test_posix\n        test_pty\n        test_pwd\n        test_resource\n        test_signal\n        test_syslog\n        test_threadsignals\n        test_wait3\n        test_wait4\n        \"\"\"),\n('linux',\n\"\"\"\n        test_curses\n        test_devpoll\n        test_largefile\n        test_kqueue\n        test_ossaudiodev\n        \"\"\"),\n('unixware',\n\"\"\"\n        test_epoll\n        test_largefile\n        test_kqueue\n        test_minidom\n        test_openpty\n        test_pyexpat\n        test_sax\n        test_sundry\n        \"\"\"),\n('openunix',\n\"\"\"\n        test_epoll\n        test_largefile\n        test_kqueue\n        test_minidom\n        test_openpty\n        test_pyexpat\n        test_sax\n        test_sundry\n        \"\"\"),\n('sco_sv',\n\"\"\"\n        test_asynchat\n        test_fork1\n        test_epoll\n        test_gettext\n        test_largefile\n        test_locale\n        test_kqueue\n        test_minidom\n        test_openpty\n        test_pyexpat\n        test_queue\n        test_sax\n        test_sundry\n        test_thread\n        test_threaded_import\n        test_threadedtempfile\n        test_threading\n        \"\"\"),\n('darwin',\n\"\"\"\n        test__locale\n        test_curses\n        test_devpoll\n        test_epoll\n        test_dbm_gnu\n        test_gdb\n        test_largefile\n        test_locale\n        test_minidom\n        test_ossaudiodev\n        test_poll\n        \"\"\"),\n('sunos',\n\"\"\"\n        test_curses\n        test_dbm\n        test_epoll\n        test_kqueue\n        test_dbm_gnu\n        test_gzip\n        test_openpty\n        test_zipfile\n        test_zlib\n        \"\"\"),\n('hp-ux',\n\"\"\"\n        test_curses\n        test_epoll\n        test_dbm_gnu\n        test_gzip\n        test_largefile\n        test_locale\n        test_kqueue\n        test_minidom\n        test_openpty\n        test_pyexpat\n        test_sax\n        test_zipfile\n        test_zlib\n        \"\"\"),\n('cygwin',\n\"\"\"\n        test_curses\n        test_dbm\n        test_devpoll\n        test_epoll\n        test_ioctl\n        test_kqueue\n        test_largefile\n        test_locale\n        test_ossaudiodev\n        test_socketserver\n        \"\"\"),\n('os2emx',\n\"\"\"\n        test_audioop\n        test_curses\n        test_epoll\n        test_kqueue\n        test_largefile\n        test_mmap\n        test_openpty\n        test_ossaudiodev\n        test_pty\n        test_resource\n        test_signal\n        \"\"\"),\n('freebsd',\n\"\"\"\n        test_devpoll\n        test_epoll\n        test_dbm_gnu\n        test_locale\n        test_ossaudiodev\n        test_pep277\n        test_pty\n        test_socketserver\n        test_tcl\n        test_tk\n        test_ttk_guionly\n        test_ttk_textonly\n        test_timeout\n        test_urllibnet\n        test_multiprocessing\n        \"\"\"),\n('aix',\n\"\"\"\n        test_bz2\n        test_epoll\n        test_dbm_gnu\n        test_gzip\n        test_kqueue\n        test_ossaudiodev\n        test_tcl\n        test_tk\n        test_ttk_guionly\n        test_ttk_textonly\n        test_zipimport\n        test_zlib\n        \"\"\"),\n('openbsd',\n\"\"\"\n        test_ctypes\n        test_devpoll\n        test_epoll\n        test_dbm_gnu\n        test_locale\n        test_normalization\n        test_ossaudiodev\n        test_pep277\n        test_tcl\n        test_tk\n        test_ttk_guionly\n        test_ttk_textonly\n        test_multiprocessing\n        \"\"\"),\n('netbsd',\n\"\"\"\n        test_ctypes\n        test_curses\n        test_devpoll\n        test_epoll\n        test_dbm_gnu\n        test_locale\n        test_ossaudiodev\n        test_pep277\n        test_tcl\n        test_tk\n        test_ttk_guionly\n        test_ttk_textonly\n        test_multiprocessing\n        \"\"\"),\n)\n\nclass _ExpectedSkips:\n def __init__(self):\n  import os.path\n  from test import test_timeout\n  \n  self.valid = False\n  expected = None\n  for item in _expectations:\n   if sys.platform.startswith(item[0]):\n    expected = item[1]\n    break\n  if expected is not None:\n   self.expected = set(expected.split())\n   \n   \n   \n   self.expected.add('test_nis')\n   \n   \n   if not os.path.supports_unicode_filenames:\n    self.expected.add('test_pep277')\n    \n    \n    \n    \n   encs = (\"utf-8\", \"latin-1\", \"ascii\", \"mbcs\", \"utf-16\", \"utf-32\")\n   if sys.getfilesystemencoding().lower() not in encs:\n    self.expected.add('test_profile')\n    self.expected.add('test_cProfile')\n    self.expected.add('test_doctest')\n    \n   if test_timeout.skip_expected:\n    self.expected.add('test_timeout')\n    \n   if sys.platform != \"win32\":\n   \n   \n    WIN_ONLY = {\"test_unicode_file\", \"test_winreg\",\n    \"test_winsound\", \"test_startfile\",\n    \"test_sqlite\", \"test_msilib\"}\n    self.expected |= WIN_ONLY\n    \n   if sys.platform != 'sunos5':\n    self.expected.add('test_nis')\n    \n   if support.python_is_optimized():\n    self.expected.add(\"test_gdb\")\n    \n   self.valid = True\n   \n def isvalid(self):\n  \"\"\n  return self.valid\n  \n def getexpected(self):\n  \"\"\n  \n  assert self.isvalid()\n  return self.expected\n  \ndef _make_temp_dir_for_build(TEMPDIR):\n\n\n\n if sysconfig.is_python_build():\n  TEMPDIR = os.path.join(sysconfig.get_config_var('srcdir'), 'build')\n  TEMPDIR = os.path.abspath(TEMPDIR)\n  try:\n   os.mkdir(TEMPDIR)\n  except FileExistsError:\n   pass\n   \n   \n   \n   \n TESTCWD = 'test_python_{}'.format(os.getpid())\n \n TESTCWD = os.path.join(TEMPDIR, TESTCWD)\n return TEMPDIR, TESTCWD\n \nif __name__ == '__main__':\n\n\n\n\n\n mydir = os.path.abspath(os.path.normpath(os.path.dirname(sys.argv[0])))\n i = len(sys.path)\n while i >= 0:\n  i -= 1\n  if os.path.abspath(os.path.normpath(sys.path[i])) == mydir:\n   del sys.path[i]\n   \n   \n   \n   \n   \n __file__ = os.path.abspath(__file__)\n \n \n assert __file__ == os.path.abspath(sys.argv[0])\n \n TEMPDIR, TESTCWD = _make_temp_dir_for_build(TEMPDIR)\n \n \n \n \n \n with support.temp_cwd(TESTCWD, quiet=True):\n  main()\n"], "unittest.test.test_runner": ["import io\nimport os\nimport sys\nimport pickle\nimport subprocess\n\nimport unittest\n\nfrom .support import LoggingResult, ResultWithNoStartTestRunStopTestRun\n\n\nclass TestCleanUp(unittest.TestCase):\n\n def testCleanUp(self):\n  class TestableTest(unittest.TestCase):\n   def testNothing(self):\n    pass\n    \n  test = TestableTest('testNothing')\n  self.assertEqual(test._cleanups, [])\n  \n  cleanups = []\n  \n  def cleanup1(*args, **kwargs):\n   cleanups.append((1, args, kwargs))\n   \n  def cleanup2(*args, **kwargs):\n   cleanups.append((2, args, kwargs))\n   \n  test.addCleanup(cleanup1, 1, 2, 3, four='hello', five='goodbye')\n  test.addCleanup(cleanup2)\n  \n  self.assertEqual(test._cleanups,\n  [(cleanup1, (1, 2, 3), dict(four='hello', five='goodbye')),\n  (cleanup2, (), {})])\n  \n  self.assertTrue(test.doCleanups())\n  self.assertEqual(cleanups, [(2, (), {}), (1, (1, 2, 3), dict(four='hello', five='goodbye'))])\n  \n def testCleanUpWithErrors(self):\n  class TestableTest(unittest.TestCase):\n   def testNothing(self):\n    pass\n    \n  class MockOutcome(object):\n   success = True\n   errors = []\n   \n  test = TestableTest('testNothing')\n  test._outcomeForDoCleanups = MockOutcome\n  \n  exc1 = Exception('foo')\n  exc2 = Exception('bar')\n  def cleanup1():\n   raise exc1\n   \n  def cleanup2():\n   raise exc2\n   \n  test.addCleanup(cleanup1)\n  test.addCleanup(cleanup2)\n  \n  self.assertFalse(test.doCleanups())\n  self.assertFalse(MockOutcome.success)\n  \n  (Type1, instance1, _), (Type2, instance2, _) = reversed(MockOutcome.errors)\n  self.assertEqual((Type1, instance1), (Exception, exc1))\n  self.assertEqual((Type2, instance2), (Exception, exc2))\n  \n def testCleanupInRun(self):\n  blowUp = False\n  ordering = []\n  \n  class TestableTest(unittest.TestCase):\n   def setUp(self):\n    ordering.append('setUp')\n    if blowUp:\n     raise Exception('foo')\n     \n   def testNothing(self):\n    ordering.append('test')\n    \n   def tearDown(self):\n    ordering.append('tearDown')\n    \n  test = TestableTest('testNothing')\n  \n  def cleanup1():\n   ordering.append('cleanup1')\n  def cleanup2():\n   ordering.append('cleanup2')\n  test.addCleanup(cleanup1)\n  test.addCleanup(cleanup2)\n  \n  def success(some_test):\n   self.assertEqual(some_test, test)\n   ordering.append('success')\n   \n  result = unittest.TestResult()\n  result.addSuccess = success\n  \n  test.run(result)\n  self.assertEqual(ordering, ['setUp', 'test', 'tearDown',\n  'cleanup2', 'cleanup1', 'success'])\n  \n  blowUp = True\n  ordering = []\n  test = TestableTest('testNothing')\n  test.addCleanup(cleanup1)\n  test.run(result)\n  self.assertEqual(ordering, ['setUp', 'cleanup1'])\n  \n def testTestCaseDebugExecutesCleanups(self):\n  ordering = []\n  \n  class TestableTest(unittest.TestCase):\n   def setUp(self):\n    ordering.append('setUp')\n    self.addCleanup(cleanup1)\n    \n   def testNothing(self):\n    ordering.append('test')\n    \n   def tearDown(self):\n    ordering.append('tearDown')\n    \n  test = TestableTest('testNothing')\n  \n  def cleanup1():\n   ordering.append('cleanup1')\n   test.addCleanup(cleanup2)\n  def cleanup2():\n   ordering.append('cleanup2')\n   \n  test.debug()\n  self.assertEqual(ordering, ['setUp', 'test', 'tearDown', 'cleanup1', 'cleanup2'])\n  \n  \nclass Test_TextTestRunner(unittest.TestCase):\n \"\"\n \n def test_init(self):\n  runner = unittest.TextTestRunner()\n  self.assertFalse(runner.failfast)\n  self.assertFalse(runner.buffer)\n  self.assertEqual(runner.verbosity, 1)\n  self.assertEqual(runner.warnings, None)\n  self.assertTrue(runner.descriptions)\n  self.assertEqual(runner.resultclass, unittest.TextTestResult)\n  \n  \n def testBufferAndFailfast(self):\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  result = unittest.TestResult()\n  runner = unittest.TextTestRunner(stream=io.StringIO(), failfast=True,\n  buffer=True)\n  \n  runner._makeResult = lambda: result\n  runner.run(Test('testFoo'))\n  \n  self.assertTrue(result.failfast)\n  self.assertTrue(result.buffer)\n  \n def testRunnerRegistersResult(self):\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  originalRegisterResult = unittest.runner.registerResult\n  def cleanup():\n   unittest.runner.registerResult = originalRegisterResult\n  self.addCleanup(cleanup)\n  \n  result = unittest.TestResult()\n  runner = unittest.TextTestRunner(stream=io.StringIO())\n  \n  runner._makeResult = lambda: result\n  \n  self.wasRegistered = 0\n  def fakeRegisterResult(thisResult):\n   self.wasRegistered += 1\n   self.assertEqual(thisResult, result)\n  unittest.runner.registerResult = fakeRegisterResult\n  \n  runner.run(unittest.TestSuite())\n  self.assertEqual(self.wasRegistered, 1)\n  \n def test_works_with_result_without_startTestRun_stopTestRun(self):\n  class OldTextResult(ResultWithNoStartTestRunStopTestRun):\n   separator2 = ''\n   def printErrors(self):\n    pass\n    \n  class Runner(unittest.TextTestRunner):\n   def __init__(self):\n    super(Runner, self).__init__(io.StringIO())\n    \n   def _makeResult(self):\n    return OldTextResult()\n    \n  runner = Runner()\n  runner.run(unittest.TestSuite())\n  \n def test_startTestRun_stopTestRun_called(self):\n  class LoggingTextResult(LoggingResult):\n   separator2 = ''\n   def printErrors(self):\n    pass\n    \n  class LoggingRunner(unittest.TextTestRunner):\n   def __init__(self, events):\n    super(LoggingRunner, self).__init__(io.StringIO())\n    self._events = events\n    \n   def _makeResult(self):\n    return LoggingTextResult(self._events)\n    \n  events = []\n  runner = LoggingRunner(events)\n  runner.run(unittest.TestSuite())\n  expected = ['startTestRun', 'stopTestRun']\n  self.assertEqual(events, expected)\n  \n def test_pickle_unpickle(self):\n \n \n  stream = io.StringIO(\"foo\")\n  runner = unittest.TextTestRunner(stream)\n  for protocol in range(2, pickle.HIGHEST_PROTOCOL + 1):\n   s = pickle.dumps(runner, protocol)\n   obj = pickle.loads(s)\n   \n   self.assertEqual(obj.stream.getvalue(), stream.getvalue())\n   \n def test_resultclass(self):\n  def MockResultClass(*args):\n   return args\n  STREAM = object()\n  DESCRIPTIONS = object()\n  VERBOSITY = object()\n  runner = unittest.TextTestRunner(STREAM, DESCRIPTIONS, VERBOSITY,\n  resultclass=MockResultClass)\n  self.assertEqual(runner.resultclass, MockResultClass)\n  \n  expectedresult = (runner.stream, DESCRIPTIONS, VERBOSITY)\n  self.assertEqual(runner._makeResult(), expectedresult)\n  \n def test_warnings(self):\n  \"\"\n  \n  \n  def get_parse_out_err(p):\n   return [b.splitlines() for b in p.communicate()]\n  opts = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n  cwd=os.path.dirname(__file__))\n  ae_msg = b'Please use assertEqual instead.'\n  at_msg = b'Please use assertTrue instead.'\n  \n  \n  p = subprocess.Popen([sys.executable, '_test_warnings.py'], **opts)\n  out, err = get_parse_out_err(p)\n  self.assertIn(b'OK', err)\n  \n  self.assertEqual(len(out), 12)\n  \n  for msg in [b'dw', b'iw', b'uw']:\n   self.assertEqual(out.count(msg), 3)\n  for msg in [ae_msg, at_msg, b'rw']:\n   self.assertEqual(out.count(msg), 1)\n   \n  args_list = (\n  \n  [sys.executable, '_test_warnings.py', 'ignore'],\n  \n  [sys.executable, '-Wa', '_test_warnings.py', 'ignore'],\n  \n  [sys.executable, '-Wi', '_test_warnings.py']\n  )\n  \n  for args in args_list:\n   p = subprocess.Popen(args, **opts)\n   out, err = get_parse_out_err(p)\n   self.assertIn(b'OK', err)\n   self.assertEqual(len(out), 0)\n   \n   \n   \n   \n  p = subprocess.Popen([sys.executable, '_test_warnings.py', 'always'],\n  **opts)\n  out, err = get_parse_out_err(p)\n  self.assertIn(b'OK', err)\n  self.assertEqual(len(out), 14)\n  for msg in [b'dw', b'iw', b'uw', b'rw']:\n   self.assertEqual(out.count(msg), 3)\n  for msg in [ae_msg, at_msg]:\n   self.assertEqual(out.count(msg), 1)\n   \n def testStdErrLookedUpAtInstantiationTime(self):\n \n  old_stderr = sys.stderr\n  f = io.StringIO()\n  sys.stderr = f\n  try:\n   runner = unittest.TextTestRunner()\n   self.assertTrue(runner.stream.stream is f)\n  finally:\n   sys.stderr = old_stderr\n   \n def testSpecifiedStreamUsed(self):\n \n  f = io.StringIO()\n  runner = unittest.TextTestRunner(f)\n  self.assertTrue(runner.stream.stream is f)\n"], "unittest.case": ["\"\"\n\nimport sys\nimport functools\nimport difflib\nimport pprint\nimport re\nimport warnings\nimport collections\n\nfrom . import result\nfrom .util import (strclass, safe_repr, _count_diff_all_purpose,\n_count_diff_hashable)\n\n__unittest = True\n\n\nDIFF_OMITTED = ('\\nDiff is %s characters long. '\n'Set self.maxDiff to None to see it.')\n\nclass SkipTest(Exception):\n \"\"\n \nclass _ExpectedFailure(Exception):\n \"\"\n \n def __init__(self, exc_info):\n  super(_ExpectedFailure, self).__init__()\n  self.exc_info = exc_info\n  \nclass _UnexpectedSuccess(Exception):\n \"\"\n \n \nclass _Outcome(object):\n def __init__(self):\n  self.success = True\n  self.skipped = None\n  self.unexpectedSuccess = None\n  self.expectedFailure = None\n  self.errors = []\n  self.failures = []\n  \n  \ndef _id(obj):\n return obj\n \ndef skip(reason):\n \"\"\n def decorator(test_item):\n  if not isinstance(test_item, type):\n   @functools.wraps(test_item)\n   def skip_wrapper(*args, **kwargs):\n    raise SkipTest(reason)\n   test_item = skip_wrapper\n   \n  test_item.__unittest_skip__ = True\n  test_item.__unittest_skip_why__ = reason\n  return test_item\n return decorator\n \ndef skipIf(condition, reason):\n \"\"\n if condition:\n  return skip(reason)\n return _id\n \ndef skipUnless(condition, reason):\n \"\"\n if not condition:\n  return skip(reason)\n return _id\n \n \ndef expectedFailure(func):\n @functools.wraps(func)\n def wrapper(*args, **kwargs):\n  try:\n   func(*args, **kwargs)\n  except Exception:\n   raise _ExpectedFailure(sys.exc_info())\n  raise _UnexpectedSuccess\n return wrapper\n \n \nclass _AssertRaisesBaseContext(object):\n\n def __init__(self, expected, test_case, callable_obj=None,\n expected_regex=None):\n  self.expected = expected\n  self.test_case = test_case\n  if callable_obj is not None:\n   try:\n    self.obj_name = callable_obj.__name__\n   except AttributeError:\n    self.obj_name = str(callable_obj)\n  else:\n   self.obj_name = None\n  if isinstance(expected_regex, (bytes, str)):\n   expected_regex = re.compile(expected_regex)\n  self.expected_regex = expected_regex\n  self.msg = None\n  \n def _raiseFailure(self, standardMsg):\n  msg = self.test_case._formatMessage(self.msg, standardMsg)\n  raise self.test_case.failureException(msg)\n  \n def handle(self, name, callable_obj, args, kwargs):\n  \"\"\n  if callable_obj is None:\n   self.msg = kwargs.pop('msg', None)\n   return self\n  with self:\n   callable_obj(*args, **kwargs)\n   \n   \n   \nclass _AssertRaisesContext(_AssertRaisesBaseContext):\n \"\"\n \n def __enter__(self):\n  return self\n  \n def __exit__(self, exc_type, exc_value, tb):\n  if exc_type is None:\n   try:\n    exc_name = self.expected.__name__\n   except AttributeError:\n    exc_name = str(self.expected)\n   if self.obj_name:\n    self._raiseFailure(\"{} not raised by {}\".format(exc_name,\n    self.obj_name))\n   else:\n    self._raiseFailure(\"{} not raised\".format(exc_name))\n  if not issubclass(exc_type, self.expected):\n  \n   return False\n   \n  self.exception = exc_value.with_traceback(None)\n  if self.expected_regex is None:\n   return True\n   \n  expected_regex = self.expected_regex\n  if not expected_regex.search(str(exc_value)):\n   self._raiseFailure('\"{}\" does not match \"{}\"'.format(\n   expected_regex.pattern, str(exc_value)))\n  return True\n  \n  \nclass _AssertWarnsContext(_AssertRaisesBaseContext):\n \"\"\n \n def __enter__(self):\n \n \n  for v in sys.modules.values():\n   if getattr(v, '__warningregistry__', None):\n    v.__warningregistry__ = {}\n  self.warnings_manager = warnings.catch_warnings(record=True)\n  self.warnings = self.warnings_manager.__enter__()\n  warnings.simplefilter(\"always\", self.expected)\n  return self\n  \n def __exit__(self, exc_type, exc_value, tb):\n  self.warnings_manager.__exit__(exc_type, exc_value, tb)\n  if exc_type is not None:\n  \n   return\n  try:\n   exc_name = self.expected.__name__\n  except AttributeError:\n   exc_name = str(self.expected)\n  first_matching = None\n  for m in self.warnings:\n   w = m.message\n   if not isinstance(w, self.expected):\n    continue\n   if first_matching is None:\n    first_matching = w\n   if (self.expected_regex is not None and\n   not self.expected_regex.search(str(w))):\n    continue\n    \n   self.warning = w\n   self.filename = m.filename\n   self.lineno = m.lineno\n   return\n   \n  if first_matching is not None:\n   self._raiseFailure('\"{}\" does not match \"{}\"'.format(\n   self.expected_regex.pattern, str(first_matching)))\n  if self.obj_name:\n   self._raiseFailure(\"{} not triggered by {}\".format(exc_name,\n   self.obj_name))\n  else:\n   self._raiseFailure(\"{} not triggered\".format(exc_name))\n   \n   \nclass TestCase(object):\n \"\"\n \n failureException = AssertionError\n \n longMessage = True\n \n maxDiff = 80*8\n \n \n \n _diffThreshold = 2**16\n \n \n \n _classSetupFailed = False\n \n def __init__(self, methodName='runTest'):\n  \"\"\n  self._testMethodName = methodName\n  self._outcomeForDoCleanups = None\n  self._testMethodDoc = 'No test'\n  try:\n   testMethod = getattr(self, methodName)\n  except AttributeError:\n   if methodName != 'runTest':\n   \n   \n    raise ValueError(\"no such test method in %s: %s\" %\n    (self.__class__, methodName))\n  else:\n   self._testMethodDoc = testMethod.__doc__\n  self._cleanups = []\n  \n  \n  \n  \n  self._type_equality_funcs = {}\n  self.addTypeEqualityFunc(dict, 'assertDictEqual')\n  self.addTypeEqualityFunc(list, 'assertListEqual')\n  self.addTypeEqualityFunc(tuple, 'assertTupleEqual')\n  self.addTypeEqualityFunc(set, 'assertSetEqual')\n  self.addTypeEqualityFunc(frozenset, 'assertSetEqual')\n  self.addTypeEqualityFunc(str, 'assertMultiLineEqual')\n  \n def addTypeEqualityFunc(self, typeobj, function):\n  \"\"\n  self._type_equality_funcs[typeobj] = function\n  \n def addCleanup(self, function, *args, **kwargs):\n  \"\"\n  self._cleanups.append((function, args, kwargs))\n  \n def setUp(self):\n  \"\"\n  pass\n  \n def tearDown(self):\n  \"\"\n  pass\n  \n @classmethod\n def setUpClass(cls):\n  \"\"\n  \n @classmethod\n def tearDownClass(cls):\n  \"\"\n  \n def countTestCases(self):\n  return 1\n  \n def defaultTestResult(self):\n  return result.TestResult()\n  \n def shortDescription(self):\n  \"\"\n  doc = self._testMethodDoc\n  return doc and doc.split(\"\\n\")[0].strip() or None\n  \n  \n def id(self):\n  return \"%s.%s\" % (strclass(self.__class__), self._testMethodName)\n  \n def __eq__(self, other):\n  if type(self) is not type(other):\n   return NotImplemented\n   \n  return self._testMethodName == other._testMethodName\n  \n def __hash__(self):\n  return hash((type(self), self._testMethodName))\n  \n def __str__(self):\n  return \"%s (%s)\" % (self._testMethodName, strclass(self.__class__))\n  \n def __repr__(self):\n  return \"<%s testMethod=%s>\" % (strclass(self.__class__), self._testMethodName)\n  \n def _addSkip(self, result, reason):\n  addSkip = getattr(result, 'addSkip', None)\n  if addSkip is not None:\n   addSkip(self, reason)\n  else:\n   warnings.warn(\"TestResult has no addSkip method, skips not reported\",\n   RuntimeWarning, 2)\n   result.addSuccess(self)\n   \n def _executeTestPart(self, function, outcome, isTest=False):\n  try:\n   function()\n  except KeyboardInterrupt:\n   raise\n  except SkipTest as e:\n   outcome.success = False\n   outcome.skipped = str(e)\n  except _UnexpectedSuccess:\n   exc_info = sys.exc_info()\n   outcome.success = False\n   if isTest:\n    outcome.unexpectedSuccess = exc_info\n   else:\n    outcome.errors.append(exc_info)\n  except _ExpectedFailure:\n   outcome.success = False\n   exc_info = sys.exc_info()\n   if isTest:\n    outcome.expectedFailure = exc_info\n   else:\n    outcome.errors.append(exc_info)\n  except self.failureException:\n   outcome.success = False\n   outcome.failures.append(sys.exc_info())\n   exc_info = sys.exc_info()\n  except:\n   outcome.success = False\n   outcome.errors.append(sys.exc_info())\n   \n def run(self, result=None):\n  orig_result = result\n  if result is None:\n   result = self.defaultTestResult()\n   startTestRun = getattr(result, 'startTestRun', None)\n   if startTestRun is not None:\n    startTestRun()\n    \n  result.startTest(self)\n  \n  testMethod = getattr(self, self._testMethodName)\n  if (getattr(self.__class__, \"__unittest_skip__\", False) or\n  getattr(testMethod, \"__unittest_skip__\", False)):\n  \n   try:\n    skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')\n    or getattr(testMethod, '__unittest_skip_why__', ''))\n    self._addSkip(result, skip_why)\n   finally:\n    result.stopTest(self)\n   return\n  try:\n   outcome = _Outcome()\n   self._outcomeForDoCleanups = outcome\n   \n   self._executeTestPart(self.setUp, outcome)\n   if outcome.success:\n    self._executeTestPart(testMethod, outcome, isTest=True)\n    self._executeTestPart(self.tearDown, outcome)\n    \n   self.doCleanups()\n   if outcome.success:\n    result.addSuccess(self)\n   else:\n    if outcome.skipped is not None:\n     self._addSkip(result, outcome.skipped)\n    for exc_info in outcome.errors:\n     result.addError(self, exc_info)\n    for exc_info in outcome.failures:\n     result.addFailure(self, exc_info)\n    if outcome.unexpectedSuccess is not None:\n     addUnexpectedSuccess = getattr(result, 'addUnexpectedSuccess', None)\n     if addUnexpectedSuccess is not None:\n      addUnexpectedSuccess(self)\n     else:\n      warnings.warn(\"TestResult has no addUnexpectedSuccess method, reporting as failures\",\n      RuntimeWarning)\n      result.addFailure(self, outcome.unexpectedSuccess)\n      \n    if outcome.expectedFailure is not None:\n     addExpectedFailure = getattr(result, 'addExpectedFailure', None)\n     if addExpectedFailure is not None:\n      addExpectedFailure(self, outcome.expectedFailure)\n     else:\n      warnings.warn(\"TestResult has no addExpectedFailure method, reporting as passes\",\n      RuntimeWarning)\n      result.addSuccess(self)\n   return result\n  finally:\n   result.stopTest(self)\n   if orig_result is None:\n    stopTestRun = getattr(result, 'stopTestRun', None)\n    if stopTestRun is not None:\n     stopTestRun()\n     \n def doCleanups(self):\n  \"\"\n  outcome = self._outcomeForDoCleanups or _Outcome()\n  while self._cleanups:\n   function, args, kwargs = self._cleanups.pop()\n   part = lambda: function(*args, **kwargs)\n   self._executeTestPart(part, outcome)\n   \n   \n   \n  return outcome.success\n  \n def __call__(self, *args, **kwds):\n  return self.run(*args, **kwds)\n  \n def debug(self):\n  \"\"\n  self.setUp()\n  getattr(self, self._testMethodName)()\n  self.tearDown()\n  while self._cleanups:\n   function, args, kwargs = self._cleanups.pop(-1)\n   function(*args, **kwargs)\n   \n def skipTest(self, reason):\n  \"\"\n  raise SkipTest(reason)\n  \n def fail(self, msg=None):\n  \"\"\n  raise self.failureException(msg)\n  \n def assertFalse(self, expr, msg=None):\n  \"\"\n  if expr:\n   msg = self._formatMessage(msg, \"%s is not false\" % safe_repr(expr))\n   raise self.failureException(msg)\n   \n def assertTrue(self, expr, msg=None):\n  \"\"\n  if not expr:\n   msg = self._formatMessage(msg, \"%s is not true\" % safe_repr(expr))\n   raise self.failureException(msg)\n   \n def _formatMessage(self, msg, standardMsg):\n  \"\"\n  if not self.longMessage:\n   return msg or standardMsg\n  if msg is None:\n   return standardMsg\n  try:\n  \n  \n   return '%s : %s' % (standardMsg, msg)\n  except UnicodeDecodeError:\n   return '%s : %s' % (safe_repr(standardMsg), safe_repr(msg))\n   \n def assertRaises(self, excClass, callableObj=None, *args, **kwargs):\n  \"\"\n  context = _AssertRaisesContext(excClass, self, callableObj)\n  return context.handle('assertRaises', callableObj, args, kwargs)\n  \n def assertWarns(self, expected_warning, callable_obj=None, *args, **kwargs):\n  \"\"\n  context = _AssertWarnsContext(expected_warning, self, callable_obj)\n  return context.handle('assertWarns', callable_obj, args, kwargs)\n  \n def _getAssertEqualityFunc(self, first, second):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if type(first) is type(second):\n   asserter = self._type_equality_funcs.get(type(first))\n   if asserter is not None:\n    if isinstance(asserter, str):\n     asserter = getattr(self, asserter)\n    return asserter\n    \n  return self._baseAssertEqual\n  \n def _baseAssertEqual(self, first, second, msg=None):\n  \"\"\n  if not first == second:\n   standardMsg = '%s != %s' % (safe_repr(first), safe_repr(second))\n   msg = self._formatMessage(msg, standardMsg)\n   raise self.failureException(msg)\n   \n def assertEqual(self, first, second, msg=None):\n  \"\"\n  assertion_func = self._getAssertEqualityFunc(first, second)\n  assertion_func(first, second, msg=msg)\n  \n def assertNotEqual(self, first, second, msg=None):\n  \"\"\n  if not first != second:\n   msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),\n   safe_repr(second)))\n   raise self.failureException(msg)\n   \n def assertAlmostEqual(self, first, second, places=None, msg=None,\n delta=None):\n  \"\"\n  if first == second:\n  \n   return\n  if delta is not None and places is not None:\n   raise TypeError(\"specify delta or places not both\")\n   \n  if delta is not None:\n   if abs(first - second) <= delta:\n    return\n    \n   standardMsg = '%s != %s within %s delta' % (safe_repr(first),\n   safe_repr(second),\n   safe_repr(delta))\n  else:\n   if places is None:\n    places = 7\n    \n   if round(abs(second-first), places) == 0:\n    return\n    \n   standardMsg = '%s != %s within %r places' % (safe_repr(first),\n   safe_repr(second),\n   places)\n  msg = self._formatMessage(msg, standardMsg)\n  raise self.failureException(msg)\n  \n def assertNotAlmostEqual(self, first, second, places=None, msg=None,\n delta=None):\n  \"\"\n  if delta is not None and places is not None:\n   raise TypeError(\"specify delta or places not both\")\n  if delta is not None:\n   if not (first == second) and abs(first - second) > delta:\n    return\n   standardMsg = '%s == %s within %s delta' % (safe_repr(first),\n   safe_repr(second),\n   safe_repr(delta))\n  else:\n   if places is None:\n    places = 7\n   if not (first == second) and round(abs(second-first), places) != 0:\n    return\n   standardMsg = '%s == %s within %r places' % (safe_repr(first),\n   safe_repr(second),\n   places)\n   \n  msg = self._formatMessage(msg, standardMsg)\n  raise self.failureException(msg)\n  \n  \n def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):\n  \"\"\n  if seq_type is not None:\n   seq_type_name = seq_type.__name__\n   if not isinstance(seq1, seq_type):\n    raise self.failureException('First sequence is not a %s: %s'\n    % (seq_type_name, safe_repr(seq1)))\n   if not isinstance(seq2, seq_type):\n    raise self.failureException('Second sequence is not a %s: %s'\n    % (seq_type_name, safe_repr(seq2)))\n  else:\n   seq_type_name = \"sequence\"\n   \n  differing = None\n  try:\n   len1 = len(seq1)\n  except (TypeError, NotImplementedError):\n   differing = 'First %s has no length.    Non-sequence?' % (\n   seq_type_name)\n   \n  if differing is None:\n   try:\n    len2 = len(seq2)\n   except (TypeError, NotImplementedError):\n    differing = 'Second %s has no length.    Non-sequence?' % (\n    seq_type_name)\n    \n  if differing is None:\n   if seq1 == seq2:\n    return\n    \n   seq1_repr = safe_repr(seq1)\n   seq2_repr = safe_repr(seq2)\n   if len(seq1_repr) > 30:\n    seq1_repr = seq1_repr[:30] + '...'\n   if len(seq2_repr) > 30:\n    seq2_repr = seq2_repr[:30] + '...'\n   elements = (seq_type_name.capitalize(), seq1_repr, seq2_repr)\n   differing = '%ss differ: %s != %s\\n' % elements\n   \n   for i in range(min(len1, len2)):\n    try:\n     item1 = seq1[i]\n    except (TypeError, IndexError, NotImplementedError):\n     differing += ('\\nUnable to index element %d of first %s\\n' %\n     (i, seq_type_name))\n     break\n     \n    try:\n     item2 = seq2[i]\n    except (TypeError, IndexError, NotImplementedError):\n     differing += ('\\nUnable to index element %d of second %s\\n' %\n     (i, seq_type_name))\n     break\n     \n    if item1 != item2:\n     differing += ('\\nFirst differing element %d:\\n%s\\n%s\\n' %\n     (i, item1, item2))\n     break\n   else:\n    if (len1 == len2 and seq_type is None and\n    type(seq1) != type(seq2)):\n    \n     return\n     \n   if len1 > len2:\n    differing += ('\\nFirst %s contains %d additional '\n    'elements.\\n' % (seq_type_name, len1 - len2))\n    try:\n     differing += ('First extra element %d:\\n%s\\n' %\n     (len2, seq1[len2]))\n    except (TypeError, IndexError, NotImplementedError):\n     differing += ('Unable to index element %d '\n     'of first %s\\n' % (len2, seq_type_name))\n   elif len1 < len2:\n    differing += ('\\nSecond %s contains %d additional '\n    'elements.\\n' % (seq_type_name, len2 - len1))\n    try:\n     differing += ('First extra element %d:\\n%s\\n' %\n     (len1, seq2[len1]))\n    except (TypeError, IndexError, NotImplementedError):\n     differing += ('Unable to index element %d '\n     'of second %s\\n' % (len1, seq_type_name))\n  standardMsg = differing\n  diffMsg = '\\n' + '\\n'.join(\n  difflib.ndiff(pprint.pformat(seq1).splitlines(),\n  pprint.pformat(seq2).splitlines()))\n  \n  standardMsg = self._truncateMessage(standardMsg, diffMsg)\n  msg = self._formatMessage(msg, standardMsg)\n  self.fail(msg)\n  \n def _truncateMessage(self, message, diff):\n  max_diff = self.maxDiff\n  if max_diff is None or len(diff) <= max_diff:\n   return message + diff\n  return message + (DIFF_OMITTED % len(diff))\n  \n def assertListEqual(self, list1, list2, msg=None):\n  \"\"\n  self.assertSequenceEqual(list1, list2, msg, seq_type=list)\n  \n def assertTupleEqual(self, tuple1, tuple2, msg=None):\n  \"\"\n  self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)\n  \n def assertSetEqual(self, set1, set2, msg=None):\n  \"\"\n  try:\n   difference1 = set1.difference(set2)\n  except TypeError as e:\n   self.fail('invalid type when attempting set difference: %s' % e)\n  except AttributeError as e:\n   self.fail('first argument does not support set difference: %s' % e)\n   \n  try:\n   difference2 = set2.difference(set1)\n  except TypeError as e:\n   self.fail('invalid type when attempting set difference: %s' % e)\n  except AttributeError as e:\n   self.fail('second argument does not support set difference: %s' % e)\n   \n  if not (difference1 or difference2):\n   return\n   \n  lines = []\n  if difference1:\n   lines.append('Items in the first set but not the second:')\n   for item in difference1:\n    lines.append(repr(item))\n  if difference2:\n   lines.append('Items in the second set but not the first:')\n   for item in difference2:\n    lines.append(repr(item))\n    \n  standardMsg = '\\n'.join(lines)\n  self.fail(self._formatMessage(msg, standardMsg))\n  \n def assertIn(self, member, container, msg=None):\n  \"\"\n  if member not in container:\n   standardMsg = '%s not found in %s' % (safe_repr(member),\n   safe_repr(container))\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertNotIn(self, member, container, msg=None):\n  \"\"\n  if member in container:\n   standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),\n   safe_repr(container))\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertIs(self, expr1, expr2, msg=None):\n  \"\"\n  if expr1 is not expr2:\n   standardMsg = '%s is not %s' % (safe_repr(expr1),\n   safe_repr(expr2))\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertIsNot(self, expr1, expr2, msg=None):\n  \"\"\n  if expr1 is expr2:\n   standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertDictEqual(self, d1, d2, msg=None):\n  self.assertIsInstance(d1, dict, 'First argument is not a dictionary')\n  self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')\n  \n  if d1 != d2:\n   standardMsg = '%s != %s' % (safe_repr(d1, True), safe_repr(d2, True))\n   diff = ('\\n' + '\\n'.join(difflib.ndiff(\n   pprint.pformat(d1).splitlines(),\n   pprint.pformat(d2).splitlines())))\n   standardMsg = self._truncateMessage(standardMsg, diff)\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertDictContainsSubset(self, subset, dictionary, msg=None):\n  \"\"\n  warnings.warn('assertDictContainsSubset is deprecated',\n  DeprecationWarning)\n  missing = []\n  mismatched = []\n  for key, value in subset.items():\n   if key not in dictionary:\n    missing.append(key)\n   elif value != dictionary[key]:\n    mismatched.append('%s, expected: %s, actual: %s' %\n    (safe_repr(key), safe_repr(value),\n    safe_repr(dictionary[key])))\n    \n  if not (missing or mismatched):\n   return\n   \n  standardMsg = ''\n  if missing:\n   standardMsg = 'Missing: %s' % ','.join(safe_repr(m) for m in\n   missing)\n  if mismatched:\n   if standardMsg:\n    standardMsg += '; '\n   standardMsg += 'Mismatched values: %s' % ','.join(mismatched)\n   \n  self.fail(self._formatMessage(msg, standardMsg))\n  \n  \n def assertCountEqual(self, first, second, msg=None):\n  \"\"\n  first_seq, second_seq = list(first), list(second)\n  try:\n   first = collections.Counter(first_seq)\n   second = collections.Counter(second_seq)\n  except TypeError:\n  \n   differences = _count_diff_all_purpose(first_seq, second_seq)\n  else:\n   if first == second:\n    return\n   differences = _count_diff_hashable(first_seq, second_seq)\n   \n  if differences:\n   standardMsg = 'Element counts were not equal:\\n'\n   lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]\n   diffMsg = '\\n'.join(lines)\n   standardMsg = self._truncateMessage(standardMsg, diffMsg)\n   msg = self._formatMessage(msg, standardMsg)\n   self.fail(msg)\n   \n def assertMultiLineEqual(self, first, second, msg=None):\n  \"\"\n  self.assertIsInstance(first, str, 'First argument is not a string')\n  self.assertIsInstance(second, str, 'Second argument is not a string')\n  \n  if first != second:\n  \n   if (len(first) > self._diffThreshold or\n   len(second) > self._diffThreshold):\n    self._baseAssertEqual(first, second, msg)\n   firstlines = first.splitlines(keepends=True)\n   secondlines = second.splitlines(keepends=True)\n   if len(firstlines) == 1 and first.strip('\\r\\n') == first:\n    firstlines = [first + '\\n']\n    secondlines = [second + '\\n']\n   standardMsg = '%s != %s' % (safe_repr(first, True),\n   safe_repr(second, True))\n   diff = '\\n' + ''.join(difflib.ndiff(firstlines, secondlines))\n   standardMsg = self._truncateMessage(standardMsg, diff)\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertLess(self, a, b, msg=None):\n  \"\"\n  if not a < b:\n   standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertLessEqual(self, a, b, msg=None):\n  \"\"\n  if not a <= b:\n   standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertGreater(self, a, b, msg=None):\n  \"\"\n  if not a > b:\n   standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertGreaterEqual(self, a, b, msg=None):\n  \"\"\n  if not a >= b:\n   standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertIsNone(self, obj, msg=None):\n  \"\"\n  if obj is not None:\n   standardMsg = '%s is not None' % (safe_repr(obj),)\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertIsNotNone(self, obj, msg=None):\n  \"\"\n  if obj is None:\n   standardMsg = 'unexpectedly None'\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertIsInstance(self, obj, cls, msg=None):\n  \"\"\n  if not isinstance(obj, cls):\n   standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertNotIsInstance(self, obj, cls, msg=None):\n  \"\"\n  if isinstance(obj, cls):\n   standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)\n   self.fail(self._formatMessage(msg, standardMsg))\n   \n def assertRaisesRegex(self, expected_exception, expected_regex,\n callable_obj=None, *args, **kwargs):\n  \"\"\n  context = _AssertRaisesContext(expected_exception, self, callable_obj,\n  expected_regex)\n  \n  return context.handle('assertRaisesRegex', callable_obj, args, kwargs)\n  \n def assertWarnsRegex(self, expected_warning, expected_regex,\n callable_obj=None, *args, **kwargs):\n  \"\"\n  context = _AssertWarnsContext(expected_warning, self, callable_obj,\n  expected_regex)\n  return context.handle('assertWarnsRegex', callable_obj, args, kwargs)\n  \n def assertRegex(self, text, expected_regex, msg=None):\n  \"\"\n  if isinstance(expected_regex, (str, bytes)):\n   assert expected_regex, \"expected_regex must not be empty.\"\n   expected_regex = re.compile(expected_regex)\n  if not expected_regex.search(text):\n   msg = msg or \"Regex didn't match\"\n   msg = '%s: %r not found in %r' % (msg, expected_regex.pattern, text)\n   raise self.failureException(msg)\n   \n def assertNotRegex(self, text, unexpected_regex, msg=None):\n  \"\"\n  if isinstance(unexpected_regex, (str, bytes)):\n   unexpected_regex = re.compile(unexpected_regex)\n  match = unexpected_regex.search(text)\n  if match:\n   msg = msg or \"Regex matched\"\n   msg = '%s: %r matches %r in %r' % (msg,\n   text[match.start():match.end()],\n   unexpected_regex.pattern,\n   text)\n   raise self.failureException(msg)\n   \n   \n def _deprecate(original_func):\n  def deprecated_func(*args, **kwargs):\n   warnings.warn(\n   'Please use {0} instead.'.format(original_func.__name__),\n   DeprecationWarning, 2)\n   return original_func(*args, **kwargs)\n  return deprecated_func\n  \n  \n failUnlessEqual = assertEquals = _deprecate(assertEqual)\n failIfEqual = assertNotEquals = _deprecate(assertNotEqual)\n failUnlessAlmostEqual = assertAlmostEquals = _deprecate(assertAlmostEqual)\n failIfAlmostEqual = assertNotAlmostEquals = _deprecate(assertNotAlmostEqual)\n failUnless = assert_ = _deprecate(assertTrue)\n failUnlessRaises = _deprecate(assertRaises)\n failIf = _deprecate(assertFalse)\n assertRaisesRegexp = _deprecate(assertRaisesRegex)\n assertRegexpMatches = _deprecate(assertRegex)\n \n \n \nclass FunctionTestCase(TestCase):\n \"\"\n \n def __init__(self, testFunc, setUp=None, tearDown=None, description=None):\n  super(FunctionTestCase, self).__init__()\n  self._setUpFunc = setUp\n  self._tearDownFunc = tearDown\n  self._testFunc = testFunc\n  self._description = description\n  \n def setUp(self):\n  if self._setUpFunc is not None:\n   self._setUpFunc()\n   \n def tearDown(self):\n  if self._tearDownFunc is not None:\n   self._tearDownFunc()\n   \n def runTest(self):\n  self._testFunc()\n  \n def id(self):\n  return self._testFunc.__name__\n  \n def __eq__(self, other):\n  if not isinstance(other, self.__class__):\n   return NotImplemented\n   \n  return self._setUpFunc == other._setUpFunc and self._tearDownFunc == other._tearDownFunc and self._testFunc == other._testFunc and self._description == other._description\n  \n def __ne__(self, other):\n  return not self == other\n  \n def __hash__(self):\n  return hash((type(self), self._setUpFunc, self._tearDownFunc,\n  self._testFunc, self._description))\n  \n def __str__(self):\n  return \"%s (%s)\" % (strclass(self.__class__),\n  self._testFunc.__name__)\n  \n def __repr__(self):\n  return \"<%s tec=%s>\" % (strclass(self.__class__),\n  self._testFunc)\n  \n def shortDescription(self):\n  if self._description is not None:\n   return self._description\n  doc = self._testFunc.__doc__\n  return doc and doc.split(\"\\n\")[0].strip() or None\n"], "unittest.test.test_suite": ["import unittest\n\nimport sys\nfrom .support import LoggingResult, TestEquality\n\n\n\n\n\nclass Test(object):\n class Foo(unittest.TestCase):\n  def test_1(self): pass\n  def test_2(self): pass\n  def test_3(self): pass\n  def runTest(self): pass\n  \ndef _mk_TestSuite(*names):\n return unittest.TestSuite(Test.Foo(n) for n in names)\n \n \n \n \nclass Test_TestSuite(unittest.TestCase, TestEquality):\n\n\n\n\n\n eq_pairs = [(unittest.TestSuite(), unittest.TestSuite())\n ,(unittest.TestSuite(), unittest.TestSuite([]))\n ,(_mk_TestSuite('test_1'), _mk_TestSuite('test_1'))]\n \n \n ne_pairs = [(unittest.TestSuite(), _mk_TestSuite('test_1'))\n ,(unittest.TestSuite([]), _mk_TestSuite('test_1'))\n ,(_mk_TestSuite('test_1', 'test_2'), _mk_TestSuite('test_1', 'test_3'))\n ,(_mk_TestSuite('test_1'), _mk_TestSuite('test_2'))]\n \n \n \n \n \n \n \n \n \n \n def test_init__tests_optional(self):\n  suite = unittest.TestSuite()\n  \n  self.assertEqual(suite.countTestCases(), 0)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_init__empty_tests(self):\n  suite = unittest.TestSuite([])\n  \n  self.assertEqual(suite.countTestCases(), 0)\n  \n  \n  \n  \n  \n  \n  \n def test_init__tests_from_any_iterable(self):\n  def tests():\n   yield unittest.FunctionTestCase(lambda: None)\n   yield unittest.FunctionTestCase(lambda: None)\n   \n  suite_1 = unittest.TestSuite(tests())\n  self.assertEqual(suite_1.countTestCases(), 2)\n  \n  suite_2 = unittest.TestSuite(suite_1)\n  self.assertEqual(suite_2.countTestCases(), 2)\n  \n  suite_3 = unittest.TestSuite(set(suite_1))\n  self.assertEqual(suite_3.countTestCases(), 2)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_init__TestSuite_instances_in_tests(self):\n  def tests():\n   ftc = unittest.FunctionTestCase(lambda: None)\n   yield unittest.TestSuite([ftc])\n   yield unittest.FunctionTestCase(lambda: None)\n   \n  suite = unittest.TestSuite(tests())\n  self.assertEqual(suite.countTestCases(), 2)\n  \n  \n  \n  \n  \n def test_iter(self):\n  test1 = unittest.FunctionTestCase(lambda: None)\n  test2 = unittest.FunctionTestCase(lambda: None)\n  suite = unittest.TestSuite((test1, test2))\n  \n  self.assertEqual(list(suite), [test1, test2])\n  \n  \n  \n  \n  \n  \n def test_countTestCases_zero_simple(self):\n  suite = unittest.TestSuite()\n  \n  self.assertEqual(suite.countTestCases(), 0)\n  \n  \n  \n  \n  \n  \n  \n def test_countTestCases_zero_nested(self):\n  class Test1(unittest.TestCase):\n   def test(self):\n    pass\n    \n  suite = unittest.TestSuite([unittest.TestSuite()])\n  \n  self.assertEqual(suite.countTestCases(), 0)\n  \n  \n  \n  \n def test_countTestCases_simple(self):\n  test1 = unittest.FunctionTestCase(lambda: None)\n  test2 = unittest.FunctionTestCase(lambda: None)\n  suite = unittest.TestSuite((test1, test2))\n  \n  self.assertEqual(suite.countTestCases(), 2)\n  \n  \n  \n  \n  \n  \n def test_countTestCases_nested(self):\n  class Test1(unittest.TestCase):\n   def test1(self): pass\n   def test2(self): pass\n   \n  test2 = unittest.FunctionTestCase(lambda: None)\n  test3 = unittest.FunctionTestCase(lambda: None)\n  child = unittest.TestSuite((Test1('test2'), test2))\n  parent = unittest.TestSuite((test3, child, Test1('test1')))\n  \n  self.assertEqual(parent.countTestCases(), 4)\n  \n  \n  \n  \n  \n def test_run__empty_suite(self):\n  events = []\n  result = LoggingResult(events)\n  \n  suite = unittest.TestSuite()\n  \n  suite.run(result)\n  \n  self.assertEqual(events, [])\n  \n  \n  \n def test_run__requires_result(self):\n  suite = unittest.TestSuite()\n  \n  try:\n   suite.run()\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Failed to raise TypeError\")\n   \n   \n   \n def test_run(self):\n  events = []\n  result = LoggingResult(events)\n  \n  class LoggingCase(unittest.TestCase):\n   def run(self, result):\n    events.append('run %s' % self._testMethodName)\n    \n   def test1(self): pass\n   def test2(self): pass\n   \n  tests = [LoggingCase('test1'), LoggingCase('test2')]\n  \n  unittest.TestSuite(tests).run(result)\n  \n  self.assertEqual(events, ['run test1', 'run test2'])\n  \n  \n def test_addTest__TestCase(self):\n  class Foo(unittest.TestCase):\n   def test(self): pass\n   \n  test = Foo('test')\n  suite = unittest.TestSuite()\n  \n  suite.addTest(test)\n  \n  self.assertEqual(suite.countTestCases(), 1)\n  self.assertEqual(list(suite), [test])\n  \n  \n def test_addTest__TestSuite(self):\n  class Foo(unittest.TestCase):\n   def test(self): pass\n   \n  suite_2 = unittest.TestSuite([Foo('test')])\n  \n  suite = unittest.TestSuite()\n  suite.addTest(suite_2)\n  \n  self.assertEqual(suite.countTestCases(), 1)\n  self.assertEqual(list(suite), [suite_2])\n  \n  \n  \n  \n  \n  \n def test_addTests(self):\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   \n  test_1 = Foo('test_1')\n  test_2 = Foo('test_2')\n  inner_suite = unittest.TestSuite([test_2])\n  \n  def gen():\n   yield test_1\n   yield test_2\n   yield inner_suite\n   \n  suite_1 = unittest.TestSuite()\n  suite_1.addTests(gen())\n  \n  self.assertEqual(list(suite_1), list(gen()))\n  \n  \n  \n  suite_2 = unittest.TestSuite()\n  for t in gen():\n   suite_2.addTest(t)\n   \n  self.assertEqual(suite_1, suite_2)\n  \n  \n  \n  \n  \n def test_addTest__noniterable(self):\n  suite = unittest.TestSuite()\n  \n  try:\n   suite.addTests(5)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Failed to raise TypeError\")\n   \n def test_addTest__noncallable(self):\n  suite = unittest.TestSuite()\n  self.assertRaises(TypeError, suite.addTest, 5)\n  \n def test_addTest__casesuiteclass(self):\n  suite = unittest.TestSuite()\n  self.assertRaises(TypeError, suite.addTest, Test_TestSuite)\n  self.assertRaises(TypeError, suite.addTest, unittest.TestSuite)\n  \n def test_addTests__string(self):\n  suite = unittest.TestSuite()\n  self.assertRaises(TypeError, suite.addTests, \"foo\")\n  \n def test_function_in_suite(self):\n  def f(_):\n   pass\n  suite = unittest.TestSuite()\n  suite.addTest(f)\n  \n  \n  suite.run(unittest.TestResult())\n  \n  \n  \n def test_basetestsuite(self):\n  class Test(unittest.TestCase):\n   wasSetUp = False\n   wasTornDown = False\n   @classmethod\n   def setUpClass(cls):\n    cls.wasSetUp = True\n   @classmethod\n   def tearDownClass(cls):\n    cls.wasTornDown = True\n   def testPass(self):\n    pass\n   def testFail(self):\n    fail\n  class Module(object):\n   wasSetUp = False\n   wasTornDown = False\n   @staticmethod\n   def setUpModule():\n    Module.wasSetUp = True\n   @staticmethod\n   def tearDownModule():\n    Module.wasTornDown = True\n    \n  Test.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  self.addCleanup(sys.modules.pop, 'Module')\n  \n  suite = unittest.BaseTestSuite()\n  suite.addTests([Test('testPass'), Test('testFail')])\n  self.assertEqual(suite.countTestCases(), 2)\n  \n  result = unittest.TestResult()\n  suite.run(result)\n  self.assertFalse(Module.wasSetUp)\n  self.assertFalse(Module.wasTornDown)\n  self.assertFalse(Test.wasSetUp)\n  self.assertFalse(Test.wasTornDown)\n  self.assertEqual(len(result.errors), 1)\n  self.assertEqual(len(result.failures), 0)\n  self.assertEqual(result.testsRun, 2)\n  \n  \n def test_overriding_call(self):\n  class MySuite(unittest.TestSuite):\n   called = False\n   def __call__(self, *args, **kw):\n    self.called = True\n    unittest.TestSuite.__call__(self, *args, **kw)\n    \n  suite = MySuite()\n  result = unittest.TestResult()\n  wrapper = unittest.TestSuite()\n  wrapper.addTest(suite)\n  wrapper(result)\n  self.assertTrue(suite.called)\n  \n  \n  self.assertFalse(result._testRunEntered)\n  \n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.test.testmock.testmagicmethods": ["import unittest\nimport inspect\nimport sys\nfrom unittest.mock import Mock, MagicMock, _magics\n\n\n\nclass TestMockingMagicMethods(unittest.TestCase):\n\n def test_deleting_magic_methods(self):\n  mock = Mock()\n  self.assertFalse(hasattr(mock, '__getitem__'))\n  \n  mock.__getitem__ = Mock()\n  self.assertTrue(hasattr(mock, '__getitem__'))\n  \n  del mock.__getitem__\n  self.assertFalse(hasattr(mock, '__getitem__'))\n  \n  \n def test_magicmock_del(self):\n  mock = MagicMock()\n  \n  del mock.__getitem__\n  self.assertRaises(TypeError, lambda: mock['foo'])\n  \n  mock = MagicMock()\n  \n  mock['foo']\n  del mock.__getitem__\n  self.assertRaises(TypeError, lambda: mock['foo'])\n  \n  \n def test_magic_method_wrapping(self):\n  mock = Mock()\n  def f(self, name):\n   return self, 'fish'\n   \n  mock.__getitem__ = f\n  self.assertFalse(mock.__getitem__ is f)\n  self.assertEqual(mock['foo'], (mock, 'fish'))\n  self.assertEqual(mock.__getitem__('foo'), (mock, 'fish'))\n  \n  mock.__getitem__ = mock\n  self.assertTrue(mock.__getitem__ is mock)\n  \n  \n def test_magic_methods_isolated_between_mocks(self):\n  mock1 = Mock()\n  mock2 = Mock()\n  \n  mock1.__iter__ = Mock(return_value=iter([]))\n  self.assertEqual(list(mock1), [])\n  self.assertRaises(TypeError, lambda: list(mock2))\n  \n  \n def test_repr(self):\n  mock = Mock()\n  self.assertEqual(repr(mock), \"<Mock id='%s'>\" % id(mock))\n  mock.__repr__ = lambda s: 'foo'\n  self.assertEqual(repr(mock), 'foo')\n  \n  \n def test_str(self):\n  mock = Mock()\n  self.assertEqual(str(mock), object.__str__(mock))\n  mock.__str__ = lambda s: 'foo'\n  self.assertEqual(str(mock), 'foo')\n  \n  \n def test_dict_methods(self):\n  mock = Mock()\n  \n  self.assertRaises(TypeError, lambda: mock['foo'])\n  def _del():\n   del mock['foo']\n  def _set():\n   mock['foo'] = 3\n  self.assertRaises(TypeError, _del)\n  self.assertRaises(TypeError, _set)\n  \n  _dict = {}\n  def getitem(s, name):\n   return _dict[name]\n  def setitem(s, name, value):\n   _dict[name] = value\n  def delitem(s, name):\n   del _dict[name]\n   \n  mock.__setitem__ = setitem\n  mock.__getitem__ = getitem\n  mock.__delitem__ = delitem\n  \n  self.assertRaises(KeyError, lambda: mock['foo'])\n  mock['foo'] = 'bar'\n  self.assertEqual(_dict, {'foo': 'bar'})\n  self.assertEqual(mock['foo'], 'bar')\n  del mock['foo']\n  self.assertEqual(_dict, {})\n  \n  \n def test_numeric(self):\n  original = mock = Mock()\n  mock.value = 0\n  \n  self.assertRaises(TypeError, lambda: mock + 3)\n  \n  def add(self, other):\n   mock.value += other\n   return self\n  mock.__add__ = add\n  self.assertEqual(mock + 3, mock)\n  self.assertEqual(mock.value, 3)\n  \n  del mock.__add__\n  def iadd(mock):\n   mock += 3\n  self.assertRaises(TypeError, iadd, mock)\n  mock.__iadd__ = add\n  mock += 6\n  self.assertEqual(mock, original)\n  self.assertEqual(mock.value, 9)\n  \n  self.assertRaises(TypeError, lambda: 3 + mock)\n  mock.__radd__ = add\n  self.assertEqual(7 + mock, mock)\n  self.assertEqual(mock.value, 16)\n  \n  \n def test_hash(self):\n  mock = Mock()\n  \n  self.assertEqual(hash(mock), Mock.__hash__(mock))\n  \n  def _hash(s):\n   return 3\n  mock.__hash__ = _hash\n  self.assertEqual(hash(mock), 3)\n  \n  \n def test_nonzero(self):\n  m = Mock()\n  self.assertTrue(bool(m))\n  \n  m.__bool__ = lambda s: False\n  self.assertFalse(bool(m))\n  \n  \n def test_comparison(self):\n  mock = Mock()\n  def comp(s, o):\n   return True\n  mock.__lt__ = mock.__gt__ = mock.__le__ = mock.__ge__ = comp\n  self. assertTrue(mock < 3)\n  self. assertTrue(mock > 3)\n  self. assertTrue(mock <= 3)\n  self. assertTrue(mock >= 3)\n  \n  self.assertRaises(TypeError, lambda: MagicMock() < object())\n  self.assertRaises(TypeError, lambda: object() < MagicMock())\n  self.assertRaises(TypeError, lambda: MagicMock() < MagicMock())\n  self.assertRaises(TypeError, lambda: MagicMock() > object())\n  self.assertRaises(TypeError, lambda: object() > MagicMock())\n  self.assertRaises(TypeError, lambda: MagicMock() > MagicMock())\n  self.assertRaises(TypeError, lambda: MagicMock() <= object())\n  self.assertRaises(TypeError, lambda: object() <= MagicMock())\n  self.assertRaises(TypeError, lambda: MagicMock() <= MagicMock())\n  self.assertRaises(TypeError, lambda: MagicMock() >= object())\n  self.assertRaises(TypeError, lambda: object() >= MagicMock())\n  self.assertRaises(TypeError, lambda: MagicMock() >= MagicMock())\n  \n  \n def test_equality(self):\n  for mock in Mock(), MagicMock():\n   self.assertEqual(mock == mock, True)\n   self.assertIsInstance(mock == mock, bool)\n   self.assertEqual(mock != mock, False)\n   self.assertIsInstance(mock != mock, bool)\n   self.assertEqual(mock == object(), False)\n   self.assertEqual(mock != object(), True)\n   \n   def eq(self, other):\n    return other == 3\n   mock.__eq__ = eq\n   self.assertTrue(mock == 3)\n   self.assertFalse(mock == 4)\n   \n   def ne(self, other):\n    return other == 3\n   mock.__ne__ = ne\n   self.assertTrue(mock != 3)\n   self.assertFalse(mock != 4)\n   \n  mock = MagicMock()\n  mock.__eq__.return_value = True\n  self.assertIsInstance(mock == 3, bool)\n  self.assertEqual(mock == 3, True)\n  \n  mock.__ne__.return_value = False\n  self.assertIsInstance(mock != 3, bool)\n  self.assertEqual(mock != 3, False)\n  \n  \n def test_len_contains_iter(self):\n  mock = Mock()\n  \n  self.assertRaises(TypeError, len, mock)\n  self.assertRaises(TypeError, iter, mock)\n  self.assertRaises(TypeError, lambda: 'foo' in mock)\n  \n  mock.__len__ = lambda s: 6\n  self.assertEqual(len(mock), 6)\n  \n  mock.__contains__ = lambda s, o: o == 3\n  self.assertTrue(3 in mock)\n  self.assertFalse(6 in mock)\n  \n  mock.__iter__ = lambda s: iter('foobarbaz')\n  self.assertEqual(list(mock), list('foobarbaz'))\n  \n  \n def test_magicmock(self):\n  mock = MagicMock()\n  \n  mock.__iter__.return_value = iter([1, 2, 3])\n  self.assertEqual(list(mock), [1, 2, 3])\n  \n  getattr(mock, '__bool__').return_value = False\n  self.assertFalse(hasattr(mock, '__nonzero__'))\n  self.assertFalse(bool(mock))\n  \n  for entry in _magics:\n   self.assertTrue(hasattr(mock, entry))\n  self.assertFalse(hasattr(mock, '__imaginery__'))\n  \n  \n def test_magic_mock_equality(self):\n  mock = MagicMock()\n  self.assertIsInstance(mock == object(), bool)\n  self.assertIsInstance(mock != object(), bool)\n  \n  self.assertEqual(mock == object(), False)\n  self.assertEqual(mock != object(), True)\n  self.assertEqual(mock == mock, True)\n  self.assertEqual(mock != mock, False)\n  \n  \n def test_magicmock_defaults(self):\n  mock = MagicMock()\n  self.assertEqual(int(mock), 1)\n  self.assertEqual(complex(mock), 1j)\n  self.assertEqual(float(mock), 1.0)\n  self.assertNotIn(object(), mock)\n  self.assertEqual(len(mock), 0)\n  self.assertEqual(list(mock), [])\n  self.assertEqual(hash(mock), object.__hash__(mock))\n  self.assertEqual(str(mock), object.__str__(mock))\n  self.assertTrue(bool(mock))\n  \n  \n  \n  self.assertEqual(oct(mock), '0o1')\n  self.assertEqual(hex(mock), '0x1')\n  \n  \n  \n def test_magic_methods_and_spec(self):\n  class Iterable(object):\n   def __iter__(self):\n    pass\n    \n  mock = Mock(spec=Iterable)\n  self.assertRaises(AttributeError, lambda: mock.__iter__)\n  \n  mock.__iter__ = Mock(return_value=iter([]))\n  self.assertEqual(list(mock), [])\n  \n  class NonIterable(object):\n   pass\n  mock = Mock(spec=NonIterable)\n  self.assertRaises(AttributeError, lambda: mock.__iter__)\n  \n  def set_int():\n   mock.__int__ = Mock(return_value=iter([]))\n  self.assertRaises(AttributeError, set_int)\n  \n  mock = MagicMock(spec=Iterable)\n  self.assertEqual(list(mock), [])\n  self.assertRaises(AttributeError, set_int)\n  \n  \n def test_magic_methods_and_spec_set(self):\n  class Iterable(object):\n   def __iter__(self):\n    pass\n    \n  mock = Mock(spec_set=Iterable)\n  self.assertRaises(AttributeError, lambda: mock.__iter__)\n  \n  mock.__iter__ = Mock(return_value=iter([]))\n  self.assertEqual(list(mock), [])\n  \n  class NonIterable(object):\n   pass\n  mock = Mock(spec_set=NonIterable)\n  self.assertRaises(AttributeError, lambda: mock.__iter__)\n  \n  def set_int():\n   mock.__int__ = Mock(return_value=iter([]))\n  self.assertRaises(AttributeError, set_int)\n  \n  mock = MagicMock(spec_set=Iterable)\n  self.assertEqual(list(mock), [])\n  self.assertRaises(AttributeError, set_int)\n  \n  \n def test_setting_unsupported_magic_method(self):\n  mock = MagicMock()\n  def set_setattr():\n   mock.__setattr__ = lambda self, name: None\n  self.assertRaisesRegex(AttributeError,\n  \"Attempting to set unsupported magic method '__setattr__'.\",\n  set_setattr\n  )\n  \n  \n def test_attributes_and_return_value(self):\n  mock = MagicMock()\n  attr = mock.foo\n  def _get_type(obj):\n  \n  \n   return type(obj).__mro__[1]\n  self.assertEqual(_get_type(attr), MagicMock)\n  \n  returned = mock()\n  self.assertEqual(_get_type(returned), MagicMock)\n  \n  \n def test_magic_methods_are_magic_mocks(self):\n  mock = MagicMock()\n  self.assertIsInstance(mock.__getitem__, MagicMock)\n  \n  mock[1][2].__getitem__.return_value = 3\n  self.assertEqual(mock[1][2][3], 3)\n  \n  \n def test_magic_method_reset_mock(self):\n  mock = MagicMock()\n  str(mock)\n  self.assertTrue(mock.__str__.called)\n  mock.reset_mock()\n  self.assertFalse(mock.__str__.called)\n  \n  \n def test_dir(self):\n \n  for mock in Mock(), MagicMock():\n   def _dir(self):\n    return ['foo']\n   mock.__dir__ = _dir\n   self.assertEqual(dir(mock), ['foo'])\n   \n   \n @unittest.skipIf('PyPy' in sys.version, \"This fails differently on pypy\")\n def test_bound_methods(self):\n  m = Mock()\n  \n  \n  \n  \n  \n  m.__iter__ = [3].__iter__\n  self.assertRaises(TypeError, iter, m)\n  \n  \n def test_magic_method_type(self):\n  class Foo(MagicMock):\n   pass\n   \n  foo = Foo()\n  self.assertIsInstance(foo.__int__, Foo)\n  \n  \n def test_descriptor_from_class(self):\n  m = MagicMock()\n  type(m).__str__.return_value = 'foo'\n  self.assertEqual(str(m), 'foo')\n  \n  \n def test_iterable_as_iter_return_value(self):\n  m = MagicMock()\n  m.__iter__.return_value = [1, 2, 3]\n  self.assertEqual(list(m), [1, 2, 3])\n  self.assertEqual(list(m), [1, 2, 3])\n  \n  m.__iter__.return_value = iter([4, 5, 6])\n  self.assertEqual(list(m), [4, 5, 6])\n  self.assertEqual(list(m), [])\n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.test.test_loader": ["import sys\nimport types\n\n\nimport unittest\n\n\nclass Test_TestLoader(unittest.TestCase):\n\n\n\n\n\n\n def test_loadTestsFromTestCase(self):\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n   \n  tests = unittest.TestSuite([Foo('test_1'), Foo('test_2')])\n  \n  loader = unittest.TestLoader()\n  self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)\n  \n  \n  \n  \n  \n def test_loadTestsFromTestCase__no_matches(self):\n  class Foo(unittest.TestCase):\n   def foo_bar(self): pass\n   \n  empty_suite = unittest.TestSuite()\n  \n  loader = unittest.TestLoader()\n  self.assertEqual(loader.loadTestsFromTestCase(Foo), empty_suite)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromTestCase__TestSuite_subclass(self):\n  class NotATestCase(unittest.TestSuite):\n   pass\n   \n  loader = unittest.TestLoader()\n  try:\n   loader.loadTestsFromTestCase(NotATestCase)\n  except TypeError:\n   pass\n  else:\n   self.fail('Should raise TypeError')\n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromTestCase__default_method_name(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n    \n  loader = unittest.TestLoader()\n  \n  self.assertFalse('runTest'.startswith(loader.testMethodPrefix))\n  \n  suite = loader.loadTestsFromTestCase(Foo)\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [Foo('runTest')])\n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromModule__TestCase_subclass(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  expected = [loader.suiteClass([MyTestCase('test')])]\n  self.assertEqual(list(suite), expected)\n  \n  \n  \n  \n def test_loadTestsFromModule__no_TestCase_instances(self):\n  m = types.ModuleType('m')\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [])\n  \n  \n  \n  \n def test_loadTestsFromModule__no_TestCase_tests(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  self.assertEqual(list(suite), [loader.suiteClass()])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromModule__not_a_module(self):\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n    \n  class NotAModule(object):\n   test_2 = MyTestCase\n   \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromModule(NotAModule)\n  \n  reference = [unittest.TestSuite([MyTestCase('test')])]\n  self.assertEqual(list(suite), reference)\n  \n  \n  \n  \n def test_loadTestsFromModule__load_tests(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  load_tests_args = []\n  def load_tests(loader, tests, pattern):\n   self.assertIsInstance(tests, unittest.TestSuite)\n   load_tests_args.extend((loader, tests, pattern))\n   return tests\n  m.load_tests = load_tests\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite, unittest.TestSuite)\n  self.assertEqual(load_tests_args, [loader, suite, None])\n  \n  load_tests_args = []\n  suite = loader.loadTestsFromModule(m, use_load_tests=False)\n  self.assertEqual(load_tests_args, [])\n  \n def test_loadTestsFromModule__faulty_load_tests(self):\n  m = types.ModuleType('m')\n  \n  def load_tests(loader, tests, pattern):\n   raise TypeError('some failure')\n  m.load_tests = load_tests\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite, unittest.TestSuite)\n  self.assertEqual(suite.countTestCases(), 1)\n  test = list(suite)[0]\n  \n  self.assertRaisesRegex(TypeError, \"some failure\", test.m)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromName__empty_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromName('')\n  except ValueError as e:\n   self.assertEqual(str(e), \"Empty module name\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ValueError\")\n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromName__malformed_name(self):\n  loader = unittest.TestLoader()\n  \n  \n  try:\n   loader.loadTestsFromName('abc () //')\n  except ValueError:\n   pass\n  except ImportError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ValueError\")\n   \n   \n   \n   \n   \n def test_loadTestsFromName__unknown_module_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromName('sdasfasfasdf')\n  except ImportError as e:\n   self.assertEqual(str(e), \"No module named 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ImportError\")\n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromName__unknown_attr_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromName('unittest.sdasfasfasdf')\n  except AttributeError as e:\n   self.assertEqual(str(e), \"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromName__relative_unknown_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromName('sdasfasfasdf', unittest)\n  except AttributeError as e:\n   self.assertEqual(str(e), \"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromName__relative_empty_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromName('', unittest)\n  except AttributeError as e:\n   pass\n  else:\n   self.fail(\"Failed to raise AttributeError\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromName__relative_malformed_name(self):\n  loader = unittest.TestLoader()\n  \n  \n  try:\n   loader.loadTestsFromName('abc () //', unittest)\n  except ValueError:\n   pass\n  except AttributeError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ValueError\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromName__relative_not_a_module(self):\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n    \n  class NotAModule(object):\n   test_2 = MyTestCase\n   \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromName('test_2', NotAModule)\n  \n  reference = [MyTestCase('test')]\n  self.assertEqual(list(suite), reference)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromName__relative_bad_object(self):\n  m = types.ModuleType('m')\n  m.testcase_1 = object()\n  \n  loader = unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('testcase_1', m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Should have raised TypeError\")\n   \n   \n   \n def test_loadTestsFromName__relative_TestCase_subclass(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromName('testcase_1', m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [MyTestCase('test')])\n  \n  \n  \n  \n  \n def test_loadTestsFromName__relative_TestSuite(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testsuite = unittest.TestSuite([MyTestCase('test')])\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromName('testsuite', m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  self.assertEqual(list(suite), [MyTestCase('test')])\n  \n  \n  \n def test_loadTestsFromName__relative_testmethod(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromName('testcase_1.test', m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  self.assertEqual(list(suite), [MyTestCase('test')])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromName__relative_invalid_testmethod(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('testcase_1.testfoo', m)\n  except AttributeError as e:\n   self.assertEqual(str(e), \"type object 'MyTestCase' has no attribute 'testfoo'\")\n  else:\n   self.fail(\"Failed to raise AttributeError\")\n   \n   \n   \n def test_loadTestsFromName__callable__TestSuite(self):\n  m = types.ModuleType('m')\n  testcase_1 = unittest.FunctionTestCase(lambda: None)\n  testcase_2 = unittest.FunctionTestCase(lambda: None)\n  def return_TestSuite():\n   return unittest.TestSuite([testcase_1, testcase_2])\n  m.return_TestSuite = return_TestSuite\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromName('return_TestSuite', m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [testcase_1, testcase_2])\n  \n  \n  \n def test_loadTestsFromName__callable__TestCase_instance(self):\n  m = types.ModuleType('m')\n  testcase_1 = unittest.FunctionTestCase(lambda: None)\n  def return_TestCase():\n   return testcase_1\n  m.return_TestCase = return_TestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromName('return_TestCase', m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [testcase_1])\n  \n  \n  \n  \n  \n  \n def test_loadTestsFromName__callable__TestCase_instance_ProperSuiteClass(self):\n  class SubTestSuite(unittest.TestSuite):\n   pass\n  m = types.ModuleType('m')\n  testcase_1 = unittest.FunctionTestCase(lambda: None)\n  def return_TestCase():\n   return testcase_1\n  m.return_TestCase = return_TestCase\n  \n  loader = unittest.TestLoader()\n  loader.suiteClass = SubTestSuite\n  suite = loader.loadTestsFromName('return_TestCase', m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [testcase_1])\n  \n  \n  \n  \n  \n  \n def test_loadTestsFromName__relative_testmethod_ProperSuiteClass(self):\n  class SubTestSuite(unittest.TestSuite):\n   pass\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  loader.suiteClass=SubTestSuite\n  suite = loader.loadTestsFromName('testcase_1.test', m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  self.assertEqual(list(suite), [MyTestCase('test')])\n  \n  \n  \n  \n  \n def test_loadTestsFromName__callable__wrong_type(self):\n  m = types.ModuleType('m')\n  def return_wrong():\n   return 6\n  m.return_wrong = return_wrong\n  \n  loader = unittest.TestLoader()\n  try:\n   suite = loader.loadTestsFromName('return_wrong', m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise TypeError\")\n   \n   \n   \n def test_loadTestsFromName__module_not_loaded(self):\n \n \n \n  module_name = 'unittest.test.dummy'\n  sys.modules.pop(module_name, None)\n  \n  loader = unittest.TestLoader()\n  try:\n   suite = loader.loadTestsFromName(module_name)\n   \n   self.assertIsInstance(suite, loader.suiteClass)\n   self.assertEqual(list(suite), [])\n   \n   \n   self.assertIn(module_name, sys.modules)\n  finally:\n   if module_name in sys.modules:\n    del sys.modules[module_name]\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n def test_loadTestsFromNames__empty_name_list(self):\n  loader = unittest.TestLoader()\n  \n  suite = loader.loadTestsFromNames([])\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromNames__relative_empty_name_list(self):\n  loader = unittest.TestLoader()\n  \n  suite = loader.loadTestsFromNames([], unittest)\n  self.assertIsInstance(suite, loader.suiteClass)\n  self.assertEqual(list(suite), [])\n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromNames__empty_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromNames([''])\n  except ValueError as e:\n   self.assertEqual(str(e), \"Empty module name\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ValueError\")\n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__malformed_name(self):\n  loader = unittest.TestLoader()\n  \n  \n  try:\n   loader.loadTestsFromNames(['abc () //'])\n  except ValueError:\n   pass\n  except ImportError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ValueError\")\n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__unknown_module_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromNames(['sdasfasfasdf'])\n  except ImportError as e:\n   self.assertEqual(str(e), \"No module named 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ImportError\")\n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__unknown_attr_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromNames(['unittest.sdasfasfasdf', 'unittest'])\n  except AttributeError as e:\n   self.assertEqual(str(e), \"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise AttributeError\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__unknown_name_relative_1(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromNames(['sdasfasfasdf'], unittest)\n  except AttributeError as e:\n   self.assertEqual(str(e), \"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__unknown_name_relative_2(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromNames(['TestCase', 'sdasfasfasdf'], unittest)\n  except AttributeError as e:\n   self.assertEqual(str(e), \"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__relative_empty_name(self):\n  loader = unittest.TestLoader()\n  \n  try:\n   loader.loadTestsFromNames([''], unittest)\n  except AttributeError:\n   pass\n  else:\n   self.fail(\"Failed to raise ValueError\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__relative_malformed_name(self):\n  loader = unittest.TestLoader()\n  \n  \n  try:\n   loader.loadTestsFromNames(['abc () //'], unittest)\n  except AttributeError:\n   pass\n  except ValueError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ValueError\")\n   \n   \n   \n   \n   \n   \n   \n   \n def test_loadTestsFromNames__relative_not_a_module(self):\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n    \n  class NotAModule(object):\n   test_2 = MyTestCase\n   \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromNames(['test_2'], NotAModule)\n  \n  reference = [unittest.TestSuite([MyTestCase('test')])]\n  self.assertEqual(list(suite), reference)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_loadTestsFromNames__relative_bad_object(self):\n  m = types.ModuleType('m')\n  m.testcase_1 = object()\n  \n  loader = unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['testcase_1'], m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Should have raised TypeError\")\n   \n   \n   \n def test_loadTestsFromNames__relative_TestCase_subclass(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromNames(['testcase_1'], m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  expected = loader.suiteClass([MyTestCase('test')])\n  self.assertEqual(list(suite), [expected])\n  \n  \n  \n def test_loadTestsFromNames__relative_TestSuite(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testsuite = unittest.TestSuite([MyTestCase('test')])\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromNames(['testsuite'], m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  self.assertEqual(list(suite), [m.testsuite])\n  \n  \n  \n def test_loadTestsFromNames__relative_testmethod(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromNames(['testcase_1.test'], m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  ref_suite = unittest.TestSuite([MyTestCase('test')])\n  self.assertEqual(list(suite), [ref_suite])\n  \n  \n  \n  \n  \n  \n def test_loadTestsFromNames__relative_invalid_testmethod(self):\n  m = types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1 = MyTestCase\n  \n  loader = unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['testcase_1.testfoo'], m)\n  except AttributeError as e:\n   self.assertEqual(str(e), \"type object 'MyTestCase' has no attribute 'testfoo'\")\n  else:\n   self.fail(\"Failed to raise AttributeError\")\n   \n   \n   \n def test_loadTestsFromNames__callable__TestSuite(self):\n  m = types.ModuleType('m')\n  testcase_1 = unittest.FunctionTestCase(lambda: None)\n  testcase_2 = unittest.FunctionTestCase(lambda: None)\n  def return_TestSuite():\n   return unittest.TestSuite([testcase_1, testcase_2])\n  m.return_TestSuite = return_TestSuite\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromNames(['return_TestSuite'], m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  expected = unittest.TestSuite([testcase_1, testcase_2])\n  self.assertEqual(list(suite), [expected])\n  \n  \n  \n def test_loadTestsFromNames__callable__TestCase_instance(self):\n  m = types.ModuleType('m')\n  testcase_1 = unittest.FunctionTestCase(lambda: None)\n  def return_TestCase():\n   return testcase_1\n  m.return_TestCase = return_TestCase\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromNames(['return_TestCase'], m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  ref_suite = unittest.TestSuite([testcase_1])\n  self.assertEqual(list(suite), [ref_suite])\n  \n  \n  \n  \n  \n def test_loadTestsFromNames__callable__call_staticmethod(self):\n  m = types.ModuleType('m')\n  class Test1(unittest.TestCase):\n   def test(self):\n    pass\n    \n  testcase_1 = Test1('test')\n  class Foo(unittest.TestCase):\n   @staticmethod\n   def foo():\n    return testcase_1\n  m.Foo = Foo\n  \n  loader = unittest.TestLoader()\n  suite = loader.loadTestsFromNames(['Foo.foo'], m)\n  self.assertIsInstance(suite, loader.suiteClass)\n  \n  ref_suite = unittest.TestSuite([testcase_1])\n  self.assertEqual(list(suite), [ref_suite])\n  \n  \n  \n  \n  \n def test_loadTestsFromNames__callable__wrong_type(self):\n  m = types.ModuleType('m')\n  def return_wrong():\n   return 6\n  m.return_wrong = return_wrong\n  \n  loader = unittest.TestLoader()\n  try:\n   suite = loader.loadTestsFromNames(['return_wrong'], m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise TypeError\")\n   \n   \n   \n def test_loadTestsFromNames__module_not_loaded(self):\n \n \n \n  module_name = 'unittest.test.dummy'\n  sys.modules.pop(module_name, None)\n  \n  loader = unittest.TestLoader()\n  try:\n   suite = loader.loadTestsFromNames([module_name])\n   \n   self.assertIsInstance(suite, loader.suiteClass)\n   self.assertEqual(list(suite), [unittest.TestSuite()])\n   \n   \n   self.assertIn(module_name, sys.modules)\n  finally:\n   if module_name in sys.modules:\n    del sys.modules[module_name]\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n def test_getTestCaseNames(self):\n  class Test(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foobar(self): pass\n   \n  loader = unittest.TestLoader()\n  \n  self.assertEqual(loader.getTestCaseNames(Test), ['test_1', 'test_2'])\n  \n  \n  \n  \n def test_getTestCaseNames__no_tests(self):\n  class Test(unittest.TestCase):\n   def foobar(self): pass\n   \n  loader = unittest.TestLoader()\n  \n  self.assertEqual(loader.getTestCaseNames(Test), [])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_getTestCaseNames__not_a_TestCase(self):\n  class BadCase(int):\n   def test_foo(self):\n    pass\n    \n  loader = unittest.TestLoader()\n  names = loader.getTestCaseNames(BadCase)\n  \n  self.assertEqual(names, ['test_foo'])\n  \n  \n  \n  \n  \n  \n  \n def test_getTestCaseNames__inheritance(self):\n  class TestP(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foobar(self): pass\n   \n  class TestC(TestP):\n   def test_1(self): pass\n   def test_3(self): pass\n   \n  loader = unittest.TestLoader()\n  \n  names = ['test_1', 'test_2', 'test_3']\n  self.assertEqual(loader.getTestCaseNames(TestC), names)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_testMethodPrefix__loadTestsFromTestCase(self):\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n   \n  tests_1 = unittest.TestSuite([Foo('foo_bar')])\n  tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])\n  \n  loader = unittest.TestLoader()\n  loader.testMethodPrefix = 'foo'\n  self.assertEqual(loader.loadTestsFromTestCase(Foo), tests_1)\n  \n  loader.testMethodPrefix = 'test'\n  self.assertEqual(loader.loadTestsFromTestCase(Foo), tests_2)\n  \n  \n  \n  \n  \n  \n def test_testMethodPrefix__loadTestsFromModule(self):\n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n  m.Foo = Foo\n  \n  tests_1 = [unittest.TestSuite([Foo('foo_bar')])]\n  tests_2 = [unittest.TestSuite([Foo('test_1'), Foo('test_2')])]\n  \n  loader = unittest.TestLoader()\n  loader.testMethodPrefix = 'foo'\n  self.assertEqual(list(loader.loadTestsFromModule(m)), tests_1)\n  \n  loader.testMethodPrefix = 'test'\n  self.assertEqual(list(loader.loadTestsFromModule(m)), tests_2)\n  \n  \n  \n  \n  \n  \n def test_testMethodPrefix__loadTestsFromName(self):\n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n  m.Foo = Foo\n  \n  tests_1 = unittest.TestSuite([Foo('foo_bar')])\n  tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])\n  \n  loader = unittest.TestLoader()\n  loader.testMethodPrefix = 'foo'\n  self.assertEqual(loader.loadTestsFromName('Foo', m), tests_1)\n  \n  loader.testMethodPrefix = 'test'\n  self.assertEqual(loader.loadTestsFromName('Foo', m), tests_2)\n  \n  \n  \n  \n  \n  \n def test_testMethodPrefix__loadTestsFromNames(self):\n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n  m.Foo = Foo\n  \n  tests_1 = unittest.TestSuite([unittest.TestSuite([Foo('foo_bar')])])\n  tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])\n  tests_2 = unittest.TestSuite([tests_2])\n  \n  loader = unittest.TestLoader()\n  loader.testMethodPrefix = 'foo'\n  self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests_1)\n  \n  loader.testMethodPrefix = 'test'\n  self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests_2)\n  \n  \n def test_testMethodPrefix__default_value(self):\n  loader = unittest.TestLoader()\n  self.assertEqual(loader.testMethodPrefix, 'test')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_sortTestMethodsUsing__loadTestsFromTestCase(self):\n  def reversed_cmp(x, y):\n   return -((x > y) - (x < y))\n   \n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   \n  loader = unittest.TestLoader()\n  loader.sortTestMethodsUsing = reversed_cmp\n  \n  tests = loader.suiteClass([Foo('test_2'), Foo('test_1')])\n  self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)\n  \n  \n  \n def test_sortTestMethodsUsing__loadTestsFromModule(self):\n  def reversed_cmp(x, y):\n   return -((x > y) - (x < y))\n   \n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n  m.Foo = Foo\n  \n  loader = unittest.TestLoader()\n  loader.sortTestMethodsUsing = reversed_cmp\n  \n  tests = [loader.suiteClass([Foo('test_2'), Foo('test_1')])]\n  self.assertEqual(list(loader.loadTestsFromModule(m)), tests)\n  \n  \n  \n def test_sortTestMethodsUsing__loadTestsFromName(self):\n  def reversed_cmp(x, y):\n   return -((x > y) - (x < y))\n   \n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n  m.Foo = Foo\n  \n  loader = unittest.TestLoader()\n  loader.sortTestMethodsUsing = reversed_cmp\n  \n  tests = loader.suiteClass([Foo('test_2'), Foo('test_1')])\n  self.assertEqual(loader.loadTestsFromName('Foo', m), tests)\n  \n  \n  \n def test_sortTestMethodsUsing__loadTestsFromNames(self):\n  def reversed_cmp(x, y):\n   return -((x > y) - (x < y))\n   \n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n  m.Foo = Foo\n  \n  loader = unittest.TestLoader()\n  loader.sortTestMethodsUsing = reversed_cmp\n  \n  tests = [loader.suiteClass([Foo('test_2'), Foo('test_1')])]\n  self.assertEqual(list(loader.loadTestsFromNames(['Foo'], m)), tests)\n  \n  \n  \n  \n  \n def test_sortTestMethodsUsing__getTestCaseNames(self):\n  def reversed_cmp(x, y):\n   return -((x > y) - (x < y))\n   \n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   \n  loader = unittest.TestLoader()\n  loader.sortTestMethodsUsing = reversed_cmp\n  \n  test_names = ['test_2', 'test_1']\n  self.assertEqual(loader.getTestCaseNames(Foo), test_names)\n  \n  \n  \n  \n def test_sortTestMethodsUsing__default_value(self):\n  loader = unittest.TestLoader()\n  \n  class Foo(unittest.TestCase):\n   def test_2(self): pass\n   def test_3(self): pass\n   def test_1(self): pass\n   \n  test_names = ['test_2', 'test_3', 'test_1']\n  self.assertEqual(loader.getTestCaseNames(Foo), sorted(test_names))\n  \n  \n  \n  \n  \n  \n def test_sortTestMethodsUsing__None(self):\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   \n  loader = unittest.TestLoader()\n  loader.sortTestMethodsUsing = None\n  \n  test_names = ['test_2', 'test_1']\n  self.assertEqual(set(loader.getTestCaseNames(Foo)), set(test_names))\n  \n  \n  \n  \n  \n  \n  \n  \n def test_suiteClass__loadTestsFromTestCase(self):\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n   \n  tests = [Foo('test_1'), Foo('test_2')]\n  \n  loader = unittest.TestLoader()\n  loader.suiteClass = list\n  self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)\n  \n  \n  \n def test_suiteClass__loadTestsFromModule(self):\n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n  m.Foo = Foo\n  \n  tests = [[Foo('test_1'), Foo('test_2')]]\n  \n  loader = unittest.TestLoader()\n  loader.suiteClass = list\n  self.assertEqual(loader.loadTestsFromModule(m), tests)\n  \n  \n  \n def test_suiteClass__loadTestsFromName(self):\n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n  m.Foo = Foo\n  \n  tests = [Foo('test_1'), Foo('test_2')]\n  \n  loader = unittest.TestLoader()\n  loader.suiteClass = list\n  self.assertEqual(loader.loadTestsFromName('Foo', m), tests)\n  \n  \n  \n def test_suiteClass__loadTestsFromNames(self):\n  m = types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self): pass\n   def test_2(self): pass\n   def foo_bar(self): pass\n  m.Foo = Foo\n  \n  tests = [[Foo('test_1'), Foo('test_2')]]\n  \n  loader = unittest.TestLoader()\n  loader.suiteClass = list\n  self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests)\n  \n  \n def test_suiteClass__default_value(self):\n  loader = unittest.TestLoader()\n  self.assertTrue(loader.suiteClass is unittest.TestSuite)\n"], "unittest.suite": ["\"\"\n\nimport sys\n\nfrom . import case\nfrom . import util\n\n__unittest = True\n\n\ndef _call_if_exists(parent, attr):\n func = getattr(parent, attr, lambda: None)\n func()\n \n \nclass BaseTestSuite(object):\n \"\"\n def __init__(self, tests=()):\n  self._tests = []\n  self.addTests(tests)\n  \n def __repr__(self):\n  return \"<%s tests=%s>\" % (util.strclass(self.__class__), list(self))\n  \n def __eq__(self, other):\n  if not isinstance(other, self.__class__):\n   return NotImplemented\n  return list(self) == list(other)\n  \n def __ne__(self, other):\n  return not self == other\n  \n def __iter__(self):\n  return iter(self._tests)\n  \n def countTestCases(self):\n  cases = 0\n  for test in self:\n   cases += test.countTestCases()\n  return cases\n  \n def addTest(self, test):\n \n  if not callable(test):\n   raise TypeError(\"{} is not callable\".format(repr(test)))\n  if isinstance(test, type) and issubclass(test,\n  (case.TestCase, TestSuite)):\n   raise TypeError(\"TestCases and TestSuites must be instantiated \"\n   \"before passing them to addTest()\")\n  self._tests.append(test)\n  \n def addTests(self, tests):\n  if isinstance(tests, str):\n   raise TypeError(\"tests must be an iterable of tests, not a string\")\n  for test in tests:\n   self.addTest(test)\n   \n def run(self, result):\n  for test in self:\n   if result.shouldStop:\n    break\n   test(result)\n  return result\n  \n def __call__(self, *args, **kwds):\n  return self.run(*args, **kwds)\n  \n def debug(self):\n  \"\"\n  for test in self:\n   test.debug()\n   \n   \nclass TestSuite(BaseTestSuite):\n \"\"\n \n def run(self, result, debug=False):\n  topLevel = False\n  if getattr(result, '_testRunEntered', False) is False:\n   result._testRunEntered = topLevel = True\n   \n  for test in self:\n   if result.shouldStop:\n    break\n    \n   if _isnotsuite(test):\n    self._tearDownPreviousClass(test, result)\n    self._handleModuleFixture(test, result)\n    self._handleClassSetUp(test, result)\n    result._previousTestClass = test.__class__\n    \n    if (getattr(test.__class__, '_classSetupFailed', False) or\n    getattr(result, '_moduleSetUpFailed', False)):\n     continue\n     \n   if not debug:\n    test(result)\n   else:\n    test.debug()\n    \n  if topLevel:\n   self._tearDownPreviousClass(None, result)\n   self._handleModuleTearDown(result)\n   result._testRunEntered = False\n  return result\n  \n def debug(self):\n  \"\"\n  debug = _DebugResult()\n  self.run(debug, True)\n  \n  \n  \n def _handleClassSetUp(self, test, result):\n  previousClass = getattr(result, '_previousTestClass', None)\n  currentClass = test.__class__\n  if currentClass == previousClass:\n   return\n  if result._moduleSetUpFailed:\n   return\n  if getattr(currentClass, \"__unittest_skip__\", False):\n   return\n   \n  try:\n   currentClass._classSetupFailed = False\n  except TypeError:\n  \n  \n   pass\n   \n  setUpClass = getattr(currentClass, 'setUpClass', None)\n  if setUpClass is not None:\n   _call_if_exists(result, '_setupStdout')\n   try:\n    setUpClass()\n   except Exception as e:\n    if isinstance(result, _DebugResult):\n     raise\n    currentClass._classSetupFailed = True\n    className = util.strclass(currentClass)\n    errorName = 'setUpClass (%s)' % className\n    self._addClassOrModuleLevelException(result, e, errorName)\n   finally:\n    _call_if_exists(result, '_restoreStdout')\n    \n def _get_previous_module(self, result):\n  previousModule = None\n  previousClass = getattr(result, '_previousTestClass', None)\n  if previousClass is not None:\n   previousModule = previousClass.__module__\n  return previousModule\n  \n  \n def _handleModuleFixture(self, test, result):\n  previousModule = self._get_previous_module(result)\n  currentModule = test.__class__.__module__\n  if currentModule == previousModule:\n   return\n   \n  self._handleModuleTearDown(result)\n  \n  \n  result._moduleSetUpFailed = False\n  try:\n   module = sys.modules[currentModule]\n  except KeyError:\n   return\n  setUpModule = getattr(module, 'setUpModule', None)\n  if setUpModule is not None:\n   _call_if_exists(result, '_setupStdout')\n   try:\n    setUpModule()\n   except Exception as e:\n    if isinstance(result, _DebugResult):\n     raise\n    result._moduleSetUpFailed = True\n    errorName = 'setUpModule (%s)' % currentModule\n    self._addClassOrModuleLevelException(result, e, errorName)\n   finally:\n    _call_if_exists(result, '_restoreStdout')\n    \n def _addClassOrModuleLevelException(self, result, exception, errorName):\n  error = _ErrorHolder(errorName)\n  addSkip = getattr(result, 'addSkip', None)\n  if addSkip is not None and isinstance(exception, case.SkipTest):\n   addSkip(error, str(exception))\n  else:\n   result.addError(error, sys.exc_info())\n   \n def _handleModuleTearDown(self, result):\n  previousModule = self._get_previous_module(result)\n  if previousModule is None:\n   return\n  if result._moduleSetUpFailed:\n   return\n   \n  try:\n   module = sys.modules[previousModule]\n  except KeyError:\n   return\n   \n  tearDownModule = getattr(module, 'tearDownModule', None)\n  if tearDownModule is not None:\n   _call_if_exists(result, '_setupStdout')\n   try:\n    tearDownModule()\n   except Exception as e:\n    if isinstance(result, _DebugResult):\n     raise\n    errorName = 'tearDownModule (%s)' % previousModule\n    self._addClassOrModuleLevelException(result, e, errorName)\n   finally:\n    _call_if_exists(result, '_restoreStdout')\n    \n def _tearDownPreviousClass(self, test, result):\n  previousClass = getattr(result, '_previousTestClass', None)\n  currentClass = test.__class__\n  if currentClass == previousClass:\n   return\n  if getattr(previousClass, '_classSetupFailed', False):\n   return\n  if getattr(result, '_moduleSetUpFailed', False):\n   return\n  if getattr(previousClass, \"__unittest_skip__\", False):\n   return\n   \n  tearDownClass = getattr(previousClass, 'tearDownClass', None)\n  if tearDownClass is not None:\n   _call_if_exists(result, '_setupStdout')\n   try:\n    tearDownClass()\n   except Exception as e:\n    if isinstance(result, _DebugResult):\n     raise\n    className = util.strclass(previousClass)\n    errorName = 'tearDownClass (%s)' % className\n    self._addClassOrModuleLevelException(result, e, errorName)\n   finally:\n    _call_if_exists(result, '_restoreStdout')\n    \n    \nclass _ErrorHolder(object):\n \"\"\n \n \n \n \n failureException = None\n \n def __init__(self, description):\n  self.description = description\n  \n def id(self):\n  return self.description\n  \n def shortDescription(self):\n  return None\n  \n def __repr__(self):\n  return \"<ErrorHolder description=%r>\" % (self.description,)\n  \n def __str__(self):\n  return self.id()\n  \n def run(self, result):\n \n \n  pass\n  \n def __call__(self, result):\n  return self.run(result)\n  \n def countTestCases(self):\n  return 0\n  \ndef _isnotsuite(test):\n \"\"\n try:\n  iter(test)\n except TypeError:\n  return True\n return False\n \n \nclass _DebugResult(object):\n \"\"\n _previousTestClass = None\n _moduleSetUpFailed = False\n shouldStop = False\n"], "unittest.test.testmock.testmock": ["import copy\nimport sys\n\nimport unittest\nfrom unittest.test.testmock.support import is_instance\nfrom unittest import mock\nfrom unittest.mock import (\ncall, DEFAULT, patch, sentinel,\nMagicMock, Mock, NonCallableMock,\nNonCallableMagicMock, _CallList,\ncreate_autospec\n)\n\n\nclass Iter(object):\n def __init__(self):\n  self.thing = iter(['this', 'is', 'an', 'iter'])\n  \n def __iter__(self):\n  return self\n  \n def next(self):\n  return next(self.thing)\n  \n __next__ = next\n \n \n \nclass MockTest(unittest.TestCase):\n\n def test_all(self):\n \n \n \n  exec(\"from unittest.mock import *\")\n  \n  \n def test_constructor(self):\n  mock = Mock()\n  \n  self.assertFalse(mock.called, \"called not initialised correctly\")\n  self.assertEqual(mock.call_count, 0,\n  \"call_count not initialised correctly\")\n  self.assertTrue(is_instance(mock.return_value, Mock),\n  \"return_value not initialised correctly\")\n  \n  self.assertEqual(mock.call_args, None,\n  \"call_args not initialised correctly\")\n  self.assertEqual(mock.call_args_list, [],\n  \"call_args_list not initialised correctly\")\n  self.assertEqual(mock.method_calls, [],\n  \"method_calls not initialised correctly\")\n  \n  \n  self.assertFalse('_items' in mock.__dict__,\n  \"default mock should not have '_items' attribute\")\n  \n  self.assertIsNone(mock._mock_parent,\n  \"parent not initialised correctly\")\n  self.assertIsNone(mock._mock_methods,\n  \"methods not initialised correctly\")\n  self.assertEqual(mock._mock_children, {},\n  \"children not initialised incorrectly\")\n  \n  \n def test_return_value_in_constructor(self):\n  mock = Mock(return_value=None)\n  self.assertIsNone(mock.return_value,\n  \"return value in constructor not honoured\")\n  \n  \n def test_repr(self):\n  mock = Mock(name='foo')\n  self.assertIn('foo', repr(mock))\n  self.assertIn(\"'%s'\" % id(mock), repr(mock))\n  \n  mocks = [(Mock(), 'mock'), (Mock(name='bar'), 'bar')]\n  for mock, name in mocks:\n   self.assertIn('%s.bar' % name, repr(mock.bar))\n   self.assertIn('%s.foo()' % name, repr(mock.foo()))\n   self.assertIn('%s.foo().bing' % name, repr(mock.foo().bing))\n   self.assertIn('%s()' % name, repr(mock()))\n   self.assertIn('%s()()' % name, repr(mock()()))\n   self.assertIn('%s()().foo.bar.baz().bing' % name,\n   repr(mock()().foo.bar.baz().bing))\n   \n   \n def test_repr_with_spec(self):\n  class X(object):\n   pass\n   \n  mock = Mock(spec=X)\n  self.assertIn(\" spec='X' \", repr(mock))\n  \n  mock = Mock(spec=X())\n  self.assertIn(\" spec='X' \", repr(mock))\n  \n  mock = Mock(spec_set=X)\n  self.assertIn(\" spec_set='X' \", repr(mock))\n  \n  mock = Mock(spec_set=X())\n  self.assertIn(\" spec_set='X' \", repr(mock))\n  \n  mock = Mock(spec=X, name='foo')\n  self.assertIn(\" spec='X' \", repr(mock))\n  self.assertIn(\" name='foo' \", repr(mock))\n  \n  mock = Mock(name='foo')\n  self.assertNotIn(\"spec\", repr(mock))\n  \n  mock = Mock()\n  self.assertNotIn(\"spec\", repr(mock))\n  \n  mock = Mock(spec=['foo'])\n  self.assertNotIn(\"spec\", repr(mock))\n  \n  \n def test_side_effect(self):\n  mock = Mock()\n  \n  def effect(*args, **kwargs):\n   raise SystemError('kablooie')\n   \n  mock.side_effect = effect\n  self.assertRaises(SystemError, mock, 1, 2, fish=3)\n  mock.assert_called_with(1, 2, fish=3)\n  \n  results = [1, 2, 3]\n  def effect():\n   return results.pop()\n  mock.side_effect = effect\n  \n  self.assertEqual([mock(), mock(), mock()], [3, 2, 1],\n  \"side effect not used correctly\")\n  \n  mock = Mock(side_effect=sentinel.SideEffect)\n  self.assertEqual(mock.side_effect, sentinel.SideEffect,\n  \"side effect in constructor not used\")\n  \n  def side_effect():\n   return DEFAULT\n  mock = Mock(side_effect=side_effect, return_value=sentinel.RETURN)\n  self.assertEqual(mock(), sentinel.RETURN)\n  \n  \n @unittest.skipUnless('java' in sys.platform,\n 'This test only applies to Jython')\n def test_java_exception_side_effect(self):\n  import java\n  mock = Mock(side_effect=java.lang.RuntimeException(\"Boom!\"))\n  \n  \n  try:\n   mock(1, 2, fish=3)\n  except java.lang.RuntimeException:\n   pass\n  else:\n   self.fail('java exception not raised')\n  mock.assert_called_with(1,2, fish=3)\n  \n  \n def test_reset_mock(self):\n  parent = Mock()\n  spec = [\"something\"]\n  mock = Mock(name=\"child\", parent=parent, spec=spec)\n  mock(sentinel.Something, something=sentinel.SomethingElse)\n  something = mock.something\n  mock.something()\n  mock.side_effect = sentinel.SideEffect\n  return_value = mock.return_value\n  return_value()\n  \n  mock.reset_mock()\n  \n  self.assertEqual(mock._mock_name, \"child\",\n  \"name incorrectly reset\")\n  self.assertEqual(mock._mock_parent, parent,\n  \"parent incorrectly reset\")\n  self.assertEqual(mock._mock_methods, spec,\n  \"methods incorrectly reset\")\n  \n  self.assertFalse(mock.called, \"called not reset\")\n  self.assertEqual(mock.call_count, 0, \"call_count not reset\")\n  self.assertEqual(mock.call_args, None, \"call_args not reset\")\n  self.assertEqual(mock.call_args_list, [], \"call_args_list not reset\")\n  self.assertEqual(mock.method_calls, [],\n  \"method_calls not initialised correctly: %r != %r\" %\n  (mock.method_calls, []))\n  self.assertEqual(mock.mock_calls, [])\n  \n  self.assertEqual(mock.side_effect, sentinel.SideEffect,\n  \"side_effect incorrectly reset\")\n  self.assertEqual(mock.return_value, return_value,\n  \"return_value incorrectly reset\")\n  self.assertFalse(return_value.called, \"return value mock not reset\")\n  self.assertEqual(mock._mock_children, {'something': something},\n  \"children reset incorrectly\")\n  self.assertEqual(mock.something, something,\n  \"children incorrectly cleared\")\n  self.assertFalse(mock.something.called, \"child not reset\")\n  \n  \n def test_reset_mock_recursion(self):\n  mock = Mock()\n  mock.return_value = mock\n  \n  \n  mock.reset_mock()\n  \n  \n def test_call(self):\n  mock = Mock()\n  self.assertTrue(is_instance(mock.return_value, Mock),\n  \"Default return_value should be a Mock\")\n  \n  result = mock()\n  self.assertEqual(mock(), result,\n  \"different result from consecutive calls\")\n  mock.reset_mock()\n  \n  ret_val = mock(sentinel.Arg)\n  self.assertTrue(mock.called, \"called not set\")\n  self.assertEqual(mock.call_count, 1, \"call_count incoreect\")\n  self.assertEqual(mock.call_args, ((sentinel.Arg,), {}),\n  \"call_args not set\")\n  self.assertEqual(mock.call_args_list, [((sentinel.Arg,), {})],\n  \"call_args_list not initialised correctly\")\n  \n  mock.return_value = sentinel.ReturnValue\n  ret_val = mock(sentinel.Arg, key=sentinel.KeyArg)\n  self.assertEqual(ret_val, sentinel.ReturnValue,\n  \"incorrect return value\")\n  \n  self.assertEqual(mock.call_count, 2, \"call_count incorrect\")\n  self.assertEqual(mock.call_args,\n  ((sentinel.Arg,), {'key': sentinel.KeyArg}),\n  \"call_args not set\")\n  self.assertEqual(mock.call_args_list, [\n  ((sentinel.Arg,), {}),\n  ((sentinel.Arg,), {'key': sentinel.KeyArg})\n  ],\n  \"call_args_list not set\")\n  \n  \n def test_call_args_comparison(self):\n  mock = Mock()\n  mock()\n  mock(sentinel.Arg)\n  mock(kw=sentinel.Kwarg)\n  mock(sentinel.Arg, kw=sentinel.Kwarg)\n  self.assertEqual(mock.call_args_list, [\n  (),\n  ((sentinel.Arg,),),\n  ({\"kw\": sentinel.Kwarg},),\n  ((sentinel.Arg,), {\"kw\": sentinel.Kwarg})\n  ])\n  self.assertEqual(mock.call_args,\n  ((sentinel.Arg,), {\"kw\": sentinel.Kwarg}))\n  \n  \n def test_assert_called_with(self):\n  mock = Mock()\n  mock()\n  \n  \n  mock.assert_called_with()\n  self.assertRaises(AssertionError, mock.assert_called_with, 1)\n  \n  mock.reset_mock()\n  self.assertRaises(AssertionError, mock.assert_called_with)\n  \n  mock(1, 2, 3, a='fish', b='nothing')\n  mock.assert_called_with(1, 2, 3, a='fish', b='nothing')\n  \n  \n def test_assert_called_once_with(self):\n  mock = Mock()\n  mock()\n  \n  \n  mock.assert_called_once_with()\n  \n  mock()\n  self.assertRaises(AssertionError, mock.assert_called_once_with)\n  \n  mock.reset_mock()\n  self.assertRaises(AssertionError, mock.assert_called_once_with)\n  \n  mock('foo', 'bar', baz=2)\n  mock.assert_called_once_with('foo', 'bar', baz=2)\n  \n  mock.reset_mock()\n  mock('foo', 'bar', baz=2)\n  self.assertRaises(\n  AssertionError,\n  lambda: mock.assert_called_once_with('bob', 'bar', baz=2)\n  )\n  \n  \n def test_attribute_access_returns_mocks(self):\n  mock = Mock()\n  something = mock.something\n  self.assertTrue(is_instance(something, Mock), \"attribute isn't a mock\")\n  self.assertEqual(mock.something, something,\n  \"different attributes returned for same name\")\n  \n  \n  mock = Mock()\n  mock.something.return_value = 3\n  \n  self.assertEqual(mock.something(), 3, \"method returned wrong value\")\n  self.assertTrue(mock.something.called,\n  \"method didn't record being called\")\n  \n  \n def test_attributes_have_name_and_parent_set(self):\n  mock = Mock()\n  something = mock.something\n  \n  self.assertEqual(something._mock_name, \"something\",\n  \"attribute name not set correctly\")\n  self.assertEqual(something._mock_parent, mock,\n  \"attribute parent not set correctly\")\n  \n  \n def test_method_calls_recorded(self):\n  mock = Mock()\n  mock.something(3, fish=None)\n  mock.something_else.something(6, cake=sentinel.Cake)\n  \n  self.assertEqual(mock.something_else.method_calls,\n  [(\"something\", (6,), {'cake': sentinel.Cake})],\n  \"method calls not recorded correctly\")\n  self.assertEqual(mock.method_calls, [\n  (\"something\", (3,), {'fish': None}),\n  (\"something_else.something\", (6,), {'cake': sentinel.Cake})\n  ],\n  \"method calls not recorded correctly\")\n  \n  \n def test_method_calls_compare_easily(self):\n  mock = Mock()\n  mock.something()\n  self.assertEqual(mock.method_calls, [('something',)])\n  self.assertEqual(mock.method_calls, [('something', (), {})])\n  \n  mock = Mock()\n  mock.something('different')\n  self.assertEqual(mock.method_calls, [('something', ('different',))])\n  self.assertEqual(mock.method_calls,\n  [('something', ('different',), {})])\n  \n  mock = Mock()\n  mock.something(x=1)\n  self.assertEqual(mock.method_calls, [('something', {'x': 1})])\n  self.assertEqual(mock.method_calls, [('something', (), {'x': 1})])\n  \n  mock = Mock()\n  mock.something('different', some='more')\n  self.assertEqual(mock.method_calls, [\n  ('something', ('different',), {'some': 'more'})\n  ])\n  \n  \n def test_only_allowed_methods_exist(self):\n  for spec in ['something'], ('something',):\n   for arg in 'spec', 'spec_set':\n    mock = Mock(**{arg: spec})\n    \n    \n    mock.something\n    self.assertRaisesRegex(\n    AttributeError,\n    \"Mock object has no attribute 'something_else'\",\n    getattr, mock, 'something_else'\n    )\n    \n    \n def test_from_spec(self):\n  class Something(object):\n   x = 3\n   __something__ = None\n   def y(self):\n    pass\n    \n  def test_attributes(mock):\n  \n   mock.x\n   mock.y\n   mock.__something__\n   self.assertRaisesRegex(\n   AttributeError,\n   \"Mock object has no attribute 'z'\",\n   getattr, mock, 'z'\n   )\n   self.assertRaisesRegex(\n   AttributeError,\n   \"Mock object has no attribute '__foobar__'\",\n   getattr, mock, '__foobar__'\n   )\n   \n  test_attributes(Mock(spec=Something))\n  test_attributes(Mock(spec=Something()))\n  \n  \n def test_wraps_calls(self):\n  real = Mock()\n  \n  mock = Mock(wraps=real)\n  self.assertEqual(mock(), real())\n  \n  real.reset_mock()\n  \n  mock(1, 2, fish=3)\n  real.assert_called_with(1, 2, fish=3)\n  \n  \n def test_wraps_call_with_nondefault_return_value(self):\n  real = Mock()\n  \n  mock = Mock(wraps=real)\n  mock.return_value = 3\n  \n  self.assertEqual(mock(), 3)\n  self.assertFalse(real.called)\n  \n  \n def test_wraps_attributes(self):\n  class Real(object):\n   attribute = Mock()\n   \n  real = Real()\n  \n  mock = Mock(wraps=real)\n  self.assertEqual(mock.attribute(), real.attribute())\n  self.assertRaises(AttributeError, lambda: mock.fish)\n  \n  self.assertNotEqual(mock.attribute, real.attribute)\n  result = mock.attribute.frog(1, 2, fish=3)\n  Real.attribute.frog.assert_called_with(1, 2, fish=3)\n  self.assertEqual(result, Real.attribute.frog())\n  \n  \n def test_exceptional_side_effect(self):\n  mock = Mock(side_effect=AttributeError)\n  self.assertRaises(AttributeError, mock)\n  \n  mock = Mock(side_effect=AttributeError('foo'))\n  self.assertRaises(AttributeError, mock)\n  \n  \n def test_baseexceptional_side_effect(self):\n  mock = Mock(side_effect=KeyboardInterrupt)\n  self.assertRaises(KeyboardInterrupt, mock)\n  \n  mock = Mock(side_effect=KeyboardInterrupt('foo'))\n  self.assertRaises(KeyboardInterrupt, mock)\n  \n  \n def test_assert_called_with_message(self):\n  mock = Mock()\n  self.assertRaisesRegex(AssertionError, 'Not called',\n  mock.assert_called_with)\n  \n  \n def test__name__(self):\n  mock = Mock()\n  self.assertRaises(AttributeError, lambda: mock.__name__)\n  \n  mock.__name__ = 'foo'\n  self.assertEqual(mock.__name__, 'foo')\n  \n  \n def test_spec_list_subclass(self):\n  class Sub(list):\n   pass\n  mock = Mock(spec=Sub(['foo']))\n  \n  mock.append(3)\n  mock.append.assert_called_with(3)\n  self.assertRaises(AttributeError, getattr, mock, 'foo')\n  \n  \n def test_spec_class(self):\n  class X(object):\n   pass\n   \n  mock = Mock(spec=X)\n  self.assertTrue(isinstance(mock, X))\n  \n  mock = Mock(spec=X())\n  self.assertTrue(isinstance(mock, X))\n  \n  self.assertIs(mock.__class__, X)\n  self.assertEqual(Mock().__class__.__name__, 'Mock')\n  \n  mock = Mock(spec_set=X)\n  self.assertTrue(isinstance(mock, X))\n  \n  mock = Mock(spec_set=X())\n  self.assertTrue(isinstance(mock, X))\n  \n  \n def test_setting_attribute_with_spec_set(self):\n  class X(object):\n   y = 3\n   \n  mock = Mock(spec=X)\n  mock.x = 'foo'\n  \n  mock = Mock(spec_set=X)\n  def set_attr():\n   mock.x = 'foo'\n   \n  mock.y = 'foo'\n  self.assertRaises(AttributeError, set_attr)\n  \n  \n def test_copy(self):\n  current = sys.getrecursionlimit()\n  self.addCleanup(sys.setrecursionlimit, current)\n  \n  \n  sys.setrecursionlimit(int(10e8))\n  \n  copy.copy(Mock())\n  \n  \n def test_subclass_with_properties(self):\n  class SubClass(Mock):\n   def _get(self):\n    return 3\n   def _set(self, value):\n    raise NameError('strange error')\n   some_attribute = property(_get, _set)\n   \n  s = SubClass(spec_set=SubClass)\n  self.assertEqual(s.some_attribute, 3)\n  \n  def test():\n   s.some_attribute = 3\n  self.assertRaises(NameError, test)\n  \n  def test():\n   s.foo = 'bar'\n  self.assertRaises(AttributeError, test)\n  \n  \n def test_setting_call(self):\n  mock = Mock()\n  def __call__(self, a):\n   return self._mock_call(a)\n   \n  type(mock).__call__ = __call__\n  mock('one')\n  mock.assert_called_with('one')\n  \n  self.assertRaises(TypeError, mock, 'one', 'two')\n  \n  \n def test_dir(self):\n  mock = Mock()\n  attrs = set(dir(mock))\n  type_attrs = set([m for m in dir(Mock) if not m.startswith('_')])\n  \n  \n  self.assertEqual(set(), type_attrs - attrs)\n  \n  \n  mock.a, mock.b\n  self.assertIn('a', dir(mock))\n  self.assertIn('b', dir(mock))\n  \n  \n  mock.c = mock.d = None\n  self.assertIn('c', dir(mock))\n  self.assertIn('d', dir(mock))\n  \n  \n  mock.__iter__ = lambda s: iter([])\n  self.assertIn('__iter__', dir(mock))\n  \n  \n def test_dir_from_spec(self):\n  mock = Mock(spec=unittest.TestCase)\n  testcase_attrs = set(dir(unittest.TestCase))\n  attrs = set(dir(mock))\n  \n  \n  self.assertEqual(set(), testcase_attrs - attrs)\n  \n  \n  mock.version = 3\n  self.assertEqual(dir(mock).count('version'), 1)\n  \n  \n def test_filter_dir(self):\n  patcher = patch.object(mock, 'FILTER_DIR', False)\n  patcher.start()\n  try:\n   attrs = set(dir(Mock()))\n   type_attrs = set(dir(Mock))\n   \n   \n   self.assertEqual(set(), type_attrs - attrs)\n  finally:\n   patcher.stop()\n   \n   \n def test_configure_mock(self):\n  mock = Mock(foo='bar')\n  self.assertEqual(mock.foo, 'bar')\n  \n  mock = MagicMock(foo='bar')\n  self.assertEqual(mock.foo, 'bar')\n  \n  kwargs = {'side_effect': KeyError, 'foo.bar.return_value': 33,\n  'foo': MagicMock()}\n  mock = Mock(**kwargs)\n  self.assertRaises(KeyError, mock)\n  self.assertEqual(mock.foo.bar(), 33)\n  self.assertIsInstance(mock.foo, MagicMock)\n  \n  mock = Mock()\n  mock.configure_mock(**kwargs)\n  self.assertRaises(KeyError, mock)\n  self.assertEqual(mock.foo.bar(), 33)\n  self.assertIsInstance(mock.foo, MagicMock)\n  \n  \n def assertRaisesWithMsg(self, exception, message, func, *args, **kwargs):\n \n  try:\n   func(*args, **kwargs)\n  except:\n   instance = sys.exc_info()[1]\n   self.assertIsInstance(instance, exception)\n  else:\n   self.fail('Exception %r not raised' % (exception,))\n   \n  msg = str(instance)\n  self.assertEqual(msg, message)\n  \n  \n def test_assert_called_with_failure_message(self):\n  mock = NonCallableMock()\n  \n  expected = \"mock(1, '2', 3, bar='foo')\"\n  message = 'Expected call: %s\\nNot called'\n  self.assertRaisesWithMsg(\n  AssertionError, message % (expected,),\n  mock.assert_called_with, 1, '2', 3, bar='foo'\n  )\n  \n  mock.foo(1, '2', 3, foo='foo')\n  \n  \n  asserters = [\n  mock.foo.assert_called_with, mock.foo.assert_called_once_with\n  ]\n  for meth in asserters:\n   actual = \"foo(1, '2', 3, foo='foo')\"\n   expected = \"foo(1, '2', 3, bar='foo')\"\n   message = 'Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError, message % (expected, actual),\n   meth, 1, '2', 3, bar='foo'\n   )\n   \n   \n  for meth in asserters:\n   actual = \"foo(1, '2', 3, foo='foo')\"\n   expected = \"foo(bar='foo')\"\n   message = 'Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError, message % (expected, actual),\n   meth, bar='foo'\n   )\n   \n   \n  for meth in asserters:\n   actual = \"foo(1, '2', 3, foo='foo')\"\n   expected = \"foo(1, 2, 3)\"\n   message = 'Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError, message % (expected, actual),\n   meth, 1, 2, 3\n   )\n   \n   \n  for meth in asserters:\n   actual = \"foo(1, '2', 3, foo='foo')\"\n   expected = \"foo()\"\n   message = 'Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError, message % (expected, actual), meth\n   )\n   \n   \n def test_mock_calls(self):\n  mock = MagicMock()\n  \n  \n  \n  self.assertIs(mock.mock_calls == [], True)\n  \n  mock = MagicMock()\n  mock()\n  expected = [('', (), {})]\n  self.assertEqual(mock.mock_calls, expected)\n  \n  mock.foo()\n  expected.append(call.foo())\n  self.assertEqual(mock.mock_calls, expected)\n  \n  self.assertEqual(mock.foo.mock_calls, [('', (), {})])\n  \n  mock = MagicMock()\n  mock().foo(1, 2, 3, a=4, b=5)\n  expected = [\n  ('', (), {}), ('().foo', (1, 2, 3), dict(a=4, b=5))\n  ]\n  self.assertEqual(mock.mock_calls, expected)\n  self.assertEqual(mock.return_value.foo.mock_calls,\n  [('', (1, 2, 3), dict(a=4, b=5))])\n  self.assertEqual(mock.return_value.mock_calls,\n  [('foo', (1, 2, 3), dict(a=4, b=5))])\n  \n  mock = MagicMock()\n  mock().foo.bar().baz()\n  expected = [\n  ('', (), {}), ('().foo.bar', (), {}),\n  ('().foo.bar().baz', (), {})\n  ]\n  self.assertEqual(mock.mock_calls, expected)\n  self.assertEqual(mock().mock_calls,\n  call.foo.bar().baz().call_list())\n  \n  for kwargs in dict(), dict(name='bar'):\n   mock = MagicMock(**kwargs)\n   int(mock.foo)\n   expected = [('foo.__int__', (), {})]\n   self.assertEqual(mock.mock_calls, expected)\n   \n   mock = MagicMock(**kwargs)\n   mock.a()()\n   expected = [('a', (), {}), ('a()', (), {})]\n   self.assertEqual(mock.mock_calls, expected)\n   self.assertEqual(mock.a().mock_calls, [call()])\n   \n   mock = MagicMock(**kwargs)\n   mock(1)(2)(3)\n   self.assertEqual(mock.mock_calls, call(1)(2)(3).call_list())\n   self.assertEqual(mock().mock_calls, call(2)(3).call_list())\n   self.assertEqual(mock()().mock_calls, call(3).call_list())\n   \n   mock = MagicMock(**kwargs)\n   mock(1)(2)(3).a.b.c(4)\n   self.assertEqual(mock.mock_calls,\n   call(1)(2)(3).a.b.c(4).call_list())\n   self.assertEqual(mock().mock_calls,\n   call(2)(3).a.b.c(4).call_list())\n   self.assertEqual(mock()().mock_calls,\n   call(3).a.b.c(4).call_list())\n   \n   mock = MagicMock(**kwargs)\n   int(mock().foo.bar().baz())\n   last_call = ('().foo.bar().baz().__int__', (), {})\n   self.assertEqual(mock.mock_calls[-1], last_call)\n   self.assertEqual(mock().mock_calls,\n   call.foo.bar().baz().__int__().call_list())\n   self.assertEqual(mock().foo.bar().mock_calls,\n   call.baz().__int__().call_list())\n   self.assertEqual(mock().foo.bar().baz.mock_calls,\n   call().__int__().call_list())\n   \n   \n def test_subclassing(self):\n  class Subclass(Mock):\n   pass\n   \n  mock = Subclass()\n  self.assertIsInstance(mock.foo, Subclass)\n  self.assertIsInstance(mock(), Subclass)\n  \n  class Subclass(Mock):\n   def _get_child_mock(self, **kwargs):\n    return Mock(**kwargs)\n    \n  mock = Subclass()\n  self.assertNotIsInstance(mock.foo, Subclass)\n  self.assertNotIsInstance(mock(), Subclass)\n  \n  \n def test_arg_lists(self):\n  mocks = [\n  Mock(),\n  MagicMock(),\n  NonCallableMock(),\n  NonCallableMagicMock()\n  ]\n  \n  def assert_attrs(mock):\n   names = 'call_args_list', 'method_calls', 'mock_calls'\n   for name in names:\n    attr = getattr(mock, name)\n    self.assertIsInstance(attr, _CallList)\n    self.assertIsInstance(attr, list)\n    self.assertEqual(attr, [])\n    \n  for mock in mocks:\n   assert_attrs(mock)\n   \n   if callable(mock):\n    mock()\n    mock(1, 2)\n    mock(a=3)\n    \n    mock.reset_mock()\n    assert_attrs(mock)\n    \n   mock.foo()\n   mock.foo.bar(1, a=3)\n   mock.foo(1).bar().baz(3)\n   \n   mock.reset_mock()\n   assert_attrs(mock)\n   \n   \n def test_call_args_two_tuple(self):\n  mock = Mock()\n  mock(1, a=3)\n  mock(2, b=4)\n  \n  self.assertEqual(len(mock.call_args), 2)\n  args, kwargs = mock.call_args\n  self.assertEqual(args, (2,))\n  self.assertEqual(kwargs, dict(b=4))\n  \n  expected_list = [((1,), dict(a=3)), ((2,), dict(b=4))]\n  for expected, call_args in zip(expected_list, mock.call_args_list):\n   self.assertEqual(len(call_args), 2)\n   self.assertEqual(expected[0], call_args[0])\n   self.assertEqual(expected[1], call_args[1])\n   \n   \n def test_side_effect_iterator(self):\n  mock = Mock(side_effect=iter([1, 2, 3]))\n  self.assertEqual([mock(), mock(), mock()], [1, 2, 3])\n  self.assertRaises(StopIteration, mock)\n  \n  mock = MagicMock(side_effect=['a', 'b', 'c'])\n  self.assertEqual([mock(), mock(), mock()], ['a', 'b', 'c'])\n  self.assertRaises(StopIteration, mock)\n  \n  mock = Mock(side_effect='ghi')\n  self.assertEqual([mock(), mock(), mock()], ['g', 'h', 'i'])\n  self.assertRaises(StopIteration, mock)\n  \n  class Foo(object):\n   pass\n  mock = MagicMock(side_effect=Foo)\n  self.assertIsInstance(mock(), Foo)\n  \n  mock = Mock(side_effect=Iter())\n  self.assertEqual([mock(), mock(), mock(), mock()],\n  ['this', 'is', 'an', 'iter'])\n  self.assertRaises(StopIteration, mock)\n  \n  \n def test_side_effect_iterator_exceptions(self):\n  for Klass in Mock, MagicMock:\n   iterable = (ValueError, 3, KeyError, 6)\n   m = Klass(side_effect=iterable)\n   self.assertRaises(ValueError, m)\n   self.assertEqual(m(), 3)\n   self.assertRaises(KeyError, m)\n   self.assertEqual(m(), 6)\n   \n   \n def test_side_effect_setting_iterator(self):\n  mock = Mock()\n  mock.side_effect = iter([1, 2, 3])\n  self.assertEqual([mock(), mock(), mock()], [1, 2, 3])\n  self.assertRaises(StopIteration, mock)\n  side_effect = mock.side_effect\n  self.assertIsInstance(side_effect, type(iter([])))\n  \n  mock.side_effect = ['a', 'b', 'c']\n  self.assertEqual([mock(), mock(), mock()], ['a', 'b', 'c'])\n  self.assertRaises(StopIteration, mock)\n  side_effect = mock.side_effect\n  self.assertIsInstance(side_effect, type(iter([])))\n  \n  this_iter = Iter()\n  mock.side_effect = this_iter\n  self.assertEqual([mock(), mock(), mock(), mock()],\n  ['this', 'is', 'an', 'iter'])\n  self.assertRaises(StopIteration, mock)\n  self.assertIs(mock.side_effect, this_iter)\n  \n  \n def test_assert_has_calls_any_order(self):\n  mock = Mock()\n  mock(1, 2)\n  mock(a=3)\n  mock(3, 4)\n  mock(b=6)\n  mock(b=6)\n  \n  kalls = [\n  call(1, 2), ({'a': 3},),\n  ((3, 4),), ((), {'a': 3}),\n  ('', (1, 2)), ('', {'a': 3}),\n  ('', (1, 2), {}), ('', (), {'a': 3})\n  ]\n  for kall in kalls:\n   mock.assert_has_calls([kall], any_order=True)\n   \n  for kall in call(1, '2'), call(b=3), call(), 3, None, 'foo':\n   self.assertRaises(\n   AssertionError, mock.assert_has_calls,\n   [kall], any_order=True\n   )\n   \n  kall_lists = [\n  [call(1, 2), call(b=6)],\n  [call(3, 4), call(1, 2)],\n  [call(b=6), call(b=6)],\n  ]\n  \n  for kall_list in kall_lists:\n   mock.assert_has_calls(kall_list, any_order=True)\n   \n  kall_lists = [\n  [call(b=6), call(b=6), call(b=6)],\n  [call(1, 2), call(1, 2)],\n  [call(3, 4), call(1, 2), call(5, 7)],\n  [call(b=6), call(3, 4), call(b=6), call(1, 2), call(b=6)],\n  ]\n  for kall_list in kall_lists:\n   self.assertRaises(\n   AssertionError, mock.assert_has_calls,\n   kall_list, any_order=True\n   )\n   \n def test_assert_has_calls(self):\n  kalls1 = [\n  call(1, 2), ({'a': 3},),\n  ((3, 4),), call(b=6),\n  ('', (1,), {'b': 6}),\n  ]\n  kalls2 = [call.foo(), call.bar(1)]\n  kalls2.extend(call.spam().baz(a=3).call_list())\n  kalls2.extend(call.bam(set(), foo={}).fish([1]).call_list())\n  \n  mocks = []\n  for mock in Mock(), MagicMock():\n   mock(1, 2)\n   mock(a=3)\n   mock(3, 4)\n   mock(b=6)\n   mock(1, b=6)\n   mocks.append((mock, kalls1))\n   \n  mock = Mock()\n  mock.foo()\n  mock.bar(1)\n  mock.spam().baz(a=3)\n  mock.bam(set(), foo={}).fish([1])\n  mocks.append((mock, kalls2))\n  \n  for mock, kalls in mocks:\n   for i in range(len(kalls)):\n    for step in 1, 2, 3:\n     these = kalls[i:i+step]\n     mock.assert_has_calls(these)\n     \n     if len(these) > 1:\n      self.assertRaises(\n      AssertionError,\n      mock.assert_has_calls,\n      list(reversed(these))\n      )\n      \n      \n def test_assert_any_call(self):\n  mock = Mock()\n  mock(1, 2)\n  mock(a=3)\n  mock(1, b=6)\n  \n  mock.assert_any_call(1, 2)\n  mock.assert_any_call(a=3)\n  mock.assert_any_call(1, b=6)\n  \n  self.assertRaises(\n  AssertionError,\n  mock.assert_any_call\n  )\n  self.assertRaises(\n  AssertionError,\n  mock.assert_any_call,\n  1, 3\n  )\n  self.assertRaises(\n  AssertionError,\n  mock.assert_any_call,\n  a=4\n  )\n  \n  \n def test_mock_calls_create_autospec(self):\n  def f(a, b):\n   pass\n  obj = Iter()\n  obj.f = f\n  \n  funcs = [\n  create_autospec(f),\n  create_autospec(obj).f\n  ]\n  for func in funcs:\n   func(1, 2)\n   func(3, 4)\n   \n   self.assertEqual(\n   func.mock_calls, [call(1, 2), call(3, 4)]\n   )\n   \n   \n def test_mock_add_spec(self):\n  class _One(object):\n   one = 1\n  class _Two(object):\n   two = 2\n  class Anything(object):\n   one = two = three = 'four'\n   \n  klasses = [\n  Mock, MagicMock, NonCallableMock, NonCallableMagicMock\n  ]\n  for Klass in list(klasses):\n   klasses.append(lambda K=Klass: K(spec=Anything))\n   klasses.append(lambda K=Klass: K(spec_set=Anything))\n   \n  for Klass in klasses:\n   for kwargs in dict(), dict(spec_set=True):\n    mock = Klass()\n    \n    mock.one, mock.two, mock.three\n    \n    for One, Two in [(_One, _Two), (['one'], ['two'])]:\n     for kwargs in dict(), dict(spec_set=True):\n      mock.mock_add_spec(One, **kwargs)\n      \n      mock.one\n      self.assertRaises(\n      AttributeError, getattr, mock, 'two'\n      )\n      self.assertRaises(\n      AttributeError, getattr, mock, 'three'\n      )\n      if 'spec_set' in kwargs:\n       self.assertRaises(\n       AttributeError, setattr, mock, 'three', None\n       )\n       \n      mock.mock_add_spec(Two, **kwargs)\n      self.assertRaises(\n      AttributeError, getattr, mock, 'one'\n      )\n      mock.two\n      self.assertRaises(\n      AttributeError, getattr, mock, 'three'\n      )\n      if 'spec_set' in kwargs:\n       self.assertRaises(\n       AttributeError, setattr, mock, 'three', None\n       )\n       \n       \n       \n       \n def test_mock_add_spec_magic_methods(self):\n  for Klass in MagicMock, NonCallableMagicMock:\n   mock = Klass()\n   int(mock)\n   \n   mock.mock_add_spec(object)\n   self.assertRaises(TypeError, int, mock)\n   \n   mock = Klass()\n   mock['foo']\n   mock.__int__.return_value =4\n   \n   mock.mock_add_spec(int)\n   self.assertEqual(int(mock), 4)\n   self.assertRaises(TypeError, lambda: mock['foo'])\n   \n   \n def test_adding_child_mock(self):\n  for Klass in NonCallableMock, Mock, MagicMock, NonCallableMagicMock:\n   mock = Klass()\n   \n   mock.foo = Mock()\n   mock.foo()\n   \n   self.assertEqual(mock.method_calls, [call.foo()])\n   self.assertEqual(mock.mock_calls, [call.foo()])\n   \n   mock = Klass()\n   mock.bar = Mock(name='name')\n   mock.bar()\n   self.assertEqual(mock.method_calls, [])\n   self.assertEqual(mock.mock_calls, [])\n   \n   \n   mock = Klass()\n   mock.baz = MagicMock()()\n   mock.baz()\n   self.assertEqual(mock.method_calls, [])\n   self.assertEqual(mock.mock_calls, [])\n   \n   \n def test_adding_return_value_mock(self):\n  for Klass in Mock, MagicMock:\n   mock = Klass()\n   mock.return_value = MagicMock()\n   \n   mock()()\n   self.assertEqual(mock.mock_calls, [call(), call()()])\n   \n   \n def test_manager_mock(self):\n  class Foo(object):\n   one = 'one'\n   two = 'two'\n  manager = Mock()\n  p1 = patch.object(Foo, 'one')\n  p2 = patch.object(Foo, 'two')\n  \n  mock_one = p1.start()\n  self.addCleanup(p1.stop)\n  mock_two = p2.start()\n  self.addCleanup(p2.stop)\n  \n  manager.attach_mock(mock_one, 'one')\n  manager.attach_mock(mock_two, 'two')\n  \n  Foo.two()\n  Foo.one()\n  \n  self.assertEqual(manager.mock_calls, [call.two(), call.one()])\n  \n  \n def test_magic_methods_mock_calls(self):\n  for Klass in Mock, MagicMock:\n   m = Klass()\n   m.__int__ = Mock(return_value=3)\n   m.__float__ = MagicMock(return_value=3.0)\n   int(m)\n   float(m)\n   \n   self.assertEqual(m.mock_calls, [call.__int__(), call.__float__()])\n   self.assertEqual(m.method_calls, [])\n   \n   \n def test_attribute_deletion(self):\n \n  for Klass in Mock, MagicMock, NonCallableMagicMock, NonCallableMock:\n   m = Klass()\n   original = m.foo\n   m.foo = 3\n   del m.foo\n   self.assertEqual(m.foo, original)\n   \n   new = m.foo = Mock()\n   del m.foo\n   self.assertEqual(m.foo, new)\n   \n   \n def test_mock_parents(self):\n  for Klass in Mock, MagicMock:\n   m = Klass()\n   original_repr = repr(m)\n   m.return_value = m\n   self.assertIs(m(), m)\n   self.assertEqual(repr(m), original_repr)\n   \n   m.reset_mock()\n   self.assertIs(m(), m)\n   self.assertEqual(repr(m), original_repr)\n   \n   m = Klass()\n   m.b = m.a\n   self.assertIn(\"name='mock.a'\", repr(m.b))\n   self.assertIn(\"name='mock.a'\", repr(m.a))\n   m.reset_mock()\n   self.assertIn(\"name='mock.a'\", repr(m.b))\n   self.assertIn(\"name='mock.a'\", repr(m.a))\n   \n   m = Klass()\n   original_repr = repr(m)\n   m.a = m()\n   m.a.return_value = m\n   \n   self.assertEqual(repr(m), original_repr)\n   self.assertEqual(repr(m.a()), original_repr)\n   \n   \n def test_attach_mock(self):\n  classes = Mock, MagicMock, NonCallableMagicMock, NonCallableMock\n  for Klass in classes:\n   for Klass2 in classes:\n    m = Klass()\n    \n    m2 = Klass2(name='foo')\n    m.attach_mock(m2, 'bar')\n    \n    self.assertIs(m.bar, m2)\n    self.assertIn(\"name='mock.bar'\", repr(m2))\n    \n    m.bar.baz(1)\n    self.assertEqual(m.mock_calls, [call.bar.baz(1)])\n    self.assertEqual(m.method_calls, [call.bar.baz(1)])\n    \n    \n def test_attach_mock_return_value(self):\n  classes = Mock, MagicMock, NonCallableMagicMock, NonCallableMock\n  for Klass in Mock, MagicMock:\n   for Klass2 in classes:\n    m = Klass()\n    \n    m2 = Klass2(name='foo')\n    m.attach_mock(m2, 'return_value')\n    \n    self.assertIs(m(), m2)\n    self.assertIn(\"name='mock()'\", repr(m2))\n    \n    m2.foo()\n    self.assertEqual(m.mock_calls, call().foo().call_list())\n    \n    \n def test_attribute_deletion(self):\n  for mock in Mock(), MagicMock():\n   self.assertTrue(hasattr(mock, 'm'))\n   \n   del mock.m\n   self.assertFalse(hasattr(mock, 'm'))\n   \n   del mock.f\n   self.assertFalse(hasattr(mock, 'f'))\n   self.assertRaises(AttributeError, getattr, mock, 'f')\n   \n   \n def test_class_assignable(self):\n  for mock in Mock(), MagicMock():\n   self.assertNotIsInstance(mock, int)\n   \n   mock.__class__ = int\n   self.assertIsInstance(mock, int)\n   mock.foo\n   \n   \n   \nif __name__ == '__main__':\n unittest.main()\n"], "test.pystone": ["\n\n\"\"\n\nLOOPS = 50000\n\nfrom time import clock\n\n__version__ = \"1.1\"\n\n[Ident1, Ident2, Ident3, Ident4, Ident5] = range(1, 6)\n\nclass Record:\n\n def __init__(self, PtrComp = None, Discr = 0, EnumComp = 0,\n IntComp = 0, StringComp = 0):\n  self.PtrComp = PtrComp\n  self.Discr = Discr\n  self.EnumComp = EnumComp\n  self.IntComp = IntComp\n  self.StringComp = StringComp\n  \n def copy(self):\n  return Record(self.PtrComp, self.Discr, self.EnumComp,\n  self.IntComp, self.StringComp)\n  \nTRUE = 1\nFALSE = 0\n\ndef main(loops=LOOPS):\n benchtime, stones = pystones(loops)\n print(\"Pystone(%s) time for %d passes = %g\" % (__version__, loops, benchtime))\n print(\"This machine benchmarks at %g pystones/second\" % stones)\n \n \ndef pystones(loops=LOOPS):\n return Proc0(loops)\n \nIntGlob = 0\nBoolGlob = FALSE\nChar1Glob = '\\0'\nChar2Glob = '\\0'\nArray1Glob = [0]*51\nArray2Glob = [x[:] for x in [Array1Glob]*51]\nPtrGlb = None\nPtrGlbNext = None\n\ndef Proc0(loops=LOOPS):\n global IntGlob\n global BoolGlob\n global Char1Glob\n global Char2Glob\n global Array1Glob\n global Array2Glob\n global PtrGlb\n global PtrGlbNext\n \n starttime = clock()\n for i in range(loops):\n  pass\n nulltime = clock() - starttime\n \n PtrGlbNext = Record()\n PtrGlb = Record()\n PtrGlb.PtrComp = PtrGlbNext\n PtrGlb.Discr = Ident1\n PtrGlb.EnumComp = Ident3\n PtrGlb.IntComp = 40\n PtrGlb.StringComp = \"DHRYSTONE PROGRAM, SOME STRING\"\n String1Loc = \"DHRYSTONE PROGRAM, 1'ST STRING\"\n Array2Glob[8][7] = 10\n \n starttime = clock()\n \n for i in range(loops):\n  Proc5()\n  Proc4()\n  IntLoc1 = 2\n  IntLoc2 = 3\n  String2Loc = \"DHRYSTONE PROGRAM, 2'ND STRING\"\n  EnumLoc = Ident2\n  BoolGlob = not Func2(String1Loc, String2Loc)\n  while IntLoc1 < IntLoc2:\n   IntLoc3 = 5 * IntLoc1 - IntLoc2\n   IntLoc3 = Proc7(IntLoc1, IntLoc2)\n   IntLoc1 = IntLoc1 + 1\n  Proc8(Array1Glob, Array2Glob, IntLoc1, IntLoc3)\n  PtrGlb = Proc1(PtrGlb)\n  CharIndex = 'A'\n  while CharIndex <= Char2Glob:\n   if EnumLoc == Func1(CharIndex, 'C'):\n    EnumLoc = Proc6(Ident1)\n   CharIndex = chr(ord(CharIndex)+1)\n  IntLoc3 = IntLoc2 * IntLoc1\n  IntLoc2 = IntLoc3 / IntLoc1\n  IntLoc2 = 7 * (IntLoc3 - IntLoc2) - IntLoc1\n  IntLoc1 = Proc2(IntLoc1)\n  \n benchtime = clock() - starttime - nulltime\n if benchtime == 0.0:\n  loopsPerBenchtime = 0.0\n else:\n  loopsPerBenchtime = (loops / benchtime)\n return benchtime, loopsPerBenchtime\n \ndef Proc1(PtrParIn):\n PtrParIn.PtrComp = NextRecord = PtrGlb.copy()\n PtrParIn.IntComp = 5\n NextRecord.IntComp = PtrParIn.IntComp\n NextRecord.PtrComp = PtrParIn.PtrComp\n NextRecord.PtrComp = Proc3(NextRecord.PtrComp)\n if NextRecord.Discr == Ident1:\n  NextRecord.IntComp = 6\n  NextRecord.EnumComp = Proc6(PtrParIn.EnumComp)\n  NextRecord.PtrComp = PtrGlb.PtrComp\n  NextRecord.IntComp = Proc7(NextRecord.IntComp, 10)\n else:\n  PtrParIn = NextRecord.copy()\n NextRecord.PtrComp = None\n return PtrParIn\n \ndef Proc2(IntParIO):\n IntLoc = IntParIO + 10\n while 1:\n  if Char1Glob == 'A':\n   IntLoc = IntLoc - 1\n   IntParIO = IntLoc - IntGlob\n   EnumLoc = Ident1\n  if EnumLoc == Ident1:\n   break\n return IntParIO\n \ndef Proc3(PtrParOut):\n global IntGlob\n \n if PtrGlb is not None:\n  PtrParOut = PtrGlb.PtrComp\n else:\n  IntGlob = 100\n PtrGlb.IntComp = Proc7(10, IntGlob)\n return PtrParOut\n \ndef Proc4():\n global Char2Glob\n \n BoolLoc = Char1Glob == 'A'\n BoolLoc = BoolLoc or BoolGlob\n Char2Glob = 'B'\n \ndef Proc5():\n global Char1Glob\n global BoolGlob\n \n Char1Glob = 'A'\n BoolGlob = FALSE\n \ndef Proc6(EnumParIn):\n EnumParOut = EnumParIn\n if not Func3(EnumParIn):\n  EnumParOut = Ident4\n if EnumParIn == Ident1:\n  EnumParOut = Ident1\n elif EnumParIn == Ident2:\n  if IntGlob > 100:\n   EnumParOut = Ident1\n  else:\n   EnumParOut = Ident4\n elif EnumParIn == Ident3:\n  EnumParOut = Ident2\n elif EnumParIn == Ident4:\n  pass\n elif EnumParIn == Ident5:\n  EnumParOut = Ident3\n return EnumParOut\n \ndef Proc7(IntParI1, IntParI2):\n IntLoc = IntParI1 + 2\n IntParOut = IntParI2 + IntLoc\n return IntParOut\n \ndef Proc8(Array1Par, Array2Par, IntParI1, IntParI2):\n global IntGlob\n \n IntLoc = IntParI1 + 5\n Array1Par[IntLoc] = IntParI2\n Array1Par[IntLoc+1] = Array1Par[IntLoc]\n Array1Par[IntLoc+30] = IntLoc\n for IntIndex in range(IntLoc, IntLoc+2):\n  Array2Par[IntLoc][IntIndex] = IntLoc\n Array2Par[IntLoc][IntLoc-1] = Array2Par[IntLoc][IntLoc-1] + 1\n Array2Par[IntLoc+20][IntLoc] = Array1Par[IntLoc]\n IntGlob = 5\n \ndef Func1(CharPar1, CharPar2):\n CharLoc1 = CharPar1\n CharLoc2 = CharLoc1\n if CharLoc2 != CharPar2:\n  return Ident1\n else:\n  return Ident2\n  \ndef Func2(StrParI1, StrParI2):\n IntLoc = 1\n while IntLoc <= 1:\n  if Func1(StrParI1[IntLoc], StrParI2[IntLoc+1]) == Ident1:\n   CharLoc = 'A'\n   IntLoc = IntLoc + 1\n if CharLoc >= 'W' and CharLoc <= 'Z':\n  IntLoc = 7\n if CharLoc == 'X':\n  return TRUE\n else:\n  if StrParI1 > StrParI2:\n   IntLoc = IntLoc + 7\n   return TRUE\n  else:\n   return FALSE\n   \ndef Func3(EnumParIn):\n EnumLoc = EnumParIn\n if EnumLoc == Ident3: return TRUE\n return FALSE\n \nif __name__ == '__main__':\n import sys\n def error(msg):\n  print(msg, end=' ', file=sys.stderr)\n  print(\"usage: %s [number_of_loops]\" % sys.argv[0], file=sys.stderr)\n  sys.exit(100)\n nargs = len(sys.argv) - 1\n if nargs > 1:\n  error(\"%d arguments are too many;\" % nargs)\n elif nargs == 1:\n  try: loops = int(sys.argv[1])\n  except ValueError:\n   error(\"Invalid argument %r;\" % sys.argv[1])\n else:\n  loops = LOOPS\n main(loops)\n"], "unittest.signals": ["import signal\nimport weakref\n\nfrom functools import wraps\n\n__unittest = True\n\n\nclass _InterruptHandler(object):\n def __init__(self, default_handler):\n  self.called = False\n  self.original_handler = default_handler\n  if isinstance(default_handler, int):\n   if default_handler == signal.SIG_DFL:\n   \n    default_handler = signal.default_int_handler\n   elif default_handler == signal.SIG_IGN:\n   \n   \n    def default_handler(unused_signum, unused_frame):\n     pass\n   else:\n    raise TypeError(\"expected SIGINT signal handler to be \"\n    \"signal.SIG_IGN, signal.SIG_DFL, or a \"\n    \"callable object\")\n  self.default_handler = default_handler\n  \n def __call__(self, signum, frame):\n  installed_handler = signal.getsignal(signal.SIGINT)\n  if installed_handler is not self:\n  \n  \n   self.default_handler(signum, frame)\n   \n  if self.called:\n   self.default_handler(signum, frame)\n  self.called = True\n  for result in _results.keys():\n   result.stop()\n   \n_results = weakref.WeakKeyDictionary()\ndef registerResult(result):\n _results[result] = 1\n \ndef removeResult(result):\n return bool(_results.pop(result, None))\n \n_interrupt_handler = None\ndef installHandler():\n global _interrupt_handler\n if _interrupt_handler is None:\n  default_handler = signal.getsignal(signal.SIGINT)\n  _interrupt_handler = _InterruptHandler(default_handler)\n  signal.signal(signal.SIGINT, _interrupt_handler)\n  \n  \ndef removeHandler(method=None):\n if method is not None:\n  @wraps(method)\n  def inner(*args, **kwargs):\n   initial = signal.getsignal(signal.SIGINT)\n   removeHandler()\n   try:\n    return method(*args, **kwargs)\n   finally:\n    signal.signal(signal.SIGINT, initial)\n  return inner\n  \n global _interrupt_handler\n if _interrupt_handler is not None:\n  signal.signal(signal.SIGINT, _interrupt_handler.original_handler)\n"], "unittest.util": ["\"\"\n\nfrom collections import namedtuple, OrderedDict\n\n__unittest = True\n\n_MAX_LENGTH = 80\ndef safe_repr(obj, short=False):\n try:\n  result = repr(obj)\n except Exception:\n  result = object.__repr__(obj)\n if not short or len(result) < _MAX_LENGTH:\n  return result\n return result[:_MAX_LENGTH] + ' [truncated]...'\n \ndef strclass(cls):\n return \"%s.%s\" % (cls.__module__, cls.__name__)\n \ndef sorted_list_difference(expected, actual):\n \"\"\n i = j = 0\n missing = []\n unexpected = []\n while True:\n  try:\n   e = expected[i]\n   a = actual[j]\n   if e < a:\n    missing.append(e)\n    i += 1\n    while expected[i] == e:\n     i += 1\n   elif e > a:\n    unexpected.append(a)\n    j += 1\n    while actual[j] == a:\n     j += 1\n   else:\n    i += 1\n    try:\n     while expected[i] == e:\n      i += 1\n    finally:\n     j += 1\n     while actual[j] == a:\n      j += 1\n  except IndexError:\n   missing.extend(expected[i:])\n   unexpected.extend(actual[j:])\n   break\n return missing, unexpected\n \n \ndef unorderable_list_difference(expected, actual):\n \"\"\n missing = []\n while expected:\n  item = expected.pop()\n  try:\n   actual.remove(item)\n  except ValueError:\n   missing.append(item)\n   \n   \n return missing, actual\n \ndef three_way_cmp(x, y):\n \"\"\n return (x > y) - (x < y)\n \n_Mismatch = namedtuple('Mismatch', 'actual expected value')\n\ndef _count_diff_all_purpose(actual, expected):\n \"\"\n \n s, t = list(actual), list(expected)\n m, n = len(s), len(t)\n NULL = object()\n result = []\n for i, elem in enumerate(s):\n  if elem is NULL:\n   continue\n  cnt_s = cnt_t = 0\n  for j in range(i, m):\n   if s[j] == elem:\n    cnt_s += 1\n    s[j] = NULL\n  for j, other_elem in enumerate(t):\n   if other_elem == elem:\n    cnt_t += 1\n    t[j] = NULL\n  if cnt_s != cnt_t:\n   diff = _Mismatch(cnt_s, cnt_t, elem)\n   result.append(diff)\n   \n for i, elem in enumerate(t):\n  if elem is NULL:\n   continue\n  cnt_t = 0\n  for j in range(i, n):\n   if t[j] == elem:\n    cnt_t += 1\n    t[j] = NULL\n  diff = _Mismatch(0, cnt_t, elem)\n  result.append(diff)\n return result\n \ndef _ordered_count(iterable):\n \"\"\n c = OrderedDict()\n for elem in iterable:\n  c[elem] = c.get(elem, 0) + 1\n return c\n \ndef _count_diff_hashable(actual, expected):\n \"\"\n \n s, t = _ordered_count(actual), _ordered_count(expected)\n result = []\n for elem, cnt_s in s.items():\n  cnt_t = t.get(elem, 0)\n  if cnt_s != cnt_t:\n   diff = _Mismatch(cnt_s, cnt_t, elem)\n   result.append(diff)\n for elem, cnt_t in t.items():\n  if elem not in s:\n   diff = _Mismatch(0, cnt_t, elem)\n   result.append(diff)\n return result\n"], "unittest.test.test_result": ["import io\nimport sys\nimport textwrap\n\nfrom test import support\n\nimport traceback\nimport unittest\n\n\nclass Test_TestResult(unittest.TestCase):\n\n\n\n\n\n\n\n\n\n def test_init(self):\n  result = unittest.TestResult()\n  \n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.failures), 0)\n  self.assertEqual(result.testsRun, 0)\n  self.assertEqual(result.shouldStop, False)\n  self.assertIsNone(result._stdout_buffer)\n  self.assertIsNone(result._stderr_buffer)\n  \n  \n  \n  \n def test_stop(self):\n  result = unittest.TestResult()\n  \n  result.stop()\n  \n  self.assertEqual(result.shouldStop, True)\n  \n  \n  \n def test_startTest(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n    \n  test = Foo('test_1')\n  \n  result = unittest.TestResult()\n  \n  result.startTest(test)\n  \n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.failures), 0)\n  self.assertEqual(result.testsRun, 1)\n  self.assertEqual(result.shouldStop, False)\n  \n  result.stopTest(test)\n  \n  \n  \n def test_stopTest(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n    \n  test = Foo('test_1')\n  \n  result = unittest.TestResult()\n  \n  result.startTest(test)\n  \n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.failures), 0)\n  self.assertEqual(result.testsRun, 1)\n  self.assertEqual(result.shouldStop, False)\n  \n  result.stopTest(test)\n  \n  \n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.failures), 0)\n  self.assertEqual(result.testsRun, 1)\n  self.assertEqual(result.shouldStop, False)\n  \n  \n def test_startTestRun_stopTestRun(self):\n  result = unittest.TestResult()\n  result.startTestRun()\n  result.stopTestRun()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_addSuccess(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n    \n  test = Foo('test_1')\n  \n  result = unittest.TestResult()\n  \n  result.startTest(test)\n  result.addSuccess(test)\n  result.stopTest(test)\n  \n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.failures), 0)\n  self.assertEqual(result.testsRun, 1)\n  self.assertEqual(result.shouldStop, False)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_addFailure(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n    \n  test = Foo('test_1')\n  try:\n   test.fail(\"foo\")\n  except:\n   exc_info_tuple = sys.exc_info()\n   \n  result = unittest.TestResult()\n  \n  result.startTest(test)\n  result.addFailure(test, exc_info_tuple)\n  result.stopTest(test)\n  \n  self.assertFalse(result.wasSuccessful())\n  self.assertEqual(len(result.errors), 0)\n  self.assertEqual(len(result.failures), 1)\n  self.assertEqual(result.testsRun, 1)\n  self.assertEqual(result.shouldStop, False)\n  \n  test_case, formatted_exc = result.failures[0]\n  self.assertTrue(test_case is test)\n  self.assertIsInstance(formatted_exc, str)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_addError(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n    \n  test = Foo('test_1')\n  try:\n   raise TypeError()\n  except:\n   exc_info_tuple = sys.exc_info()\n   \n  result = unittest.TestResult()\n  \n  result.startTest(test)\n  result.addError(test, exc_info_tuple)\n  result.stopTest(test)\n  \n  self.assertFalse(result.wasSuccessful())\n  self.assertEqual(len(result.errors), 1)\n  self.assertEqual(len(result.failures), 0)\n  self.assertEqual(result.testsRun, 1)\n  self.assertEqual(result.shouldStop, False)\n  \n  test_case, formatted_exc = result.errors[0]\n  self.assertTrue(test_case is test)\n  self.assertIsInstance(formatted_exc, str)\n  \n def testGetDescriptionWithoutDocstring(self):\n  result = unittest.TextTestResult(None, True, 1)\n  self.assertEqual(\n  result.getDescription(self),\n  'testGetDescriptionWithoutDocstring (' + __name__ +\n  '.Test_TestResult)')\n  \n @unittest.skipIf(sys.flags.optimize >= 2,\n \"Docstrings are omitted with -O2 and above\")\n def testGetDescriptionWithOneLineDocstring(self):\n  \"\"\n  result = unittest.TextTestResult(None, True, 1)\n  self.assertEqual(\n  result.getDescription(self),\n  ('testGetDescriptionWithOneLineDocstring '\n  '(' + __name__ + '.Test_TestResult)\\n'\n  'Tests getDescription() for a method with a docstring.'))\n  \n @unittest.skipIf(sys.flags.optimize >= 2,\n \"Docstrings are omitted with -O2 and above\")\n def testGetDescriptionWithMultiLineDocstring(self):\n  \"\"\n  result = unittest.TextTestResult(None, True, 1)\n  self.assertEqual(\n  result.getDescription(self),\n  ('testGetDescriptionWithMultiLineDocstring '\n  '(' + __name__ + '.Test_TestResult)\\n'\n  'Tests getDescription() for a method with a longer '\n  'docstring.'))\n  \n def testStackFrameTrimming(self):\n  class Frame(object):\n   class tb_frame(object):\n    f_globals = {}\n  result = unittest.TestResult()\n  self.assertFalse(result._is_relevant_tb_level(Frame))\n  \n  Frame.tb_frame.f_globals['__unittest'] = True\n  self.assertTrue(result._is_relevant_tb_level(Frame))\n  \n def testFailFast(self):\n  result = unittest.TestResult()\n  result._exc_info_to_string = lambda *_: ''\n  result.failfast = True\n  result.addError(None, None)\n  self.assertTrue(result.shouldStop)\n  \n  result = unittest.TestResult()\n  result._exc_info_to_string = lambda *_: ''\n  result.failfast = True\n  result.addFailure(None, None)\n  self.assertTrue(result.shouldStop)\n  \n  result = unittest.TestResult()\n  result._exc_info_to_string = lambda *_: ''\n  result.failfast = True\n  result.addUnexpectedSuccess(None)\n  self.assertTrue(result.shouldStop)\n  \n def testFailFastSetByRunner(self):\n  runner = unittest.TextTestRunner(stream=io.StringIO(), failfast=True)\n  def test(result):\n   self.assertTrue(result.failfast)\n  result = runner.run(test)\n  \n  \nclassDict = dict(unittest.TestResult.__dict__)\nfor m in ('addSkip', 'addExpectedFailure', 'addUnexpectedSuccess',\n'__init__'):\n del classDict[m]\n \ndef __init__(self, stream=None, descriptions=None, verbosity=None):\n self.failures = []\n self.errors = []\n self.testsRun = 0\n self.shouldStop = False\n self.buffer = False\n \nclassDict['__init__'] = __init__\nOldResult = type('OldResult', (object,), classDict)\n\nclass Test_OldTestResult(unittest.TestCase):\n\n def assertOldResultWarning(self, test, failures):\n  with support.check_warnings((\"TestResult has no add.+ method,\",\n  RuntimeWarning)):\n   result = OldResult()\n   test.run(result)\n   self.assertEqual(len(result.failures), failures)\n   \n def testOldTestResult(self):\n  class Test(unittest.TestCase):\n   def testSkip(self):\n    self.skipTest('foobar')\n   @unittest.expectedFailure\n   def testExpectedFail(self):\n    raise TypeError\n   @unittest.expectedFailure\n   def testUnexpectedSuccess(self):\n    pass\n    \n  for test_name, should_pass in (('testSkip', True),\n  ('testExpectedFail', True),\n  ('testUnexpectedSuccess', False)):\n   test = Test(test_name)\n   self.assertOldResultWarning(test, int(not should_pass))\n   \n def testOldTestTesultSetup(self):\n  class Test(unittest.TestCase):\n   def setUp(self):\n    self.skipTest('no reason')\n   def testFoo(self):\n    pass\n  self.assertOldResultWarning(Test('testFoo'), 0)\n  \n def testOldTestResultClass(self):\n  @unittest.skip('no reason')\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  self.assertOldResultWarning(Test('testFoo'), 0)\n  \n def testOldResultWithRunner(self):\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  runner = unittest.TextTestRunner(resultclass=OldResult,\n  stream=io.StringIO())\n  \n  \n  runner.run(Test('testFoo'))\n  \n  \nclass MockTraceback(object):\n @staticmethod\n def format_exception(*_):\n  return ['A traceback']\n  \ndef restore_traceback():\n unittest.result.traceback = traceback\n \n \nclass TestOutputBuffering(unittest.TestCase):\n\n def setUp(self):\n  self._real_out = sys.stdout\n  self._real_err = sys.stderr\n  \n def tearDown(self):\n  sys.stdout = self._real_out\n  sys.stderr = self._real_err\n  \n def testBufferOutputOff(self):\n  real_out = self._real_out\n  real_err = self._real_err\n  \n  result = unittest.TestResult()\n  self.assertFalse(result.buffer)\n  \n  self.assertIs(real_out, sys.stdout)\n  self.assertIs(real_err, sys.stderr)\n  \n  result.startTest(self)\n  \n  self.assertIs(real_out, sys.stdout)\n  self.assertIs(real_err, sys.stderr)\n  \n def testBufferOutputStartTestAddSuccess(self):\n  real_out = self._real_out\n  real_err = self._real_err\n  \n  result = unittest.TestResult()\n  self.assertFalse(result.buffer)\n  \n  result.buffer = True\n  \n  self.assertIs(real_out, sys.stdout)\n  self.assertIs(real_err, sys.stderr)\n  \n  result.startTest(self)\n  \n  self.assertIsNot(real_out, sys.stdout)\n  self.assertIsNot(real_err, sys.stderr)\n  self.assertIsInstance(sys.stdout, io.StringIO)\n  self.assertIsInstance(sys.stderr, io.StringIO)\n  self.assertIsNot(sys.stdout, sys.stderr)\n  \n  out_stream = sys.stdout\n  err_stream = sys.stderr\n  \n  result._original_stdout = io.StringIO()\n  result._original_stderr = io.StringIO()\n  \n  print('foo')\n  print('bar', file=sys.stderr)\n  \n  self.assertEqual(out_stream.getvalue(), 'foo\\n')\n  self.assertEqual(err_stream.getvalue(), 'bar\\n')\n  \n  self.assertEqual(result._original_stdout.getvalue(), '')\n  self.assertEqual(result._original_stderr.getvalue(), '')\n  \n  result.addSuccess(self)\n  result.stopTest(self)\n  \n  self.assertIs(sys.stdout, result._original_stdout)\n  self.assertIs(sys.stderr, result._original_stderr)\n  \n  self.assertEqual(result._original_stdout.getvalue(), '')\n  self.assertEqual(result._original_stderr.getvalue(), '')\n  \n  self.assertEqual(out_stream.getvalue(), '')\n  self.assertEqual(err_stream.getvalue(), '')\n  \n  \n def getStartedResult(self):\n  result = unittest.TestResult()\n  result.buffer = True\n  result.startTest(self)\n  return result\n  \n def testBufferOutputAddErrorOrFailure(self):\n  unittest.result.traceback = MockTraceback\n  self.addCleanup(restore_traceback)\n  \n  for message_attr, add_attr, include_error in [\n  ('errors', 'addError', True),\n  ('failures', 'addFailure', False),\n  ('errors', 'addError', True),\n  ('failures', 'addFailure', False)\n  ]:\n   result = self.getStartedResult()\n   buffered_out = sys.stdout\n   buffered_err = sys.stderr\n   result._original_stdout = io.StringIO()\n   result._original_stderr = io.StringIO()\n   \n   print('foo', file=sys.stdout)\n   if include_error:\n    print('bar', file=sys.stderr)\n    \n    \n   addFunction = getattr(result, add_attr)\n   addFunction(self, (None, None, None))\n   result.stopTest(self)\n   \n   result_list = getattr(result, message_attr)\n   self.assertEqual(len(result_list), 1)\n   \n   test, message = result_list[0]\n   expectedOutMessage = textwrap.dedent(\"\"\"\n                Stdout:\n                foo\n            \"\"\"   )\n   expectedErrMessage = ''\n   if include_error:\n    expectedErrMessage = textwrap.dedent(\"\"\"\n                Stderr:\n                bar\n            \"\"\"    )\n    \n   expectedFullMessage = 'A traceback%s%s' % (expectedOutMessage, expectedErrMessage)\n   \n   self.assertIs(test, self)\n   self.assertEqual(result._original_stdout.getvalue(), expectedOutMessage)\n   self.assertEqual(result._original_stderr.getvalue(), expectedErrMessage)\n   self.assertMultiLineEqual(message, expectedFullMessage)\n   \n def testBufferSetupClass(self):\n  result = unittest.TestResult()\n  result.buffer = True\n  \n  class Foo(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    1/0\n   def test_foo(self):\n    pass\n  suite = unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors), 1)\n  \n def testBufferTearDownClass(self):\n  result = unittest.TestResult()\n  result.buffer = True\n  \n  class Foo(unittest.TestCase):\n   @classmethod\n   def tearDownClass(cls):\n    1/0\n   def test_foo(self):\n    pass\n  suite = unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors), 1)\n  \n def testBufferSetUpModule(self):\n  result = unittest.TestResult()\n  result.buffer = True\n  \n  class Foo(unittest.TestCase):\n   def test_foo(self):\n    pass\n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    1/0\n    \n  Foo.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  self.addCleanup(sys.modules.pop, 'Module')\n  suite = unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors), 1)\n  \n def testBufferTearDownModule(self):\n  result = unittest.TestResult()\n  result.buffer = True\n  \n  class Foo(unittest.TestCase):\n   def test_foo(self):\n    pass\n  class Module(object):\n   @staticmethod\n   def tearDownModule():\n    1/0\n    \n  Foo.__module__ = 'Module'\n  sys.modules['Module'] = Module\n  self.addCleanup(sys.modules.pop, 'Module')\n  suite = unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors), 1)\n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.test.dummy": ["\n"], "unittest.test.test_skipping": ["import unittest\n\nfrom .support import LoggingResult\n\n\nclass Test_TestSkipping(unittest.TestCase):\n\n def test_skipping(self):\n  class Foo(unittest.TestCase):\n   def test_skip_me(self):\n    self.skipTest(\"skip\")\n  events = []\n  result = LoggingResult(events)\n  test = Foo(\"test_skip_me\")\n  test.run(result)\n  self.assertEqual(events, ['startTest', 'addSkip', 'stopTest'])\n  self.assertEqual(result.skipped, [(test, \"skip\")])\n  \n  \n  class Foo(unittest.TestCase):\n   def setUp(self):\n    self.skipTest(\"testing\")\n   def test_nothing(self): pass\n  events = []\n  result = LoggingResult(events)\n  test = Foo(\"test_nothing\")\n  test.run(result)\n  self.assertEqual(events, ['startTest', 'addSkip', 'stopTest'])\n  self.assertEqual(result.skipped, [(test, \"testing\")])\n  self.assertEqual(result.testsRun, 1)\n  \n def test_skipping_decorators(self):\n  op_table = ((unittest.skipUnless, False, True),\n  (unittest.skipIf, True, False))\n  for deco, do_skip, dont_skip in op_table:\n   class Foo(unittest.TestCase):\n    @deco(do_skip, \"testing\")\n    def test_skip(self): pass\n    \n    @deco(dont_skip, \"testing\")\n    def test_dont_skip(self): pass\n   test_do_skip = Foo(\"test_skip\")\n   test_dont_skip = Foo(\"test_dont_skip\")\n   suite = unittest.TestSuite([test_do_skip, test_dont_skip])\n   events = []\n   result = LoggingResult(events)\n   suite.run(result)\n   self.assertEqual(len(result.skipped), 1)\n   expected = ['startTest', 'addSkip', 'stopTest',\n   'startTest', 'addSuccess', 'stopTest']\n   self.assertEqual(events, expected)\n   self.assertEqual(result.testsRun, 2)\n   self.assertEqual(result.skipped, [(test_do_skip, \"testing\")])\n   self.assertTrue(result.wasSuccessful())\n   \n def test_skip_class(self):\n  @unittest.skip(\"testing\")\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    record.append(1)\n  record = []\n  result = unittest.TestResult()\n  test = Foo(\"test_1\")\n  suite = unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped, [(test, \"testing\")])\n  self.assertEqual(record, [])\n  \n def test_skip_non_unittest_class(self):\n  @unittest.skip(\"testing\")\n  class Mixin:\n   def test_1(self):\n    record.append(1)\n  class Foo(Mixin, unittest.TestCase):\n   pass\n  record = []\n  result = unittest.TestResult()\n  test = Foo(\"test_1\")\n  suite = unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped, [(test, \"testing\")])\n  self.assertEqual(record, [])\n  \n def test_expected_failure(self):\n  class Foo(unittest.TestCase):\n   @unittest.expectedFailure\n   def test_die(self):\n    self.fail(\"help me!\")\n  events = []\n  result = LoggingResult(events)\n  test = Foo(\"test_die\")\n  test.run(result)\n  self.assertEqual(events,\n  ['startTest', 'addExpectedFailure', 'stopTest'])\n  self.assertEqual(result.expectedFailures[0][0], test)\n  self.assertTrue(result.wasSuccessful())\n  \n def test_unexpected_success(self):\n  class Foo(unittest.TestCase):\n   @unittest.expectedFailure\n   def test_die(self):\n    pass\n  events = []\n  result = LoggingResult(events)\n  test = Foo(\"test_die\")\n  test.run(result)\n  self.assertEqual(events,\n  ['startTest', 'addUnexpectedSuccess', 'stopTest'])\n  self.assertFalse(result.failures)\n  self.assertEqual(result.unexpectedSuccesses, [test])\n  self.assertTrue(result.wasSuccessful())\n  \n def test_skip_doesnt_run_setup(self):\n  class Foo(unittest.TestCase):\n   wasSetUp = False\n   wasTornDown = False\n   def setUp(self):\n    Foo.wasSetUp = True\n   def tornDown(self):\n    Foo.wasTornDown = True\n   @unittest.skip('testing')\n   def test_1(self):\n    pass\n    \n  result = unittest.TestResult()\n  test = Foo(\"test_1\")\n  suite = unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped, [(test, \"testing\")])\n  self.assertFalse(Foo.wasSetUp)\n  self.assertFalse(Foo.wasTornDown)\n  \n def test_decorated_skip(self):\n  def decorator(func):\n   def inner(*a):\n    return func(*a)\n   return inner\n   \n  class Foo(unittest.TestCase):\n   @decorator\n   @unittest.skip('testing')\n   def test_1(self):\n    pass\n    \n  result = unittest.TestResult()\n  test = Foo(\"test_1\")\n  suite = unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped, [(test, \"testing\")])\n"], "unittest.loader": ["\"\"\n\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport functools\n\nfrom fnmatch import fnmatch\n\nfrom . import case, suite, util\n\n__unittest = True\n\n\n\n\nVALID_MODULE_NAME = re.compile(r'[_a-z]\\w*\\.py$', re.IGNORECASE)\n\n\ndef _make_failed_import_test(name, suiteClass):\n message = 'Failed to import test module: %s\\n%s' % (name, traceback.format_exc())\n return _make_failed_test('ModuleImportFailure', name, ImportError(message),\n suiteClass)\n \ndef _make_failed_load_tests(name, exception, suiteClass):\n return _make_failed_test('LoadTestsFailure', name, exception, suiteClass)\n \ndef _make_failed_test(classname, methodname, exception, suiteClass):\n def testFailure(self):\n  raise exception\n attrs = {methodname: testFailure}\n TestClass = type(classname, (case.TestCase,), attrs)\n return suiteClass((TestClass(methodname),))\n \ndef _jython_aware_splitext(path):\n if path.lower().endswith('$py.class'):\n  return path[:-9]\n return os.path.splitext(path)[0]\n \n \nclass TestLoader(object):\n \"\"\n testMethodPrefix = 'test'\n sortTestMethodsUsing = staticmethod(util.three_way_cmp)\n suiteClass = suite.TestSuite\n _top_level_dir = None\n \n def loadTestsFromTestCase(self, testCaseClass):\n  \"\"\n  if issubclass(testCaseClass, suite.TestSuite):\n   raise TypeError(\"Test cases should not be derived from TestSuite.\" \" Maybe you meant to derive from TestCase?\")\n  testCaseNames = self.getTestCaseNames(testCaseClass)\n  if not testCaseNames and hasattr(testCaseClass, 'runTest'):\n   testCaseNames = ['runTest']\n  loaded_suite = self.suiteClass(map(testCaseClass, testCaseNames))\n  return loaded_suite\n  \n def loadTestsFromModule(self, module, use_load_tests=True):\n  \"\"\n  tests = []\n  for name in dir(module):\n   obj = getattr(module, name)\n   if isinstance(obj, type) and issubclass(obj, case.TestCase):\n    tests.append(self.loadTestsFromTestCase(obj))\n    \n  load_tests = getattr(module, 'load_tests', None)\n  tests = self.suiteClass(tests)\n  if use_load_tests and load_tests is not None:\n   try:\n    return load_tests(self, tests, None)\n   except Exception as e:\n    return _make_failed_load_tests(module.__name__, e,\n    self.suiteClass)\n  return tests\n  \n def loadTestsFromName(self, name, module=None):\n  \"\"\n  parts = name.split('.')\n  if module is None:\n   parts_copy = parts[:]\n   while parts_copy:\n    try:\n     module = __import__('.'.join(parts_copy))\n     break\n    except ImportError:\n     del parts_copy[-1]\n     if not parts_copy:\n      raise\n   parts = parts[1:]\n  obj = module\n  for part in parts:\n   parent, obj = obj, getattr(obj, part)\n   \n  if isinstance(obj, types.ModuleType):\n   return self.loadTestsFromModule(obj)\n  elif isinstance(obj, type) and issubclass(obj, case.TestCase):\n   return self.loadTestsFromTestCase(obj)\n  elif (isinstance(obj, types.FunctionType) and\n  isinstance(parent, type) and\n  issubclass(parent, case.TestCase)):\n   name = parts[-1]\n   inst = parent(name)\n   \n   if not isinstance(getattr(inst, name), types.FunctionType):\n    return self.suiteClass([inst])\n  elif isinstance(obj, suite.TestSuite):\n   return obj\n  if callable(obj):\n   test = obj()\n   if isinstance(test, suite.TestSuite):\n    return test\n   elif isinstance(test, case.TestCase):\n    return self.suiteClass([test])\n   else:\n    raise TypeError(\"calling %s returned %s, not a test\" %\n    (obj, test))\n  else:\n   raise TypeError(\"don't know how to make test from: %s\" % obj)\n   \n def loadTestsFromNames(self, names, module=None):\n  \"\"\n  suites = [self.loadTestsFromName(name, module) for name in names]\n  return self.suiteClass(suites)\n  \n def getTestCaseNames(self, testCaseClass):\n  \"\"\n  def isTestMethod(attrname, testCaseClass=testCaseClass,\n  prefix=self.testMethodPrefix):\n   return attrname.startswith(prefix) and callable(getattr(testCaseClass, attrname))\n  testFnNames = list(filter(isTestMethod, dir(testCaseClass)))\n  if self.sortTestMethodsUsing:\n   testFnNames.sort(key=functools.cmp_to_key(self.sortTestMethodsUsing))\n  return testFnNames\n  \n def discover(self, start_dir, pattern='test*.py', top_level_dir=None):\n  \"\"\n  set_implicit_top = False\n  if top_level_dir is None and self._top_level_dir is not None:\n  \n   top_level_dir = self._top_level_dir\n  elif top_level_dir is None:\n   set_implicit_top = True\n   top_level_dir = start_dir\n   \n  top_level_dir = os.path.abspath(top_level_dir)\n  \n  if not top_level_dir in sys.path:\n  \n  \n  \n  \n   sys.path.insert(0, top_level_dir)\n  self._top_level_dir = top_level_dir\n  \n  is_not_importable = False\n  if os.path.isdir(os.path.abspath(start_dir)):\n   start_dir = os.path.abspath(start_dir)\n   if start_dir != top_level_dir:\n    is_not_importable = not os.path.isfile(os.path.join(start_dir, '__init__.py'))\n  else:\n  \n   try:\n    __import__(start_dir)\n   except ImportError:\n    is_not_importable = True\n   else:\n    the_module = sys.modules[start_dir]\n    top_part = start_dir.split('.')[0]\n    start_dir = os.path.abspath(os.path.dirname((the_module.__file__)))\n    if set_implicit_top:\n     self._top_level_dir = self._get_directory_containing_module(top_part)\n     sys.path.remove(top_level_dir)\n     \n  if is_not_importable:\n   raise ImportError('Start directory is not importable: %r' % start_dir)\n   \n  tests = list(self._find_tests(start_dir, pattern))\n  return self.suiteClass(tests)\n  \n def _get_directory_containing_module(self, module_name):\n  module = sys.modules[module_name]\n  full_path = os.path.abspath(module.__file__)\n  \n  if os.path.basename(full_path).lower().startswith('__init__.py'):\n   return os.path.dirname(os.path.dirname(full_path))\n  else:\n  \n  \n  \n   return os.path.dirname(full_path)\n   \n def _get_name_from_path(self, path):\n  path = _jython_aware_splitext(os.path.normpath(path))\n  \n  _relpath = os.path.relpath(path, self._top_level_dir)\n  assert not os.path.isabs(_relpath), \"Path must be within the project\"\n  assert not _relpath.startswith('..'), \"Path must be within the project\"\n  \n  name = _relpath.replace(os.path.sep, '.')\n  return name\n  \n def _get_module_from_name(self, name):\n  __import__(name)\n  return sys.modules[name]\n  \n def _match_path(self, path, full_path, pattern):\n \n  return fnmatch(path, pattern)\n  \n def _find_tests(self, start_dir, pattern):\n  \"\"\n  paths = os.listdir(start_dir)\n  \n  for path in paths:\n   full_path = os.path.join(start_dir, path)\n   if os.path.isfile(full_path):\n    if not VALID_MODULE_NAME.match(path):\n    \n     continue\n    if not self._match_path(path, full_path, pattern):\n     continue\n     \n    name = self._get_name_from_path(full_path)\n    try:\n     module = self._get_module_from_name(name)\n    except:\n     yield _make_failed_import_test(name, self.suiteClass)\n    else:\n     mod_file = os.path.abspath(getattr(module, '__file__', full_path))\n     realpath = _jython_aware_splitext(os.path.realpath(mod_file))\n     fullpath_noext = _jython_aware_splitext(os.path.realpath(full_path))\n     if realpath.lower() != fullpath_noext.lower():\n      module_dir = os.path.dirname(realpath)\n      mod_name = _jython_aware_splitext(os.path.basename(full_path))\n      expected_dir = os.path.dirname(full_path)\n      msg = (\"%r module incorrectly imported from %r. Expected %r. \"\n      \"Is this module globally installed?\")\n      raise ImportError(msg % (mod_name, module_dir, expected_dir))\n     yield self.loadTestsFromModule(module)\n   elif os.path.isdir(full_path):\n    if not os.path.isfile(os.path.join(full_path, '__init__.py')):\n     continue\n     \n    load_tests = None\n    tests = None\n    if fnmatch(path, pattern):\n    \n     name = self._get_name_from_path(full_path)\n     package = self._get_module_from_name(name)\n     load_tests = getattr(package, 'load_tests', None)\n     tests = self.loadTestsFromModule(package, use_load_tests=False)\n     \n    if load_tests is None:\n     if tests is not None:\n     \n      yield tests\n      \n     for test in self._find_tests(full_path, pattern):\n      yield test\n    else:\n     try:\n      yield load_tests(self, tests, pattern)\n     except Exception as e:\n      yield _make_failed_load_tests(package.__name__, e,\n      self.suiteClass)\n      \ndefaultTestLoader = TestLoader()\n\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n loader = TestLoader()\n loader.sortTestMethodsUsing = sortUsing\n loader.testMethodPrefix = prefix\n if suiteClass:\n  loader.suiteClass = suiteClass\n return loader\n \ndef getTestCaseNames(testCaseClass, prefix, sortUsing=util.three_way_cmp):\n return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n \ndef makeSuite(testCaseClass, prefix='test', sortUsing=util.three_way_cmp,\nsuiteClass=suite.TestSuite):\n return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(\n testCaseClass)\n \ndef findTestCases(module, prefix='test', sortUsing=util.three_way_cmp,\nsuiteClass=suite.TestSuite):\n return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule( module)\n"], "unittest.mock": ["\n\n\n\n\n\n__all__ = (\n'Mock',\n'MagicMock',\n'patch',\n'sentinel',\n'DEFAULT',\n'ANY',\n'call',\n'create_autospec',\n'FILTER_DIR',\n'NonCallableMock',\n'NonCallableMagicMock',\n'mock_open',\n'PropertyMock',\n)\n\n\n__version__ = '1.0'\n\n\nimport inspect\nimport pprint\nimport sys\nfrom functools import wraps\n\n\nBaseExceptions = (BaseException,)\nif 'java' in sys.platform:\n\n import java\n BaseExceptions = (BaseException, java.lang.Throwable)\n \n \nFILTER_DIR = True\n\n\n\n_safe_super = super\n\ndef _is_instance_mock(obj):\n\n\n return issubclass(type(obj), NonCallableMock)\n \n \ndef _is_exception(obj):\n return (\n isinstance(obj, BaseExceptions) or\n isinstance(obj, type) and issubclass(obj, BaseExceptions)\n )\n \n \nclass _slotted(object):\n __slots__ = ['a']\n \n \nDescriptorTypes = (\ntype(_slotted.a),\nproperty,\n)\n\n\ndef _getsignature(func, skipfirst, instance=False):\n if isinstance(func, type) and not instance:\n  try:\n   func = func.__init__\n  except AttributeError:\n   return\n  skipfirst = True\n elif not isinstance(func, FunctionTypes):\n \n  try:\n   func = func.__call__\n  except AttributeError:\n   return\n   \n try:\n  argspec = inspect.getfullargspec(func)\n except TypeError:\n \n  return\n  \n regargs, varargs, varkw, defaults, kwonly, kwonlydef, ann = argspec\n \n \n \n if getattr(func, '__self__', None) is not None:\n  regargs = regargs[1:]\n if skipfirst:\n \n  regargs = regargs[1:]\n  \n signature = inspect.formatargspec(\n regargs, varargs, varkw, defaults,\n kwonly, kwonlydef, ann, formatvalue=lambda value: \"\")\n return signature[1:-1], func\n \n \ndef _check_signature(func, mock, skipfirst, instance=False):\n if not _callable(func):\n  return\n  \n result = _getsignature(func, skipfirst, instance)\n if result is None:\n  return\n signature, func = result\n \n \n \n src = \"lambda _mock_self, %s: None\" % signature\n checksig = eval(src, {})\n _copy_func_details(func, checksig)\n type(mock)._mock_check_sig = checksig\n \n \ndef _copy_func_details(func, funcopy):\n funcopy.__name__ = func.__name__\n funcopy.__doc__ = func.__doc__\n \n \n funcopy.__module__ = func.__module__\n funcopy.__defaults__ = func.__defaults__\n funcopy.__kwdefaults__ = func.__kwdefaults__\n \n \ndef _callable(obj):\n if isinstance(obj, type):\n  return True\n if getattr(obj, '__call__', None) is not None:\n  return True\n return False\n \n \ndef _is_list(obj):\n\n\n return type(obj) in (list, tuple)\n \n \ndef _instance_callable(obj):\n \"\"\n if not isinstance(obj, type):\n \n  return getattr(obj, '__call__', None) is not None\n  \n  \n  \n for base in (obj,) + obj.__mro__:\n  if base.__dict__.get('__call__') is not None:\n   return True\n return False\n \n \ndef _set_signature(mock, original, instance=False):\n\n\n\n if not _callable(original):\n  return\n  \n skipfirst = isinstance(original, type)\n result = _getsignature(original, skipfirst, instance)\n if result is None:\n \n  return\n  \n signature, func = result\n \n src = \"lambda %s: None\" % signature\n checksig = eval(src, {})\n _copy_func_details(func, checksig)\n \n name = original.__name__\n if not name.isidentifier():\n  name = 'funcopy'\n context = {'_checksig_': checksig, 'mock': mock}\n src = \"\"\"def %s(*args, **kwargs):\n    _checksig_(*args, **kwargs)\n    return mock(*args, **kwargs)\"\"\" % name\n exec (src, context)\n funcopy = context[name]\n _setup_func(funcopy, mock)\n return funcopy\n \n \ndef _setup_func(funcopy, mock):\n funcopy.mock = mock\n \n \n if not _is_instance_mock(mock):\n  return\n  \n def assert_called_with(*args, **kwargs):\n  return mock.assert_called_with(*args, **kwargs)\n def assert_called_once_with(*args, **kwargs):\n  return mock.assert_called_once_with(*args, **kwargs)\n def assert_has_calls(*args, **kwargs):\n  return mock.assert_has_calls(*args, **kwargs)\n def assert_any_call(*args, **kwargs):\n  return mock.assert_any_call(*args, **kwargs)\n def reset_mock():\n  funcopy.method_calls = _CallList()\n  funcopy.mock_calls = _CallList()\n  mock.reset_mock()\n  ret = funcopy.return_value\n  if _is_instance_mock(ret) and not ret is mock:\n   ret.reset_mock()\n   \n funcopy.called = False\n funcopy.call_count = 0\n funcopy.call_args = None\n funcopy.call_args_list = _CallList()\n funcopy.method_calls = _CallList()\n funcopy.mock_calls = _CallList()\n \n funcopy.return_value = mock.return_value\n funcopy.side_effect = mock.side_effect\n funcopy._mock_children = mock._mock_children\n \n funcopy.assert_called_with = assert_called_with\n funcopy.assert_called_once_with = assert_called_once_with\n funcopy.assert_has_calls = assert_has_calls\n funcopy.assert_any_call = assert_any_call\n funcopy.reset_mock = reset_mock\n \n mock._mock_delegate = funcopy\n \n \ndef _is_magic(name):\n return '__%s__' % name[2:-2] == name\n \n \nclass _SentinelObject(object):\n \"\"\n def __init__(self, name):\n  self.name = name\n  \n def __repr__(self):\n  return 'sentinel.%s' % self.name\n  \n  \nclass _Sentinel(object):\n \"\"\n def __init__(self):\n  self._sentinels = {}\n  \n def __getattr__(self, name):\n  if name == '__bases__':\n  \n   raise AttributeError\n  return self._sentinels.setdefault(name, _SentinelObject(name))\n  \n  \nsentinel = _Sentinel()\n\nDEFAULT = sentinel.DEFAULT\n_missing = sentinel.MISSING\n_deleted = sentinel.DELETED\n\n\ndef _copy(value):\n if type(value) in (dict, list, tuple, set):\n  return type(value)(value)\n return value\n \n \n_allowed_names = set(\n[\n'return_value', '_mock_return_value', 'side_effect',\n'_mock_side_effect', '_mock_parent', '_mock_new_parent',\n'_mock_name', '_mock_new_name'\n]\n)\n\n\ndef _delegating_property(name):\n _allowed_names.add(name)\n _the_name = '_mock_' + name\n def _get(self, name=name, _the_name=_the_name):\n  sig = self._mock_delegate\n  if sig is None:\n   return getattr(self, _the_name)\n  return getattr(sig, name)\n def _set(self, value, name=name, _the_name=_the_name):\n  sig = self._mock_delegate\n  if sig is None:\n   self.__dict__[_the_name] = value\n  else:\n   setattr(sig, name, value)\n   \n return property(_get, _set)\n \n \n \nclass _CallList(list):\n\n def __contains__(self, value):\n  if not isinstance(value, list):\n   return list.__contains__(self, value)\n  len_value = len(value)\n  len_self = len(self)\n  if len_value > len_self:\n   return False\n   \n  for i in range(0, len_self - len_value + 1):\n   sub_list = self[i:i+len_value]\n   if sub_list == value:\n    return True\n  return False\n  \n def __repr__(self):\n  return pprint.pformat(list(self))\n  \n  \ndef _check_and_set_parent(parent, value, name, new_name):\n if not _is_instance_mock(value):\n  return False\n if ((value._mock_name or value._mock_new_name) or\n (value._mock_parent is not None) or\n (value._mock_new_parent is not None)):\n  return False\n  \n _parent = parent\n while _parent is not None:\n \n \n  if _parent is value:\n   return False\n  _parent = _parent._mock_new_parent\n  \n if new_name:\n  value._mock_new_parent = parent\n  value._mock_new_name = new_name\n if name:\n  value._mock_parent = parent\n  value._mock_name = name\n return True\n \n \n \nclass Base(object):\n _mock_return_value = DEFAULT\n _mock_side_effect = None\n def __init__(self, *args, **kwargs):\n  pass\n  \n  \n  \nclass NonCallableMock(Base):\n \"\"\n \n def __new__(cls, *args, **kw):\n \n \n \n  new = type(cls.__name__, (cls,), {'__doc__': cls.__doc__})\n  instance = object.__new__(new)\n  return instance\n  \n  \n def __init__(\n self, spec=None, wraps=None, name=None, spec_set=None,\n parent=None, _spec_state=None, _new_name='', _new_parent=None,\n **kwargs\n ):\n  if _new_parent is None:\n   _new_parent = parent\n   \n  __dict__ = self.__dict__\n  __dict__['_mock_parent'] = parent\n  __dict__['_mock_name'] = name\n  __dict__['_mock_new_name'] = _new_name\n  __dict__['_mock_new_parent'] = _new_parent\n  \n  if spec_set is not None:\n   spec = spec_set\n   spec_set = True\n   \n  self._mock_add_spec(spec, spec_set)\n  \n  __dict__['_mock_children'] = {}\n  __dict__['_mock_wraps'] = wraps\n  __dict__['_mock_delegate'] = None\n  \n  __dict__['_mock_called'] = False\n  __dict__['_mock_call_args'] = None\n  __dict__['_mock_call_count'] = 0\n  __dict__['_mock_call_args_list'] = _CallList()\n  __dict__['_mock_mock_calls'] = _CallList()\n  \n  __dict__['method_calls'] = _CallList()\n  \n  if kwargs:\n   self.configure_mock(**kwargs)\n   \n  _safe_super(NonCallableMock, self).__init__(\n  spec, wraps, name, spec_set, parent,\n  _spec_state\n  )\n  \n  \n def attach_mock(self, mock, attribute):\n  \"\"\n  mock._mock_parent = None\n  mock._mock_new_parent = None\n  mock._mock_name = ''\n  mock._mock_new_name = None\n  \n  setattr(self, attribute, mock)\n  \n  \n def mock_add_spec(self, spec, spec_set=False):\n  \"\"\n  self._mock_add_spec(spec, spec_set)\n  \n  \n def _mock_add_spec(self, spec, spec_set):\n  _spec_class = None\n  \n  if spec is not None and not _is_list(spec):\n   if isinstance(spec, type):\n    _spec_class = spec\n   else:\n    _spec_class = _get_class(spec)\n    \n   spec = dir(spec)\n   \n  __dict__ = self.__dict__\n  __dict__['_spec_class'] = _spec_class\n  __dict__['_spec_set'] = spec_set\n  __dict__['_mock_methods'] = spec\n  \n  \n def __get_return_value(self):\n  ret = self._mock_return_value\n  if self._mock_delegate is not None:\n   ret = self._mock_delegate.return_value\n   \n  if ret is DEFAULT:\n   ret = self._get_child_mock(\n   _new_parent=self, _new_name='()'\n   )\n   self.return_value = ret\n  return ret\n  \n  \n def __set_return_value(self, value):\n  if self._mock_delegate is not None:\n   self._mock_delegate.return_value = value\n  else:\n   self._mock_return_value = value\n   _check_and_set_parent(self, value, None, '()')\n   \n __return_value_doc = \"The value to be returned when the mock is called.\"\n return_value = property(__get_return_value, __set_return_value,\n __return_value_doc)\n \n \n @property\n def __class__(self):\n  if self._spec_class is None:\n   return type(self)\n  return self._spec_class\n  \n called = _delegating_property('called')\n call_count = _delegating_property('call_count')\n call_args = _delegating_property('call_args')\n call_args_list = _delegating_property('call_args_list')\n mock_calls = _delegating_property('mock_calls')\n \n \n def __get_side_effect(self):\n  delegated = self._mock_delegate\n  if delegated is None:\n   return self._mock_side_effect\n  return delegated.side_effect\n  \n def __set_side_effect(self, value):\n  value = _try_iter(value)\n  delegated = self._mock_delegate\n  if delegated is None:\n   self._mock_side_effect = value\n  else:\n   delegated.side_effect = value\n   \n side_effect = property(__get_side_effect, __set_side_effect)\n \n \n def reset_mock(self):\n  \"\"\n  self.called = False\n  self.call_args = None\n  self.call_count = 0\n  self.mock_calls = _CallList()\n  self.call_args_list = _CallList()\n  self.method_calls = _CallList()\n  \n  for child in self._mock_children.values():\n   if isinstance(child, _SpecState):\n    continue\n   child.reset_mock()\n   \n  ret = self._mock_return_value\n  if _is_instance_mock(ret) and ret is not self:\n   ret.reset_mock()\n   \n   \n def configure_mock(self, **kwargs):\n  \"\"\n  for arg, val in sorted(kwargs.items(),\n  \n  \n  \n  key=lambda entry: entry[0].count('.')):\n   args = arg.split('.')\n   final = args.pop()\n   obj = self\n   for entry in args:\n    obj = getattr(obj, entry)\n   setattr(obj, final, val)\n   \n   \n def __getattr__(self, name):\n  if name == '_mock_methods':\n   raise AttributeError(name)\n  elif self._mock_methods is not None:\n   if name not in self._mock_methods or name in _all_magics:\n    raise AttributeError(\"Mock object has no attribute %r\" % name)\n  elif _is_magic(name):\n   raise AttributeError(name)\n   \n  result = self._mock_children.get(name)\n  if result is _deleted:\n   raise AttributeError(name)\n  elif result is None:\n   wraps = None\n   if self._mock_wraps is not None:\n   \n   \n    wraps = getattr(self._mock_wraps, name)\n    \n   result = self._get_child_mock(\n   parent=self, name=name, wraps=wraps, _new_name=name,\n   _new_parent=self\n   )\n   self._mock_children[name] = result\n   \n  elif isinstance(result, _SpecState):\n   result = create_autospec(\n   result.spec, result.spec_set, result.instance,\n   result.parent, result.name\n   )\n   self._mock_children[name] = result\n   \n  return result\n  \n  \n def __repr__(self):\n  _name_list = [self._mock_new_name]\n  _parent = self._mock_new_parent\n  last = self\n  \n  dot = '.'\n  if _name_list == ['()']:\n   dot = ''\n  seen = set()\n  while _parent is not None:\n   last = _parent\n   \n   _name_list.append(_parent._mock_new_name + dot)\n   dot = '.'\n   if _parent._mock_new_name == '()':\n    dot = ''\n    \n   _parent = _parent._mock_new_parent\n   \n   \n   if id(_parent) in seen:\n    break\n   seen.add(id(_parent))\n   \n  _name_list = list(reversed(_name_list))\n  _first = last._mock_name or 'mock'\n  if len(_name_list) > 1:\n   if _name_list[1] not in ('()', '().'):\n    _first += '.'\n  _name_list[0] = _first\n  name = ''.join(_name_list)\n  \n  name_string = ''\n  if name not in ('mock', 'mock.'):\n   name_string = ' name=%r' % name\n   \n  spec_string = ''\n  if self._spec_class is not None:\n   spec_string = ' spec=%r'\n   if self._spec_set:\n    spec_string = ' spec_set=%r'\n   spec_string = spec_string % self._spec_class.__name__\n  return \"<%s%s%s id='%s'>\" % (\n  type(self).__name__,\n  name_string,\n  spec_string,\n  id(self)\n  )\n  \n  \n def __dir__(self):\n  \"\"\n  if not FILTER_DIR:\n   return object.__dir__(self)\n   \n  extras = self._mock_methods or []\n  from_type = dir(type(self))\n  from_dict = list(self.__dict__)\n  \n  from_type = [e for e in from_type if not e.startswith('_')]\n  from_dict = [e for e in from_dict if not e.startswith('_') or\n  _is_magic(e)]\n  return sorted(set(extras + from_type + from_dict +\n  list(self._mock_children)))\n  \n  \n def __setattr__(self, name, value):\n  if name in _allowed_names:\n  \n   return object.__setattr__(self, name, value)\n  elif (self._spec_set and self._mock_methods is not None and\n  name not in self._mock_methods and\n  name not in self.__dict__):\n   raise AttributeError(\"Mock object has no attribute '%s'\" % name)\n  elif name in _unsupported_magics:\n   msg = 'Attempting to set unsupported magic method %r.' % name\n   raise AttributeError(msg)\n  elif name in _all_magics:\n   if self._mock_methods is not None and name not in self._mock_methods:\n    raise AttributeError(\"Mock object has no attribute '%s'\" % name)\n    \n   if not _is_instance_mock(value):\n    setattr(type(self), name, _get_method(name, value))\n    original = value\n    value = lambda *args, **kw: original(self, *args, **kw)\n   else:\n   \n   \n    _check_and_set_parent(self, value, None, name)\n    setattr(type(self), name, value)\n    self._mock_children[name] = value\n  elif name == '__class__':\n   self._spec_class = value\n   return\n  else:\n   if _check_and_set_parent(self, value, name, name):\n    self._mock_children[name] = value\n  return object.__setattr__(self, name, value)\n  \n  \n def __delattr__(self, name):\n  if name in _all_magics and name in type(self).__dict__:\n   delattr(type(self), name)\n   if name not in self.__dict__:\n   \n   \n    return\n    \n  if name in self.__dict__:\n   object.__delattr__(self, name)\n   \n  obj = self._mock_children.get(name, _missing)\n  if obj is _deleted:\n   raise AttributeError(name)\n  if obj is not _missing:\n   del self._mock_children[name]\n  self._mock_children[name] = _deleted\n  \n  \n  \n def _format_mock_call_signature(self, args, kwargs):\n  name = self._mock_name or 'mock'\n  return _format_call_signature(name, args, kwargs)\n  \n  \n def _format_mock_failure_message(self, args, kwargs):\n  message = 'Expected call: %s\\nActual call: %s'\n  expected_string = self._format_mock_call_signature(args, kwargs)\n  call_args = self.call_args\n  if len(call_args) == 3:\n   call_args = call_args[1:]\n  actual_string = self._format_mock_call_signature(*call_args)\n  return message % (expected_string, actual_string)\n  \n  \n def assert_called_with(_mock_self, *args, **kwargs):\n  \"\"\n  self = _mock_self\n  if self.call_args is None:\n   expected = self._format_mock_call_signature(args, kwargs)\n   raise AssertionError('Expected call: %s\\nNot called' % (expected,))\n   \n  if self.call_args != (args, kwargs):\n   msg = self._format_mock_failure_message(args, kwargs)\n   raise AssertionError(msg)\n   \n   \n def assert_called_once_with(_mock_self, *args, **kwargs):\n  \"\"\n  self = _mock_self\n  if not self.call_count == 1:\n   msg = (\"Expected '%s' to be called once. Called %s times.\" %\n   (self._mock_name or 'mock', self.call_count))\n   raise AssertionError(msg)\n  return self.assert_called_with(*args, **kwargs)\n  \n  \n def assert_has_calls(self, calls, any_order=False):\n  \"\"\n  if not any_order:\n   if calls not in self.mock_calls:\n    raise AssertionError(\n    'Calls not found.\\nExpected: %r\\n'\n    'Actual: %r' % (calls, self.mock_calls)\n    )\n   return\n   \n  all_calls = list(self.mock_calls)\n  \n  not_found = []\n  for kall in calls:\n   try:\n    all_calls.remove(kall)\n   except ValueError:\n    not_found.append(kall)\n  if not_found:\n   raise AssertionError(\n   '%r not all found in call list' % (tuple(not_found),)\n   )\n   \n   \n def assert_any_call(self, *args, **kwargs):\n  \"\"\n  kall = call(*args, **kwargs)\n  if kall not in self.call_args_list:\n   expected_string = self._format_mock_call_signature(args, kwargs)\n   raise AssertionError(\n   '%s call not found' % expected_string\n   )\n   \n   \n def _get_child_mock(self, **kw):\n  \"\"\n  _type = type(self)\n  if not issubclass(_type, CallableMixin):\n   if issubclass(_type, NonCallableMagicMock):\n    klass = MagicMock\n   elif issubclass(_type, NonCallableMock) :\n    klass = Mock\n  else:\n   klass = _type.__mro__[1]\n  return klass(**kw)\n  \n  \n  \ndef _try_iter(obj):\n if obj is None:\n  return obj\n if _is_exception(obj):\n  return obj\n if _callable(obj):\n  return obj\n try:\n  return iter(obj)\n except TypeError:\n \n \n  return obj\n  \n  \n  \nclass CallableMixin(Base):\n\n def __init__(self, spec=None, side_effect=None, return_value=DEFAULT,\n wraps=None, name=None, spec_set=None, parent=None,\n _spec_state=None, _new_name='', _new_parent=None, **kwargs):\n  self.__dict__['_mock_return_value'] = return_value\n  \n  _safe_super(CallableMixin, self).__init__(\n  spec, wraps, name, spec_set, parent,\n  _spec_state, _new_name, _new_parent, **kwargs\n  )\n  \n  self.side_effect = side_effect\n  \n  \n def _mock_check_sig(self, *args, **kwargs):\n \n  pass\n  \n  \n def __call__(_mock_self, *args, **kwargs):\n \n \n  _mock_self._mock_check_sig(*args, **kwargs)\n  return _mock_self._mock_call(*args, **kwargs)\n  \n  \n def _mock_call(_mock_self, *args, **kwargs):\n  self = _mock_self\n  self.called = True\n  self.call_count += 1\n  self.call_args = _Call((args, kwargs), two=True)\n  self.call_args_list.append(_Call((args, kwargs), two=True))\n  \n  _new_name = self._mock_new_name\n  _new_parent = self._mock_new_parent\n  self.mock_calls.append(_Call(('', args, kwargs)))\n  \n  seen = set()\n  skip_next_dot = _new_name == '()'\n  do_method_calls = self._mock_parent is not None\n  name = self._mock_name\n  while _new_parent is not None:\n   this_mock_call = _Call((_new_name, args, kwargs))\n   if _new_parent._mock_new_name:\n    dot = '.'\n    if skip_next_dot:\n     dot = ''\n     \n    skip_next_dot = False\n    if _new_parent._mock_new_name == '()':\n     skip_next_dot = True\n     \n    _new_name = _new_parent._mock_new_name + dot + _new_name\n    \n   if do_method_calls:\n    if _new_name == name:\n     this_method_call = this_mock_call\n    else:\n     this_method_call = _Call((name, args, kwargs))\n    _new_parent.method_calls.append(this_method_call)\n    \n    do_method_calls = _new_parent._mock_parent is not None\n    if do_method_calls:\n     name = _new_parent._mock_name + '.' + name\n     \n   _new_parent.mock_calls.append(this_mock_call)\n   _new_parent = _new_parent._mock_new_parent\n   \n   \n   _new_parent_id = id(_new_parent)\n   if _new_parent_id in seen:\n    break\n   seen.add(_new_parent_id)\n   \n  ret_val = DEFAULT\n  effect = self.side_effect\n  if effect is not None:\n   if _is_exception(effect):\n    raise effect\n    \n   if not _callable(effect):\n    result = next(effect)\n    if _is_exception(result):\n     raise result\n    if result is DEFAULT:\n     result = self.return_value\n    return result\n    \n   ret_val = effect(*args, **kwargs)\n   if ret_val is DEFAULT:\n    ret_val = self.return_value\n    \n  if (self._mock_wraps is not None and\n  self._mock_return_value is DEFAULT):\n   return self._mock_wraps(*args, **kwargs)\n  if ret_val is DEFAULT:\n   ret_val = self.return_value\n  return ret_val\n  \n  \n  \nclass Mock(CallableMixin, NonCallableMock):\n \"\"\n \n \n \ndef _dot_lookup(thing, comp, import_path):\n try:\n  return getattr(thing, comp)\n except AttributeError:\n  __import__(import_path)\n  return getattr(thing, comp)\n  \n  \ndef _importer(target):\n components = target.split('.')\n import_path = components.pop(0)\n thing = __import__(import_path)\n \n for comp in components:\n  import_path += \".%s\" % comp\n  thing = _dot_lookup(thing, comp, import_path)\n return thing\n \n \ndef _is_started(patcher):\n\n return hasattr(patcher, 'is_local')\n \n \nclass _patch(object):\n\n attribute_name = None\n _active_patches = set()\n \n def __init__(\n self, getter, attribute, new, spec, create,\n spec_set, autospec, new_callable, kwargs\n ):\n  if new_callable is not None:\n   if new is not DEFAULT:\n    raise ValueError(\n    \"Cannot use 'new' and 'new_callable' together\"\n    )\n   if autospec is not None:\n    raise ValueError(\n    \"Cannot use 'autospec' and 'new_callable' together\"\n    )\n    \n  self.getter = getter\n  self.attribute = attribute\n  self.new = new\n  self.new_callable = new_callable\n  self.spec = spec\n  self.create = create\n  self.has_local = False\n  self.spec_set = spec_set\n  self.autospec = autospec\n  self.kwargs = kwargs\n  self.additional_patchers = []\n  \n  \n def copy(self):\n  patcher = _patch(\n  self.getter, self.attribute, self.new, self.spec,\n  self.create, self.spec_set,\n  self.autospec, self.new_callable, self.kwargs\n  )\n  patcher.attribute_name = self.attribute_name\n  patcher.additional_patchers = [\n  p.copy() for p in self.additional_patchers\n  ]\n  return patcher\n  \n  \n def __call__(self, func):\n  if isinstance(func, type):\n   return self.decorate_class(func)\n  return self.decorate_callable(func)\n  \n  \n def decorate_class(self, klass):\n  for attr in dir(klass):\n   if not attr.startswith(patch.TEST_PREFIX):\n    continue\n    \n   attr_value = getattr(klass, attr)\n   if not hasattr(attr_value, \"__call__\"):\n    continue\n    \n   patcher = self.copy()\n   setattr(klass, attr, patcher(attr_value))\n  return klass\n  \n  \n def decorate_callable(self, func):\n  if hasattr(func, 'patchings'):\n   func.patchings.append(self)\n   return func\n   \n  @wraps(func)\n  def patched(*args, **keywargs):\n   extra_args = []\n   entered_patchers = []\n   \n   exc_info = tuple()\n   try:\n    for patching in patched.patchings:\n     arg = patching.__enter__()\n     entered_patchers.append(patching)\n     if patching.attribute_name is not None:\n      keywargs.update(arg)\n     elif patching.new is DEFAULT:\n      extra_args.append(arg)\n      \n    args += tuple(extra_args)\n    return func(*args, **keywargs)\n   except:\n    if (patching not in entered_patchers and\n    _is_started(patching)):\n    \n    \n     entered_patchers.append(patching)\n     \n    exc_info = sys.exc_info()\n    \n    raise\n   finally:\n    for patching in reversed(entered_patchers):\n     patching.__exit__(*exc_info)\n     \n  patched.patchings = [self]\n  return patched\n  \n  \n def get_original(self):\n  target = self.getter()\n  name = self.attribute\n  \n  original = DEFAULT\n  local = False\n  \n  try:\n   original = target.__dict__[name]\n  except (AttributeError, KeyError):\n   original = getattr(target, name, DEFAULT)\n  else:\n   local = True\n   \n  if not self.create and original is DEFAULT:\n   raise AttributeError(\n   \"%s does not have the attribute %r\" % (target, name)\n   )\n  return original, local\n  \n  \n def __enter__(self):\n  \"\"\n  new, spec, spec_set = self.new, self.spec, self.spec_set\n  autospec, kwargs = self.autospec, self.kwargs\n  new_callable = self.new_callable\n  self.target = self.getter()\n  \n  \n  if spec is False:\n   spec = None\n  if spec_set is False:\n   spec_set = None\n  if autospec is False:\n   autospec = None\n   \n  if spec is not None and autospec is not None:\n   raise TypeError(\"Can't specify spec and autospec\")\n  if ((spec is not None or autospec is not None) and\n  spec_set not in (True, None)):\n   raise TypeError(\"Can't provide explicit spec_set *and* spec or autospec\")\n   \n  original, local = self.get_original()\n  \n  if new is DEFAULT and autospec is None:\n   inherit = False\n   if spec is True:\n   \n    spec = original\n    if spec_set is True:\n     spec_set = original\n     spec = None\n   elif spec is not None:\n    if spec_set is True:\n     spec_set = spec\n     spec = None\n   elif spec_set is True:\n    spec_set = original\n    \n   if spec is not None or spec_set is not None:\n    if original is DEFAULT:\n     raise TypeError(\"Can't use 'spec' with create=True\")\n    if isinstance(original, type):\n    \n     inherit = True\n     \n   Klass = MagicMock\n   _kwargs = {}\n   if new_callable is not None:\n    Klass = new_callable\n   elif spec is not None or spec_set is not None:\n    this_spec = spec\n    if spec_set is not None:\n     this_spec = spec_set\n    if _is_list(this_spec):\n     not_callable = '__call__' not in this_spec\n    else:\n     not_callable = not callable(this_spec)\n    if not_callable:\n     Klass = NonCallableMagicMock\n     \n   if spec is not None:\n    _kwargs['spec'] = spec\n   if spec_set is not None:\n    _kwargs['spec_set'] = spec_set\n    \n    \n   if (isinstance(Klass, type) and\n   issubclass(Klass, NonCallableMock) and self.attribute):\n    _kwargs['name'] = self.attribute\n    \n   _kwargs.update(kwargs)\n   new = Klass(**_kwargs)\n   \n   if inherit and _is_instance_mock(new):\n   \n   \n    this_spec = spec\n    if spec_set is not None:\n     this_spec = spec_set\n    if (not _is_list(this_spec) and not\n    _instance_callable(this_spec)):\n     Klass = NonCallableMagicMock\n     \n    _kwargs.pop('name')\n    new.return_value = Klass(_new_parent=new, _new_name='()',\n    **_kwargs)\n  elif autospec is not None:\n  \n  \n  \n   if new is not DEFAULT:\n    raise TypeError(\n    \"autospec creates the mock for you. Can't specify \"\n    \"autospec and new.\"\n    )\n   if original is DEFAULT:\n    raise TypeError(\"Can't use 'autospec' with create=True\")\n   spec_set = bool(spec_set)\n   if autospec is True:\n    autospec = original\n    \n   new = create_autospec(autospec, spec_set=spec_set,\n   _name=self.attribute, **kwargs)\n  elif kwargs:\n  \n  \n   raise TypeError(\"Can't pass kwargs to a mock we aren't creating\")\n   \n  new_attr = new\n  \n  self.temp_original = original\n  self.is_local = local\n  setattr(self.target, self.attribute, new_attr)\n  if self.attribute_name is not None:\n   extra_args = {}\n   if self.new is DEFAULT:\n    extra_args[self.attribute_name] = new\n   for patching in self.additional_patchers:\n    arg = patching.__enter__()\n    if patching.new is DEFAULT:\n     extra_args.update(arg)\n   return extra_args\n   \n  return new\n  \n  \n def __exit__(self, *exc_info):\n  \"\"\n  if not _is_started(self):\n   raise RuntimeError('stop called on unstarted patcher')\n   \n  if self.is_local and self.temp_original is not DEFAULT:\n   setattr(self.target, self.attribute, self.temp_original)\n  else:\n   delattr(self.target, self.attribute)\n   if not self.create and not hasattr(self.target, self.attribute):\n   \n    setattr(self.target, self.attribute, self.temp_original)\n    \n  del self.temp_original\n  del self.is_local\n  del self.target\n  for patcher in reversed(self.additional_patchers):\n   if _is_started(patcher):\n    patcher.__exit__(*exc_info)\n    \n    \n def start(self):\n  \"\"\n  result = self.__enter__()\n  self._active_patches.add(self)\n  return result\n  \n  \n def stop(self):\n  \"\"\n  self._active_patches.discard(self)\n  return self.__exit__()\n  \n  \n  \ndef _get_target(target):\n try:\n  target, attribute = target.rsplit('.', 1)\n except (TypeError, ValueError):\n  raise TypeError(\"Need a valid target to patch. You supplied: %r\" %\n  (target,))\n getter = lambda: _importer(target)\n return getter, attribute\n \n \ndef _patch_object(\ntarget, attribute, new=DEFAULT, spec=None,\ncreate=False, spec_set=None, autospec=None,\nnew_callable=None, **kwargs\n):\n \"\"\n getter = lambda: target\n return _patch(\n getter, attribute, new, spec, create,\n spec_set, autospec, new_callable, kwargs\n )\n \n \ndef _patch_multiple(target, spec=None, create=False, spec_set=None,\nautospec=None, new_callable=None, **kwargs):\n \"\"\n if type(target) is str:\n  getter = lambda: _importer(target)\n else:\n  getter = lambda: target\n  \n if not kwargs:\n  raise ValueError(\n  'Must supply at least one keyword argument with patch.multiple'\n  )\n  \n items = list(kwargs.items())\n attribute, new = items[0]\n patcher = _patch(\n getter, attribute, new, spec, create, spec_set,\n autospec, new_callable, {}\n )\n patcher.attribute_name = attribute\n for attribute, new in items[1:]:\n  this_patcher = _patch(\n  getter, attribute, new, spec, create, spec_set,\n  autospec, new_callable, {}\n  )\n  this_patcher.attribute_name = attribute\n  patcher.additional_patchers.append(this_patcher)\n return patcher\n \n \ndef patch(\ntarget, new=DEFAULT, spec=None, create=False,\nspec_set=None, autospec=None, new_callable=None, **kwargs\n):\n \"\"\n getter, attribute = _get_target(target)\n return _patch(\n getter, attribute, new, spec, create,\n spec_set, autospec, new_callable, kwargs\n )\n \n \nclass _patch_dict(object):\n \"\"\n \n def __init__(self, in_dict, values=(), clear=False, **kwargs):\n  if isinstance(in_dict, str):\n   in_dict = _importer(in_dict)\n  self.in_dict = in_dict\n  \n  self.values = dict(values)\n  self.values.update(kwargs)\n  self.clear = clear\n  self._original = None\n  \n  \n def __call__(self, f):\n  if isinstance(f, type):\n   return self.decorate_class(f)\n  @wraps(f)\n  def _inner(*args, **kw):\n   self._patch_dict()\n   try:\n    return f(*args, **kw)\n   finally:\n    self._unpatch_dict()\n    \n  return _inner\n  \n  \n def decorate_class(self, klass):\n  for attr in dir(klass):\n   attr_value = getattr(klass, attr)\n   if (attr.startswith(patch.TEST_PREFIX) and\n   hasattr(attr_value, \"__call__\")):\n    decorator = _patch_dict(self.in_dict, self.values, self.clear)\n    decorated = decorator(attr_value)\n    setattr(klass, attr, decorated)\n  return klass\n  \n  \n def __enter__(self):\n  \"\"\n  self._patch_dict()\n  \n  \n def _patch_dict(self):\n  values = self.values\n  in_dict = self.in_dict\n  clear = self.clear\n  \n  try:\n   original = in_dict.copy()\n  except AttributeError:\n  \n  \n   original = {}\n   for key in in_dict:\n    original[key] = in_dict[key]\n  self._original = original\n  \n  if clear:\n   _clear_dict(in_dict)\n   \n  try:\n   in_dict.update(values)\n  except AttributeError:\n  \n   for key in values:\n    in_dict[key] = values[key]\n    \n    \n def _unpatch_dict(self):\n  in_dict = self.in_dict\n  original = self._original\n  \n  _clear_dict(in_dict)\n  \n  try:\n   in_dict.update(original)\n  except AttributeError:\n   for key in original:\n    in_dict[key] = original[key]\n    \n    \n def __exit__(self, *args):\n  \"\"\n  self._unpatch_dict()\n  return False\n  \n start = __enter__\n stop = __exit__\n \n \ndef _clear_dict(in_dict):\n try:\n  in_dict.clear()\n except AttributeError:\n  keys = list(in_dict)\n  for key in keys:\n   del in_dict[key]\n   \n   \ndef _patch_stopall():\n \"\"\n for patch in list(_patch._active_patches):\n  patch.stop()\n  \n  \npatch.object = _patch_object\npatch.dict = _patch_dict\npatch.multiple = _patch_multiple\npatch.stopall = _patch_stopall\npatch.TEST_PREFIX = 'test'\n\nmagic_methods = (\n\"lt le gt ge eq ne \"\n\"getitem setitem delitem \"\n\"len contains iter \"\n\"hash str sizeof \"\n\"enter exit \"\n\"divmod neg pos abs invert \"\n\"complex int float index \"\n\"trunc floor ceil \"\n\"bool next \"\n)\n\nnumerics = \"add sub mul div floordiv mod lshift rshift and xor or pow \"\ninplace = ' '.join('i%s' % n for n in numerics.split())\nright = ' '.join('r%s' % n for n in numerics.split())\n\n\n\n\n\n_non_defaults = set('__%s__' % method for method in [\n'get', 'set', 'delete', 'reversed', 'missing', 'reduce', 'reduce_ex',\n'getinitargs', 'getnewargs', 'getstate', 'setstate', 'getformat',\n'setformat', 'repr', 'dir', 'subclasses', 'format',\n])\n\n\ndef _get_method(name, func):\n \"\"\n def method(self, *args, **kw):\n  return func(self, *args, **kw)\n method.__name__ = name\n return method\n \n \n_magics = set(\n'__%s__' % method for method in\n' '.join([magic_methods, numerics, inplace, right]).split()\n)\n\n_all_magics = _magics | _non_defaults\n\n_unsupported_magics = set([\n'__getattr__', '__setattr__',\n'__init__', '__new__', '__prepare__'\n'__instancecheck__', '__subclasscheck__',\n'__del__'\n])\n\n_calculate_return_value = {\n'__hash__': lambda self: object.__hash__(self),\n'__str__': lambda self: object.__str__(self),\n'__sizeof__': lambda self: object.__sizeof__(self),\n}\n\n_return_values = {\n'__lt__': NotImplemented,\n'__gt__': NotImplemented,\n'__le__': NotImplemented,\n'__ge__': NotImplemented,\n'__int__': 1,\n'__contains__': False,\n'__len__': 0,\n'__exit__': False,\n'__complex__': 1j,\n'__float__': 1.0,\n'__bool__': True,\n'__index__': 1,\n}\n\n\ndef _get_eq(self):\n def __eq__(other):\n  ret_val = self.__eq__._mock_return_value\n  if ret_val is not DEFAULT:\n   return ret_val\n  return self is other\n return __eq__\n \ndef _get_ne(self):\n def __ne__(other):\n  if self.__ne__._mock_return_value is not DEFAULT:\n   return DEFAULT\n  return self is not other\n return __ne__\n \ndef _get_iter(self):\n def __iter__():\n  ret_val = self.__iter__._mock_return_value\n  if ret_val is DEFAULT:\n   return iter([])\n   \n   \n  return iter(ret_val)\n return __iter__\n \n_side_effect_methods = {\n'__eq__': _get_eq,\n'__ne__': _get_ne,\n'__iter__': _get_iter,\n}\n\n\n\ndef _set_return_value(mock, method, name):\n fixed = _return_values.get(name, DEFAULT)\n if fixed is not DEFAULT:\n  method.return_value = fixed\n  return\n  \n return_calulator = _calculate_return_value.get(name)\n if return_calulator is not None:\n  try:\n   return_value = return_calulator(mock)\n  except AttributeError:\n  \n  \n   return_value = AttributeError(name)\n  method.return_value = return_value\n  return\n  \n side_effector = _side_effect_methods.get(name)\n if side_effector is not None:\n  method.side_effect = side_effector(mock)\n  \n  \n  \nclass MagicMixin(object):\n def __init__(self, *args, **kw):\n  _safe_super(MagicMixin, self).__init__(*args, **kw)\n  self._mock_set_magics()\n  \n  \n def _mock_set_magics(self):\n  these_magics = _magics\n  \n  if self._mock_methods is not None:\n   these_magics = _magics.intersection(self._mock_methods)\n   \n   remove_magics = set()\n   remove_magics = _magics - these_magics\n   \n   for entry in remove_magics:\n    if entry in type(self).__dict__:\n    \n     delattr(self, entry)\n     \n     \n  these_magics = these_magics - set(type(self).__dict__)\n  \n  _type = type(self)\n  for entry in these_magics:\n   setattr(_type, entry, MagicProxy(entry, self))\n   \n   \n   \nclass NonCallableMagicMock(MagicMixin, NonCallableMock):\n \"\"\n def mock_add_spec(self, spec, spec_set=False):\n  \"\"\n  self._mock_add_spec(spec, spec_set)\n  self._mock_set_magics()\n  \n  \n  \nclass MagicMock(MagicMixin, Mock):\n \"\"\n def mock_add_spec(self, spec, spec_set=False):\n  \"\"\n  self._mock_add_spec(spec, spec_set)\n  self._mock_set_magics()\n  \n  \n  \nclass MagicProxy(object):\n def __init__(self, name, parent):\n  self.name = name\n  self.parent = parent\n  \n def __call__(self, *args, **kwargs):\n  m = self.create_mock()\n  return m(*args, **kwargs)\n  \n def create_mock(self):\n  entry = self.name\n  parent = self.parent\n  m = parent._get_child_mock(name=entry, _new_name=entry,\n  _new_parent=parent)\n  setattr(parent, entry, m)\n  _set_return_value(parent, m, entry)\n  return m\n  \n def __get__(self, obj, _type=None):\n  return self.create_mock()\n  \n  \n  \nclass _ANY(object):\n \"\"\n \n def __eq__(self, other):\n  return True\n  \n def __ne__(self, other):\n  return False\n  \n def __repr__(self):\n  return '<ANY>'\n  \nANY = _ANY()\n\n\n\ndef _format_call_signature(name, args, kwargs):\n message = '%s(%%s)' % name\n formatted_args = ''\n args_string = ', '.join([repr(arg) for arg in args])\n kwargs_string = ', '.join([\n '%s=%r' % (key, value) for key, value in kwargs.items()\n ])\n if args_string:\n  formatted_args = args_string\n if kwargs_string:\n  if formatted_args:\n   formatted_args += ', '\n  formatted_args += kwargs_string\n  \n return message % formatted_args\n \n \n \nclass _Call(tuple):\n \"\"\n def __new__(cls, value=(), name=None, parent=None, two=False,\n from_kall=True):\n  name = ''\n  args = ()\n  kwargs = {}\n  _len = len(value)\n  if _len == 3:\n   name, args, kwargs = value\n  elif _len == 2:\n   first, second = value\n   if isinstance(first, str):\n    name = first\n    if isinstance(second, tuple):\n     args = second\n    else:\n     kwargs = second\n   else:\n    args, kwargs = first, second\n  elif _len == 1:\n   value, = value\n   if isinstance(value, str):\n    name = value\n   elif isinstance(value, tuple):\n    args = value\n   else:\n    kwargs = value\n    \n  if two:\n   return tuple.__new__(cls, (args, kwargs))\n   \n  return tuple.__new__(cls, (name, args, kwargs))\n  \n  \n def __init__(self, value=(), name=None, parent=None, two=False,\n from_kall=True):\n  self.name = name\n  self.parent = parent\n  self.from_kall = from_kall\n  \n  \n def __eq__(self, other):\n  if other is ANY:\n   return True\n  try:\n   len_other = len(other)\n  except TypeError:\n   return False\n   \n  self_name = ''\n  if len(self) == 2:\n   self_args, self_kwargs = self\n  else:\n   self_name, self_args, self_kwargs = self\n   \n  other_name = ''\n  if len_other == 0:\n   other_args, other_kwargs = (), {}\n  elif len_other == 3:\n   other_name, other_args, other_kwargs = other\n  elif len_other == 1:\n   value, = other\n   if isinstance(value, tuple):\n    other_args = value\n    other_kwargs = {}\n   elif isinstance(value, str):\n    other_name = value\n    other_args, other_kwargs = (), {}\n   else:\n    other_args = ()\n    other_kwargs = value\n  else:\n  \n  \n   first, second = other\n   if isinstance(first, str):\n    other_name = first\n    if isinstance(second, tuple):\n     other_args, other_kwargs = second, {}\n    else:\n     other_args, other_kwargs = (), second\n   else:\n    other_args, other_kwargs = first, second\n    \n  if self_name and other_name != self_name:\n   return False\n   \n   \n  return (other_args, other_kwargs) == (self_args, self_kwargs)\n  \n  \n def __ne__(self, other):\n  return not self.__eq__(other)\n  \n  \n def __call__(self, *args, **kwargs):\n  if self.name is None:\n   return _Call(('', args, kwargs), name='()')\n   \n  name = self.name + '()'\n  return _Call((self.name, args, kwargs), name=name, parent=self)\n  \n  \n def __getattr__(self, attr):\n  if self.name is None:\n   return _Call(name=attr, from_kall=False)\n  name = '%s.%s' % (self.name, attr)\n  return _Call(name=name, parent=self, from_kall=False)\n  \n  \n def __repr__(self):\n  if not self.from_kall:\n   name = self.name or 'call'\n   if name.startswith('()'):\n    name = 'call%s' % name\n   return name\n   \n  if len(self) == 2:\n   name = 'call'\n   args, kwargs = self\n  else:\n   name, args, kwargs = self\n   if not name:\n    name = 'call'\n   elif not name.startswith('()'):\n    name = 'call.%s' % name\n   else:\n    name = 'call%s' % name\n  return _format_call_signature(name, args, kwargs)\n  \n  \n def call_list(self):\n  \"\"\n  vals = []\n  thing = self\n  while thing is not None:\n   if thing.from_kall:\n    vals.append(thing)\n   thing = thing.parent\n  return _CallList(reversed(vals))\n  \n  \ncall = _Call(from_kall=False)\n\n\n\ndef create_autospec(spec, spec_set=False, instance=False, _parent=None,\n_name=None, **kwargs):\n \"\"\n if _is_list(spec):\n \n \n  spec = type(spec)\n  \n is_type = isinstance(spec, type)\n \n _kwargs = {'spec': spec}\n if spec_set:\n  _kwargs = {'spec_set': spec}\n elif spec is None:\n \n  _kwargs = {}\n  \n _kwargs.update(kwargs)\n \n Klass = MagicMock\n if type(spec) in DescriptorTypes:\n \n \n  _kwargs = {}\n elif not _callable(spec):\n  Klass = NonCallableMagicMock\n elif is_type and instance and not _instance_callable(spec):\n  Klass = NonCallableMagicMock\n  \n _new_name = _name\n if _parent is None:\n \n  _new_name = ''\n  \n mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,\n name=_name, **_kwargs)\n \n if isinstance(spec, FunctionTypes):\n \n \n  mock = _set_signature(mock, spec)\n else:\n  _check_signature(spec, mock, is_type, instance)\n  \n if _parent is not None and not instance:\n  _parent._mock_children[_name] = mock\n  \n if is_type and not instance and 'return_value' not in kwargs:\n  mock.return_value = create_autospec(spec, spec_set, instance=True,\n  _name='()', _parent=mock)\n  \n for entry in dir(spec):\n  if _is_magic(entry):\n  \n   continue\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  try:\n   original = getattr(spec, entry)\n  except AttributeError:\n   continue\n   \n  kwargs = {'spec': original}\n  if spec_set:\n   kwargs = {'spec_set': original}\n   \n  if not isinstance(original, FunctionTypes):\n   new = _SpecState(original, spec_set, mock, entry, instance)\n   mock._mock_children[entry] = new\n  else:\n   parent = mock\n   if isinstance(spec, FunctionTypes):\n    parent = mock.mock\n    \n   new = MagicMock(parent=parent, name=entry, _new_name=entry,\n   _new_parent=parent, **kwargs)\n   mock._mock_children[entry] = new\n   skipfirst = _must_skip(spec, entry, is_type)\n   _check_signature(original, new, skipfirst=skipfirst)\n   \n   \n   \n   \n   \n  if isinstance(new, FunctionTypes):\n   setattr(mock, entry, new)\n   \n return mock\n \n \ndef _must_skip(spec, entry, is_type):\n if not isinstance(spec, type):\n  if entry in getattr(spec, '__dict__', {}):\n  \n   return False\n  spec = spec.__class__\n  \n for klass in spec.__mro__:\n  result = klass.__dict__.get(entry, DEFAULT)\n  if result is DEFAULT:\n   continue\n  if isinstance(result, (staticmethod, classmethod)):\n   return False\n  return is_type\n  \n  \n  \n return is_type\n \n \ndef _get_class(obj):\n try:\n  return obj.__class__\n except AttributeError:\n \n  return type(obj)\n  \n  \nclass _SpecState(object):\n\n def __init__(self, spec, spec_set=False, parent=None,\n name=None, ids=None, instance=False):\n  self.spec = spec\n  self.ids = ids\n  self.spec_set = spec_set\n  self.parent = parent\n  self.instance = instance\n  self.name = name\n  \n  \nFunctionTypes = (\n\ntype(create_autospec),\n\ntype(ANY.__eq__),\n)\n\n\nfile_spec = None\n\n\ndef mock_open(mock=None, read_data=''):\n \"\"\n global file_spec\n if file_spec is None:\n  import _io\n  file_spec = list(set(dir(_io.TextIOWrapper)).union(set(dir(_io.BytesIO))))\n  \n if mock is None:\n  mock = MagicMock(name='open', spec=open)\n  \n handle = MagicMock(spec=file_spec)\n handle.write.return_value = None\n handle.__enter__.return_value = handle\n handle.read.return_value = read_data\n \n mock.return_value = handle\n return mock\n \n \nclass PropertyMock(Mock):\n \"\"\n def _get_child_mock(self, **kwargs):\n  return MagicMock(**kwargs)\n  \n def __get__(self, obj, obj_type):\n  return self()\n def __set__(self, obj, val):\n  self(val)\n"], "test.test_int": ["import sys\n\nimport unittest\nfrom test.support import run_unittest\n\nL = [\n('0', 0),\n('1', 1),\n('9', 9),\n('10', 10),\n('99', 99),\n('100', 100),\n('314', 314),\n(' 314', 314),\n('314 ', 314),\n('  \\t\\t  314  \\t\\t  ', 314),\n(repr(sys.maxsize), sys.maxsize),\n('  1x', ValueError),\n('  1  ', 1),\n('  1\\02  ', ValueError),\n('', ValueError),\n(' ', ValueError),\n('  \\t\\t  ', ValueError),\n(\"\\u0200\", ValueError)\n]\n\nclass IntTestCases(unittest.TestCase):\n\n def test_basic(self):\n  self.assertEqual(int(314), 314)\n  self.assertEqual(int(3.14), 3)\n  \n  self.assertEqual(int(-3.14), -3)\n  self.assertEqual(int(3.9), 3)\n  self.assertEqual(int(-3.9), -3)\n  self.assertEqual(int(3.5), 3)\n  self.assertEqual(int(-3.5), -3)\n  self.assertEqual(int(\"-3\"), -3)\n  self.assertEqual(int(\" -3 \"), -3)\n  self.assertEqual(int(\"\\N{EM SPACE}-3\\N{EN SPACE}\"), -3)\n  \n  self.assertEqual(int(\"10\",16), 16)\n  \n  for s, v in L:\n   for sign in \"\", \"+\", \"-\":\n    for prefix in \"\", \" \", \"\\t\", \"  \\t\\t  \":\n     ss = prefix + sign + s\n     vv = v\n     if sign == \"-\" and v is not ValueError:\n      vv = -v\n     try:\n      self.assertEqual(int(ss), vv)\n     except ValueError:\n      pass\n      \n  s = repr(-1-sys.maxsize)\n  x = int(s)\n  self.assertEqual(x+1, -sys.maxsize)\n  self.assertIsInstance(x, int)\n  \n  self.assertEqual(int(s[1:]), sys.maxsize+1)\n  \n  \n  x = int(1e100)\n  self.assertIsInstance(x, int)\n  x = int(-1e100)\n  self.assertIsInstance(x, int)\n  \n  \n  \n  \n  \n  x = -1-sys.maxsize\n  self.assertEqual(x >> 1, x//2)\n  \n  self.assertRaises(ValueError, int, '123\\0')\n  self.assertRaises(ValueError, int, '53', 40)\n  \n  \n  \n  self.assertRaises(ValueError, int, '123\\0', 10)\n  self.assertRaises(ValueError, int, '123\\x00 245', 20)\n  \n  x = int('1' * 600)\n  self.assertIsInstance(x, int)\n  \n  \n  self.assertRaises(TypeError, int, 1, 12)\n  \n  self.assertEqual(int('0o123', 0), 83)\n  self.assertEqual(int('0x123', 16), 291)\n  \n  \n  self.assertRaises(ValueError, int, \"0x\", 16)\n  self.assertRaises(ValueError, int, \"0x\", 0)\n  \n  self.assertRaises(ValueError, int, \"0o\", 8)\n  self.assertRaises(ValueError, int, \"0o\", 0)\n  \n  self.assertRaises(ValueError, int, \"0b\", 2)\n  self.assertRaises(ValueError, int, \"0b\", 0)\n  \n  \n  self.assertTrue(int(\"10\") is 10)\n  self.assertTrue(int(\"-1\") is -1)\n  \n  \n  \n  \n  \n  self.assertEqual(int('100000000000000000000000000000000', 2), 4294967296)\n  self.assertEqual(int('102002022201221111211', 3), 4294967296)\n  self.assertEqual(int('10000000000000000', 4), 4294967296)\n  self.assertEqual(int('32244002423141', 5), 4294967296)\n  self.assertEqual(int('1550104015504', 6), 4294967296)\n  self.assertEqual(int('211301422354', 7), 4294967296)\n  self.assertEqual(int('40000000000', 8), 4294967296)\n  self.assertEqual(int('12068657454', 9), 4294967296)\n  self.assertEqual(int('4294967296', 10), 4294967296)\n  self.assertEqual(int('1904440554', 11), 4294967296)\n  self.assertEqual(int('9ba461594', 12), 4294967296)\n  self.assertEqual(int('535a79889', 13), 4294967296)\n  self.assertEqual(int('2ca5b7464', 14), 4294967296)\n  self.assertEqual(int('1a20dcd81', 15), 4294967296)\n  self.assertEqual(int('100000000', 16), 4294967296)\n  self.assertEqual(int('a7ffda91', 17), 4294967296)\n  self.assertEqual(int('704he7g4', 18), 4294967296)\n  self.assertEqual(int('4f5aff66', 19), 4294967296)\n  self.assertEqual(int('3723ai4g', 20), 4294967296)\n  self.assertEqual(int('281d55i4', 21), 4294967296)\n  self.assertEqual(int('1fj8b184', 22), 4294967296)\n  self.assertEqual(int('1606k7ic', 23), 4294967296)\n  self.assertEqual(int('mb994ag', 24), 4294967296)\n  self.assertEqual(int('hek2mgl', 25), 4294967296)\n  self.assertEqual(int('dnchbnm', 26), 4294967296)\n  self.assertEqual(int('b28jpdm', 27), 4294967296)\n  self.assertEqual(int('8pfgih4', 28), 4294967296)\n  self.assertEqual(int('76beigg', 29), 4294967296)\n  self.assertEqual(int('5qmcpqg', 30), 4294967296)\n  self.assertEqual(int('4q0jto4', 31), 4294967296)\n  self.assertEqual(int('4000000', 32), 4294967296)\n  self.assertEqual(int('3aokq94', 33), 4294967296)\n  self.assertEqual(int('2qhxjli', 34), 4294967296)\n  self.assertEqual(int('2br45qb', 35), 4294967296)\n  self.assertEqual(int('1z141z4', 36), 4294967296)\n  \n  \n  \n  self.assertEqual(int(' 0o123  ', 0), 83)\n  self.assertEqual(int(' 0o123  ', 0), 83)\n  self.assertEqual(int('000', 0), 0)\n  self.assertEqual(int('0o123', 0), 83)\n  self.assertEqual(int('0x123', 0), 291)\n  self.assertEqual(int('0b100', 0), 4)\n  self.assertEqual(int(' 0O123   ', 0), 83)\n  self.assertEqual(int(' 0X123  ', 0), 291)\n  self.assertEqual(int(' 0B100 ', 0), 4)\n  \n  \n  self.assertEqual(int('0123'), 123)\n  self.assertEqual(int('0123', 10), 123)\n  \n  \n  self.assertEqual(int('0x123', 16), 291)\n  self.assertEqual(int('0o123', 8), 83)\n  self.assertEqual(int('0b100', 2), 4)\n  self.assertEqual(int('0X123', 16), 291)\n  self.assertEqual(int('0O123', 8), 83)\n  self.assertEqual(int('0B100', 2), 4)\n  \n  \n  \n  self.assertRaises(ValueError, int, '0b2', 2)\n  self.assertRaises(ValueError, int, '0b02', 2)\n  self.assertRaises(ValueError, int, '0B2', 2)\n  self.assertRaises(ValueError, int, '0B02', 2)\n  self.assertRaises(ValueError, int, '0o8', 8)\n  self.assertRaises(ValueError, int, '0o08', 8)\n  self.assertRaises(ValueError, int, '0O8', 8)\n  self.assertRaises(ValueError, int, '0O08', 8)\n  self.assertRaises(ValueError, int, '0xg', 16)\n  self.assertRaises(ValueError, int, '0x0g', 16)\n  self.assertRaises(ValueError, int, '0Xg', 16)\n  self.assertRaises(ValueError, int, '0X0g', 16)\n  \n  \n  \n  self.assertEqual(int('100000000000000000000000000000001', 2), 4294967297)\n  self.assertEqual(int('102002022201221111212', 3), 4294967297)\n  self.assertEqual(int('10000000000000001', 4), 4294967297)\n  self.assertEqual(int('32244002423142', 5), 4294967297)\n  self.assertEqual(int('1550104015505', 6), 4294967297)\n  self.assertEqual(int('211301422355', 7), 4294967297)\n  self.assertEqual(int('40000000001', 8), 4294967297)\n  self.assertEqual(int('12068657455', 9), 4294967297)\n  self.assertEqual(int('4294967297', 10), 4294967297)\n  self.assertEqual(int('1904440555', 11), 4294967297)\n  self.assertEqual(int('9ba461595', 12), 4294967297)\n  self.assertEqual(int('535a7988a', 13), 4294967297)\n  self.assertEqual(int('2ca5b7465', 14), 4294967297)\n  self.assertEqual(int('1a20dcd82', 15), 4294967297)\n  self.assertEqual(int('100000001', 16), 4294967297)\n  self.assertEqual(int('a7ffda92', 17), 4294967297)\n  self.assertEqual(int('704he7g5', 18), 4294967297)\n  self.assertEqual(int('4f5aff67', 19), 4294967297)\n  self.assertEqual(int('3723ai4h', 20), 4294967297)\n  self.assertEqual(int('281d55i5', 21), 4294967297)\n  self.assertEqual(int('1fj8b185', 22), 4294967297)\n  self.assertEqual(int('1606k7id', 23), 4294967297)\n  self.assertEqual(int('mb994ah', 24), 4294967297)\n  self.assertEqual(int('hek2mgm', 25), 4294967297)\n  self.assertEqual(int('dnchbnn', 26), 4294967297)\n  self.assertEqual(int('b28jpdn', 27), 4294967297)\n  self.assertEqual(int('8pfgih5', 28), 4294967297)\n  self.assertEqual(int('76beigh', 29), 4294967297)\n  self.assertEqual(int('5qmcpqh', 30), 4294967297)\n  self.assertEqual(int('4q0jto5', 31), 4294967297)\n  self.assertEqual(int('4000001', 32), 4294967297)\n  self.assertEqual(int('3aokq95', 33), 4294967297)\n  self.assertEqual(int('2qhxjlj', 34), 4294967297)\n  self.assertEqual(int('2br45qc', 35), 4294967297)\n  self.assertEqual(int('1z141z5', 36), 4294967297)\n  \n def test_intconversion(self):\n \n  class ClassicMissingMethods:\n   pass\n  self.assertRaises(TypeError, int, ClassicMissingMethods())\n  \n  class MissingMethods(object):\n   pass\n  self.assertRaises(TypeError, int, MissingMethods())\n  \n  class Foo0:\n   def __int__(self):\n    return 42\n    \n  class Foo1(object):\n   def __int__(self):\n    return 42\n    \n  class Foo2(int):\n   def __int__(self):\n    return 42\n    \n  class Foo3(int):\n   def __int__(self):\n    return self\n    \n  class Foo4(int):\n   def __int__(self):\n    return 42\n    \n  class Foo5(int):\n   def __int__(self):\n    return 42.\n    \n  self.assertEqual(int(Foo0()), 42)\n  self.assertEqual(int(Foo1()), 42)\n  self.assertEqual(int(Foo2()), 42)\n  self.assertEqual(int(Foo3()), 0)\n  self.assertEqual(int(Foo4()), 42)\n  self.assertRaises(TypeError, int, Foo5())\n  \n  class Classic:\n   pass\n  for base in (object, Classic):\n   class IntOverridesTrunc(base):\n    def __int__(self):\n     return 42\n    def __trunc__(self):\n     return -12\n   self.assertEqual(int(IntOverridesTrunc()), 42)\n   \n   class JustTrunc(base):\n    def __trunc__(self):\n     return 42\n   self.assertEqual(int(JustTrunc()), 42)\n   \n   for trunc_result_base in (object, Classic):\n    class Integral(trunc_result_base):\n     def __int__(self):\n      return 42\n      \n    class TruncReturnsNonInt(base):\n     def __trunc__(self):\n      return Integral()\n    self.assertEqual(int(TruncReturnsNonInt()), 42)\n    \n    class NonIntegral(trunc_result_base):\n     def __trunc__(self):\n     \n      return NonIntegral()\n      \n    class TruncReturnsNonIntegral(base):\n     def __trunc__(self):\n      return NonIntegral()\n    try:\n     int(TruncReturnsNonIntegral())\n    except TypeError as e:\n     self.assertEqual(str(e),\n     \"__trunc__ returned non-Integral\"\n     \" (type NonIntegral)\")\n    else:\n     self.fail(\"Failed to raise TypeError with %s\" %\n     ((base, trunc_result_base),))\n     \n def test_error_message(self):\n  testlist = ('\\xbd', '123\\xbd', '  123 456  ')\n  for s in testlist:\n   try:\n    int(s)\n   except ValueError as e:\n    self.assertIn(s.strip(), e.args[0])\n   else:\n    self.fail(\"Expected int(%r) to raise a ValueError\", s)\n    \ndef test_main():\n run_unittest(IntTestCases)\n \nif __name__ == \"__main__\":\n test_main()\n"], "unittest.test.test_case": ["import difflib\nimport pprint\nimport pickle\nimport re\nimport sys\nimport warnings\nimport weakref\nimport inspect\n\nfrom copy import deepcopy\nfrom test import support\n\nimport unittest\n\nfrom .support import (\nTestEquality, TestHashing, LoggingResult,\nResultWithNoStartTestRunStopTestRun\n)\n\n\nclass Test(object):\n \"\"\n \n class Foo(unittest.TestCase):\n  def runTest(self): pass\n  def test1(self): pass\n  \n class Bar(Foo):\n  def test2(self): pass\n  \n class LoggingTestCase(unittest.TestCase):\n  \"\"\n  \n  def __init__(self, events):\n   super(Test.LoggingTestCase, self).__init__('test')\n   self.events = events\n   \n  def setUp(self):\n   self.events.append('setUp')\n   \n  def test(self):\n   self.events.append('test')\n   \n  def tearDown(self):\n   self.events.append('tearDown')\n   \n   \nclass Test_TestCase(unittest.TestCase, TestEquality, TestHashing):\n\n\n\n\n\n eq_pairs = [(Test.Foo('test1'), Test.Foo('test1'))]\n \n \n ne_pairs = [(Test.Foo('test1'), Test.Foo('runTest')),\n (Test.Foo('test1'), Test.Bar('test1')),\n (Test.Foo('test1'), Test.Bar('test2'))]\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n def test_init__no_test_name(self):\n  class Test(unittest.TestCase):\n   def runTest(self): raise MyException()\n   def test(self): pass\n   \n  self.assertEqual(Test().id()[-13:], '.Test.runTest')\n  \n  \n  \n  test = unittest.TestCase()\n  test.assertEqual(3, 3)\n  with test.assertRaises(test.failureException):\n   test.assertEqual(3, 2)\n   \n  with self.assertRaises(AttributeError):\n   test.run()\n   \n   \n   \n   \n   \n def test_init__test_name__valid(self):\n  class Test(unittest.TestCase):\n   def runTest(self): raise MyException()\n   def test(self): pass\n   \n  self.assertEqual(Test('test').id()[-10:], '.Test.test')\n  \n  \n  \n  \n  \n def test_init__test_name__invalid(self):\n  class Test(unittest.TestCase):\n   def runTest(self): raise MyException()\n   def test(self): pass\n   \n  try:\n   Test('testfoo')\n  except ValueError:\n   pass\n  else:\n   self.fail(\"Failed to raise ValueError\")\n   \n   \n   \n def test_countTestCases(self):\n  class Foo(unittest.TestCase):\n   def test(self): pass\n   \n  self.assertEqual(Foo('test').countTestCases(), 1)\n  \n  \n  \n  \n  \n def test_defaultTestResult(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n    \n  result = Foo().defaultTestResult()\n  self.assertEqual(type(result), unittest.TestResult)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__error_in_setUp(self):\n  events = []\n  result = LoggingResult(events)\n  \n  class Foo(Test.LoggingTestCase):\n   def setUp(self):\n    super(Foo, self).setUp()\n    raise RuntimeError('raised by Foo.setUp')\n    \n  Foo(events).run(result)\n  expected = ['startTest', 'setUp', 'addError', 'stopTest']\n  self.assertEqual(events, expected)\n  \n  \n def test_run_call_order__error_in_setUp_default_result(self):\n  events = []\n  \n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n    \n   def setUp(self):\n    super(Foo, self).setUp()\n    raise RuntimeError('raised by Foo.setUp')\n    \n  Foo(events).run()\n  expected = ['startTestRun', 'startTest', 'setUp', 'addError',\n  'stopTest', 'stopTestRun']\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__error_in_test(self):\n  events = []\n  result = LoggingResult(events)\n  \n  class Foo(Test.LoggingTestCase):\n   def test(self):\n    super(Foo, self).test()\n    raise RuntimeError('raised by Foo.test')\n    \n  expected = ['startTest', 'setUp', 'test', 'tearDown',\n  'addError', 'stopTest']\n  Foo(events).run(result)\n  self.assertEqual(events, expected)\n  \n  \n  \n def test_run_call_order__error_in_test_default_result(self):\n  events = []\n  \n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n    \n   def test(self):\n    super(Foo, self).test()\n    raise RuntimeError('raised by Foo.test')\n    \n  expected = ['startTestRun', 'startTest', 'setUp', 'test',\n  'tearDown', 'addError', 'stopTest', 'stopTestRun']\n  Foo(events).run()\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__failure_in_test(self):\n  events = []\n  result = LoggingResult(events)\n  \n  class Foo(Test.LoggingTestCase):\n   def test(self):\n    super(Foo, self).test()\n    self.fail('raised by Foo.test')\n    \n  expected = ['startTest', 'setUp', 'test', 'tearDown',\n  'addFailure', 'stopTest']\n  Foo(events).run(result)\n  self.assertEqual(events, expected)\n  \n  \n def test_run_call_order__failure_in_test_default_result(self):\n \n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n   def test(self):\n    super(Foo, self).test()\n    self.fail('raised by Foo.test')\n    \n  expected = ['startTestRun', 'startTest', 'setUp', 'test',\n  'tearDown', 'addFailure', 'stopTest', 'stopTestRun']\n  events = []\n  Foo(events).run()\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__error_in_tearDown(self):\n  events = []\n  result = LoggingResult(events)\n  \n  class Foo(Test.LoggingTestCase):\n   def tearDown(self):\n    super(Foo, self).tearDown()\n    raise RuntimeError('raised by Foo.tearDown')\n    \n  Foo(events).run(result)\n  expected = ['startTest', 'setUp', 'test', 'tearDown', 'addError',\n  'stopTest']\n  self.assertEqual(events, expected)\n  \n  \n def test_run_call_order__error_in_tearDown_default_result(self):\n \n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n   def tearDown(self):\n    super(Foo, self).tearDown()\n    raise RuntimeError('raised by Foo.tearDown')\n    \n  events = []\n  Foo(events).run()\n  expected = ['startTestRun', 'startTest', 'setUp', 'test', 'tearDown',\n  'addError', 'stopTest', 'stopTestRun']\n  self.assertEqual(events, expected)\n  \n  \n  \n def test_run_call_order_default_result(self):\n \n  class Foo(unittest.TestCase):\n   def defaultTestResult(self):\n    return ResultWithNoStartTestRunStopTestRun()\n   def test(self):\n    pass\n    \n  Foo('test').run()\n  \n  \n  \n  \n  \n  \n def test_failureException__default(self):\n  class Foo(unittest.TestCase):\n   def test(self):\n    pass\n    \n  self.assertTrue(Foo('test').failureException is AssertionError)\n  \n  \n  \n  \n  \n  \n  \n def test_failureException__subclassing__explicit_raise(self):\n  events = []\n  result = LoggingResult(events)\n  \n  class Foo(unittest.TestCase):\n   def test(self):\n    raise RuntimeError()\n    \n   failureException = RuntimeError\n   \n  self.assertTrue(Foo('test').failureException is RuntimeError)\n  \n  \n  Foo('test').run(result)\n  expected = ['startTest', 'addFailure', 'stopTest']\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n def test_failureException__subclassing__implicit_raise(self):\n  events = []\n  result = LoggingResult(events)\n  \n  class Foo(unittest.TestCase):\n   def test(self):\n    self.fail(\"foo\")\n    \n   failureException = RuntimeError\n   \n  self.assertTrue(Foo('test').failureException is RuntimeError)\n  \n  \n  Foo('test').run(result)\n  expected = ['startTest', 'addFailure', 'stopTest']\n  self.assertEqual(events, expected)\n  \n  \n def test_setUp(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n    \n    \n  Foo().setUp()\n  \n  \n def test_tearDown(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n    \n    \n  Foo().tearDown()\n  \n  \n  \n  \n  \n  \n  \n def test_id(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n    \n  self.assertIsInstance(Foo().id(), str)\n  \n  \n  \n  \n  \n  \n def test_run__uses_defaultTestResult(self):\n  events = []\n  defaultResult = LoggingResult(events)\n  \n  class Foo(unittest.TestCase):\n   def test(self):\n    events.append('test')\n    \n   def defaultTestResult(self):\n    return defaultResult\n    \n    \n  result = Foo('test').run()\n  \n  self.assertIs(result, defaultResult)\n  expected = ['startTestRun', 'startTest', 'test', 'addSuccess',\n  'stopTest', 'stopTestRun']\n  self.assertEqual(events, expected)\n  \n  \n  \n def test_run__returns_given_result(self):\n \n  class Foo(unittest.TestCase):\n   def test(self):\n    pass\n    \n  result = unittest.TestResult()\n  \n  retval = Foo('test').run(result)\n  self.assertIs(retval, result)\n  \n  \n  \n  \n def test_call__invoking_an_instance_delegates_to_run(self):\n  resultIn = unittest.TestResult()\n  resultOut = unittest.TestResult()\n  \n  class Foo(unittest.TestCase):\n   def test(self):\n    pass\n    \n   def run(self, result):\n    self.assertIs(result, resultIn)\n    return resultOut\n    \n  retval = Foo('test')(resultIn)\n  \n  self.assertIs(retval, resultOut)\n  \n  \n def testShortDescriptionWithoutDocstring(self):\n  self.assertIsNone(self.shortDescription())\n  \n @unittest.skipIf(sys.flags.optimize >= 2,\n \"Docstrings are omitted with -O2 and above\")\n def testShortDescriptionWithOneLineDocstring(self):\n  \"\"\n  self.assertEqual(\n  self.shortDescription(),\n  'Tests shortDescription() for a method with a docstring.')\n  \n @unittest.skipIf(sys.flags.optimize >= 2,\n \"Docstrings are omitted with -O2 and above\")\n def testShortDescriptionWithMultiLineDocstring(self):\n  \"\"\n  self.assertEqual(\n  self.shortDescription(),\n  'Tests shortDescription() for a method with a longer '\n  'docstring.')\n  \n def testAddTypeEqualityFunc(self):\n  class SadSnake(object):\n   \"\"\n  s1, s2 = SadSnake(), SadSnake()\n  self.assertFalse(s1 == s2)\n  def AllSnakesCreatedEqual(a, b, msg=None):\n   return type(a) == type(b) == SadSnake\n  self.addTypeEqualityFunc(SadSnake, AllSnakesCreatedEqual)\n  self.assertEqual(s1, s2)\n  \n  \n  \n  \n def testAssertIs(self):\n  thing = object()\n  self.assertIs(thing, thing)\n  self.assertRaises(self.failureException, self.assertIs, thing, object())\n  \n def testAssertIsNot(self):\n  thing = object()\n  self.assertIsNot(thing, object())\n  self.assertRaises(self.failureException, self.assertIsNot, thing, thing)\n  \n def testAssertIsInstance(self):\n  thing = []\n  self.assertIsInstance(thing, list)\n  self.assertRaises(self.failureException, self.assertIsInstance,\n  thing, dict)\n  \n def testAssertNotIsInstance(self):\n  thing = []\n  self.assertNotIsInstance(thing, dict)\n  self.assertRaises(self.failureException, self.assertNotIsInstance,\n  thing, list)\n  \n def testAssertIn(self):\n  animals = {'monkey': 'banana', 'cow': 'grass', 'seal': 'fish'}\n  \n  self.assertIn('a', 'abc')\n  self.assertIn(2, [1, 2, 3])\n  self.assertIn('monkey', animals)\n  \n  self.assertNotIn('d', 'abc')\n  self.assertNotIn(0, [1, 2, 3])\n  self.assertNotIn('otter', animals)\n  \n  self.assertRaises(self.failureException, self.assertIn, 'x', 'abc')\n  self.assertRaises(self.failureException, self.assertIn, 4, [1, 2, 3])\n  self.assertRaises(self.failureException, self.assertIn, 'elephant',\n  animals)\n  \n  self.assertRaises(self.failureException, self.assertNotIn, 'c', 'abc')\n  self.assertRaises(self.failureException, self.assertNotIn, 1, [1, 2, 3])\n  self.assertRaises(self.failureException, self.assertNotIn, 'cow',\n  animals)\n  \n def testAssertDictContainsSubset(self):\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"ignore\", DeprecationWarning)\n   \n   self.assertDictContainsSubset({}, {})\n   self.assertDictContainsSubset({}, {'a': 1})\n   self.assertDictContainsSubset({'a': 1}, {'a': 1})\n   self.assertDictContainsSubset({'a': 1}, {'a': 1, 'b': 2})\n   self.assertDictContainsSubset({'a': 1, 'b': 2}, {'a': 1, 'b': 2})\n   \n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({1: \"one\"}, {})\n    \n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'a': 2}, {'a': 1})\n    \n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'c': 1}, {'a': 1})\n    \n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'a': 1, 'c': 1}, {'a': 1})\n    \n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'a': 1, 'c': 1}, {'a': 1})\n    \n   one = ''.join(chr(i) for i in range(255))\n   \n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'foo': one}, {'foo': '\\uFFFD'})\n    \n def testAssertEqual(self):\n  equal_pairs = [\n  ((), ()),\n  ({}, {}),\n  ([], []),\n  (set(), set()),\n  (frozenset(), frozenset())]\n  for a, b in equal_pairs:\n  \n  \n   try:\n    self.assertEqual(a, b)\n   except self.failureException:\n    self.fail('assertEqual(%r, %r) failed' % (a, b))\n   try:\n    self.assertEqual(a, b, msg='foo')\n   except self.failureException:\n    self.fail('assertEqual(%r, %r) with msg= failed' % (a, b))\n   try:\n    self.assertEqual(a, b, 'foo')\n   except self.failureException:\n    self.fail('assertEqual(%r, %r) with third parameter failed' %\n    (a, b))\n    \n  unequal_pairs = [\n  ((), []),\n  ({}, set()),\n  (set([4,1]), frozenset([4,2])),\n  (frozenset([4,5]), set([2,3])),\n  (set([3,4]), set([5,4]))]\n  for a, b in unequal_pairs:\n   self.assertRaises(self.failureException, self.assertEqual, a, b)\n   self.assertRaises(self.failureException, self.assertEqual, a, b,\n   'foo')\n   self.assertRaises(self.failureException, self.assertEqual, a, b,\n   msg='foo')\n   \n def testEquality(self):\n  self.assertListEqual([], [])\n  self.assertTupleEqual((), ())\n  self.assertSequenceEqual([], ())\n  \n  a = [0, 'a', []]\n  b = []\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertListEqual, a, b)\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertListEqual, tuple(a), tuple(b))\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertSequenceEqual, a, tuple(b))\n  \n  b.extend(a)\n  self.assertListEqual(a, b)\n  self.assertTupleEqual(tuple(a), tuple(b))\n  self.assertSequenceEqual(a, tuple(b))\n  self.assertSequenceEqual(tuple(a), b)\n  \n  self.assertRaises(self.failureException, self.assertListEqual,\n  a, tuple(b))\n  self.assertRaises(self.failureException, self.assertTupleEqual,\n  tuple(a), b)\n  self.assertRaises(self.failureException, self.assertListEqual, None, b)\n  self.assertRaises(self.failureException, self.assertTupleEqual, None,\n  tuple(b))\n  self.assertRaises(self.failureException, self.assertSequenceEqual,\n  None, tuple(b))\n  self.assertRaises(self.failureException, self.assertListEqual, 1, 1)\n  self.assertRaises(self.failureException, self.assertTupleEqual, 1, 1)\n  self.assertRaises(self.failureException, self.assertSequenceEqual,\n  1, 1)\n  \n  self.assertDictEqual({}, {})\n  \n  c = { 'x': 1 }\n  d = {}\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertDictEqual, c, d)\n  \n  d.update(c)\n  self.assertDictEqual(c, d)\n  \n  d['x'] = 0\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertDictEqual, c, d, 'These are unequal')\n  \n  self.assertRaises(self.failureException, self.assertDictEqual, None, d)\n  self.assertRaises(self.failureException, self.assertDictEqual, [], d)\n  self.assertRaises(self.failureException, self.assertDictEqual, 1, 1)\n  \n def testAssertSequenceEqualMaxDiff(self):\n  self.assertEqual(self.maxDiff, 80*8)\n  seq1 = 'a' + 'x' * 80**2\n  seq2 = 'b' + 'x' * 80**2\n  diff = '\\n'.join(difflib.ndiff(pprint.pformat(seq1).splitlines(),\n  pprint.pformat(seq2).splitlines()))\n  \n  omitted = unittest.case.DIFF_OMITTED % (len(diff) + 1,)\n  \n  self.maxDiff = len(diff)//2\n  try:\n  \n   self.assertSequenceEqual(seq1, seq2)\n  except self.failureException as e:\n   msg = e.args[0]\n  else:\n   self.fail('assertSequenceEqual did not fail.')\n  self.assertTrue(len(msg) < len(diff))\n  self.assertIn(omitted, msg)\n  \n  self.maxDiff = len(diff) * 2\n  try:\n   self.assertSequenceEqual(seq1, seq2)\n  except self.failureException as e:\n   msg = e.args[0]\n  else:\n   self.fail('assertSequenceEqual did not fail.')\n  self.assertTrue(len(msg) > len(diff))\n  self.assertNotIn(omitted, msg)\n  \n  self.maxDiff = None\n  try:\n   self.assertSequenceEqual(seq1, seq2)\n  except self.failureException as e:\n   msg = e.args[0]\n  else:\n   self.fail('assertSequenceEqual did not fail.')\n  self.assertTrue(len(msg) > len(diff))\n  self.assertNotIn(omitted, msg)\n  \n def testTruncateMessage(self):\n  self.maxDiff = 1\n  message = self._truncateMessage('foo', 'bar')\n  omitted = unittest.case.DIFF_OMITTED % len('bar')\n  self.assertEqual(message, 'foo' + omitted)\n  \n  self.maxDiff = None\n  message = self._truncateMessage('foo', 'bar')\n  self.assertEqual(message, 'foobar')\n  \n  self.maxDiff = 4\n  message = self._truncateMessage('foo', 'bar')\n  self.assertEqual(message, 'foobar')\n  \n def testAssertDictEqualTruncates(self):\n  test = unittest.TestCase('assertEqual')\n  def truncate(msg, diff):\n   return 'foo'\n  test._truncateMessage = truncate\n  try:\n   test.assertDictEqual({}, {1: 0})\n  except self.failureException as e:\n   self.assertEqual(str(e), 'foo')\n  else:\n   self.fail('assertDictEqual did not fail')\n   \n def testAssertMultiLineEqualTruncates(self):\n  test = unittest.TestCase('assertEqual')\n  def truncate(msg, diff):\n   return 'foo'\n  test._truncateMessage = truncate\n  try:\n   test.assertMultiLineEqual('foo', 'bar')\n  except self.failureException as e:\n   self.assertEqual(str(e), 'foo')\n  else:\n   self.fail('assertMultiLineEqual did not fail')\n   \n def testAssertEqual_diffThreshold(self):\n \n  self.assertEqual(self._diffThreshold, 2**16)\n  \n  self.maxDiff = None\n  \n  \n  old_threshold = self._diffThreshold\n  self._diffThreshold = 2**8\n  self.addCleanup(lambda: setattr(self, '_diffThreshold', old_threshold))\n  \n  \n  s = 'x' * (2**7)\n  with self.assertRaises(self.failureException) as cm:\n   self.assertEqual(s + 'a', s + 'b')\n  self.assertIn('^', str(cm.exception))\n  self.assertEqual(s + 'a', s + 'a')\n  \n  \n  s = 'x' * (2**9)\n  \n  \n  \n  def explodingTruncation(message, diff):\n   raise SystemError('this should not be raised')\n  old_truncate = self._truncateMessage\n  self._truncateMessage = explodingTruncation\n  self.addCleanup(lambda: setattr(self, '_truncateMessage', old_truncate))\n  \n  s1, s2 = s + 'a', s + 'b'\n  with self.assertRaises(self.failureException) as cm:\n   self.assertEqual(s1, s2)\n  self.assertNotIn('^', str(cm.exception))\n  self.assertEqual(str(cm.exception), '%r != %r' % (s1, s2))\n  self.assertEqual(s + 'a', s + 'a')\n  \n def testAssertCountEqual(self):\n  a = object()\n  self.assertCountEqual([1, 2, 3], [3, 2, 1])\n  self.assertCountEqual(['foo', 'bar', 'baz'], ['bar', 'baz', 'foo'])\n  self.assertCountEqual([a, a, 2, 2, 3], (a, 2, 3, a, 2))\n  self.assertCountEqual([1, \"2\", \"a\", \"a\"], [\"a\", \"2\", True, \"a\"])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [1, 2] + [3] * 100, [1] * 100 + [2, 3])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [1, \"2\", \"a\", \"a\"], [\"a\", \"2\", True, 1])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [10], [10, 11])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [10, 11], [10])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [10, 11, 10], [10, 11])\n  \n  \n  self.assertCountEqual([[1, 2], [3, 4], 0], [False, [3, 4], [1, 2]])\n  \n  self.assertCountEqual(iter([1, 2, [], 3, 4]),\n  iter([1, 2, [], 3, 4]))\n  \n  \n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [], [divmod, 'x', 1, 5j, 2j, frozenset()])\n  \n  self.assertCountEqual([{'a': 1}, {'b': 2}], [{'b': 2}, {'a': 1}])\n  \n  self.assertCountEqual([1, 'x', divmod, []], [divmod, [], 'x', 1])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [], [divmod, [], 'x', 1, 5j, 2j, set()])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [[1]], [[2]])\n  \n  \n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [1, 1, 2], [2, 1])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [1, 1, \"2\", \"a\", \"a\"], [\"2\", \"2\", True, \"a\"])\n  self.assertRaises(self.failureException, self.assertCountEqual,\n  [1, {'b': 2}, None, True], [{'b': 2}, True, None])\n  \n  \n  \n  a = [{2,4}, {1,2}]\n  b = a[::-1]\n  self.assertCountEqual(a, b)\n  \n  \n  \n  diffs = set(unittest.util._count_diff_all_purpose('aaabccd', 'abbbcce'))\n  expected = {(3,1,'a'), (1,3,'b'), (1,0,'d'), (0,1,'e')}\n  self.assertEqual(diffs, expected)\n  \n  diffs = unittest.util._count_diff_all_purpose([[]], [])\n  self.assertEqual(diffs, [(1, 0, [])])\n  \n  diffs = set(unittest.util._count_diff_hashable('aaabccd', 'abbbcce'))\n  expected = {(3,1,'a'), (1,3,'b'), (1,0,'d'), (0,1,'e')}\n  self.assertEqual(diffs, expected)\n  \n def testAssertSetEqual(self):\n  set1 = set()\n  set2 = set()\n  self.assertSetEqual(set1, set2)\n  \n  self.assertRaises(self.failureException, self.assertSetEqual, None, set2)\n  self.assertRaises(self.failureException, self.assertSetEqual, [], set2)\n  self.assertRaises(self.failureException, self.assertSetEqual, set1, None)\n  self.assertRaises(self.failureException, self.assertSetEqual, set1, [])\n  \n  set1 = set(['a'])\n  set2 = set()\n  self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)\n  \n  set1 = set(['a'])\n  set2 = set(['a'])\n  self.assertSetEqual(set1, set2)\n  \n  set1 = set(['a'])\n  set2 = set(['a', 'b'])\n  self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)\n  \n  set1 = set(['a'])\n  set2 = frozenset(['a', 'b'])\n  self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)\n  \n  set1 = set(['a', 'b'])\n  set2 = frozenset(['a', 'b'])\n  self.assertSetEqual(set1, set2)\n  \n  set1 = set()\n  set2 = \"foo\"\n  self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)\n  self.assertRaises(self.failureException, self.assertSetEqual, set2, set1)\n  \n  \n  set1 = set([(0, 1), (2, 3)])\n  set2 = set([(4, 5)])\n  self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)\n  \n def testInequality(self):\n \n  self.assertGreater(2, 1)\n  self.assertGreaterEqual(2, 1)\n  self.assertGreaterEqual(1, 1)\n  self.assertLess(1, 2)\n  self.assertLessEqual(1, 2)\n  self.assertLessEqual(1, 1)\n  self.assertRaises(self.failureException, self.assertGreater, 1, 2)\n  self.assertRaises(self.failureException, self.assertGreater, 1, 1)\n  self.assertRaises(self.failureException, self.assertGreaterEqual, 1, 2)\n  self.assertRaises(self.failureException, self.assertLess, 2, 1)\n  self.assertRaises(self.failureException, self.assertLess, 1, 1)\n  self.assertRaises(self.failureException, self.assertLessEqual, 2, 1)\n  \n  \n  self.assertGreater(1.1, 1.0)\n  self.assertGreaterEqual(1.1, 1.0)\n  self.assertGreaterEqual(1.0, 1.0)\n  self.assertLess(1.0, 1.1)\n  self.assertLessEqual(1.0, 1.1)\n  self.assertLessEqual(1.0, 1.0)\n  self.assertRaises(self.failureException, self.assertGreater, 1.0, 1.1)\n  self.assertRaises(self.failureException, self.assertGreater, 1.0, 1.0)\n  self.assertRaises(self.failureException, self.assertGreaterEqual, 1.0, 1.1)\n  self.assertRaises(self.failureException, self.assertLess, 1.1, 1.0)\n  self.assertRaises(self.failureException, self.assertLess, 1.0, 1.0)\n  self.assertRaises(self.failureException, self.assertLessEqual, 1.1, 1.0)\n  \n  \n  self.assertGreater('bug', 'ant')\n  self.assertGreaterEqual('bug', 'ant')\n  self.assertGreaterEqual('ant', 'ant')\n  self.assertLess('ant', 'bug')\n  self.assertLessEqual('ant', 'bug')\n  self.assertLessEqual('ant', 'ant')\n  self.assertRaises(self.failureException, self.assertGreater, 'ant', 'bug')\n  self.assertRaises(self.failureException, self.assertGreater, 'ant', 'ant')\n  self.assertRaises(self.failureException, self.assertGreaterEqual, 'ant', 'bug')\n  self.assertRaises(self.failureException, self.assertLess, 'bug', 'ant')\n  self.assertRaises(self.failureException, self.assertLess, 'ant', 'ant')\n  self.assertRaises(self.failureException, self.assertLessEqual, 'bug', 'ant')\n  \n  \n  self.assertGreater(b'bug', b'ant')\n  self.assertGreaterEqual(b'bug', b'ant')\n  self.assertGreaterEqual(b'ant', b'ant')\n  self.assertLess(b'ant', b'bug')\n  self.assertLessEqual(b'ant', b'bug')\n  self.assertLessEqual(b'ant', b'ant')\n  self.assertRaises(self.failureException, self.assertGreater, b'ant', b'bug')\n  self.assertRaises(self.failureException, self.assertGreater, b'ant', b'ant')\n  self.assertRaises(self.failureException, self.assertGreaterEqual, b'ant',\n  b'bug')\n  self.assertRaises(self.failureException, self.assertLess, b'bug', b'ant')\n  self.assertRaises(self.failureException, self.assertLess, b'ant', b'ant')\n  self.assertRaises(self.failureException, self.assertLessEqual, b'bug', b'ant')\n  \n def testAssertMultiLineEqual(self):\n  sample_text = \"\"\"\\\nhttp://www.python.org/doc/2.3/lib/module-unittest.html\ntest case\n    A test case is the smallest unit of testing. [...]\n\"\"\"  \n  revised_sample_text = \"\"\"\\\nhttp://www.python.org/doc/2.4.1/lib/module-unittest.html\ntest case\n    A test case is the smallest unit of testing. [...] You may provide your\n    own implementation that does not subclass from TestCase, of course.\n\"\"\"  \n  sample_text_error = \"\"\"\\\n- http://www.python.org/doc/2.3/lib/module-unittest.html\n?                             ^\n+ http://www.python.org/doc/2.4.1/lib/module-unittest.html\n?                             ^^^\n  test case\n-     A test case is the smallest unit of testing. [...]\n+     A test case is the smallest unit of testing. [...] You may provide your\n?                                                       +++++++++++++++++++++\n+     own implementation that does not subclass from TestCase, of course.\n\"\"\"  \n  self.maxDiff = None\n  try:\n   self.assertMultiLineEqual(sample_text, revised_sample_text)\n  except self.failureException as e:\n  \n   error = str(e).split('\\n', 1)[1]\n   \n   \n   \n   self.assertTrue(sample_text_error == error)\n   \n def testAsertEqualSingleLine(self):\n  sample_text = \"laden swallows fly slowly\"\n  revised_sample_text = \"unladen swallows fly quickly\"\n  sample_text_error = \"\"\"\\\n- laden swallows fly slowly\n?                    ^^^^\n+ unladen swallows fly quickly\n? ++                   ^^^^^\n\"\"\"  \n  try:\n   self.assertEqual(sample_text, revised_sample_text)\n  except self.failureException as e:\n   error = str(e).split('\\n', 1)[1]\n   self.assertTrue(sample_text_error == error)\n   \n def testAssertIsNone(self):\n  self.assertIsNone(None)\n  self.assertRaises(self.failureException, self.assertIsNone, False)\n  self.assertIsNotNone('DjZoPloGears on Rails')\n  self.assertRaises(self.failureException, self.assertIsNotNone, None)\n  \n def testAssertRegex(self):\n  self.assertRegex('asdfabasdf', r'ab+')\n  self.assertRaises(self.failureException, self.assertRegex,\n  'saaas', r'aaaa')\n  \n def testAssertRaisesRegex(self):\n  class ExceptionMock(Exception):\n   pass\n   \n  def Stub():\n   raise ExceptionMock('We expect')\n   \n  self.assertRaisesRegex(ExceptionMock, re.compile('expect$'), Stub)\n  self.assertRaisesRegex(ExceptionMock, 'expect$', Stub)\n  \n def testAssertNotRaisesRegex(self):\n  self.assertRaisesRegex(\n  self.failureException, '^Exception not raised by <lambda>$',\n  self.assertRaisesRegex, Exception, re.compile('x'),\n  lambda: None)\n  self.assertRaisesRegex(\n  self.failureException, '^Exception not raised by <lambda>$',\n  self.assertRaisesRegex, Exception, 'x',\n  lambda: None)\n  \n def testAssertRaisesRegexMismatch(self):\n  def Stub():\n   raise Exception('Unexpected')\n   \n  self.assertRaisesRegex(\n  self.failureException,\n  r'\"\\^Expected\\$\" does not match \"Unexpected\"',\n  self.assertRaisesRegex, Exception, '^Expected$',\n  Stub)\n  self.assertRaisesRegex(\n  self.failureException,\n  r'\"\\^Expected\\$\" does not match \"Unexpected\"',\n  self.assertRaisesRegex, Exception,\n  re.compile('^Expected$'), Stub)\n  \n def testAssertRaisesExcValue(self):\n  class ExceptionMock(Exception):\n   pass\n   \n  def Stub(foo):\n   raise ExceptionMock(foo)\n  v = \"particular value\"\n  \n  ctx = self.assertRaises(ExceptionMock)\n  with ctx:\n   Stub(v)\n  e = ctx.exception\n  self.assertIsInstance(e, ExceptionMock)\n  self.assertEqual(e.args[0], v)\n  \n def testAssertWarnsCallable(self):\n  def _runtime_warn():\n   warnings.warn(\"foo\", RuntimeWarning)\n   \n  self.assertWarns(RuntimeWarning, _runtime_warn)\n  self.assertWarns(RuntimeWarning, _runtime_warn)\n  \n  self.assertWarns((DeprecationWarning, RuntimeWarning), _runtime_warn)\n  \n  self.assertWarns(RuntimeWarning,\n  warnings.warn, \"foo\", category=RuntimeWarning)\n  \n  with self.assertRaises(self.failureException):\n   self.assertWarns(RuntimeWarning, lambda: 0)\n   \n  with warnings.catch_warnings():\n  \n   warnings.simplefilter(\"default\", RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    self.assertWarns(DeprecationWarning, _runtime_warn)\n    \n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\", RuntimeWarning)\n   with self.assertRaises(RuntimeWarning):\n    self.assertWarns(DeprecationWarning, _runtime_warn)\n    \n def testAssertWarnsContext(self):\n \n \n  def _runtime_warn():\n   warnings.warn(\"foo\", RuntimeWarning)\n  _runtime_warn_lineno = inspect.getsourcelines(_runtime_warn)[1]\n  with self.assertWarns(RuntimeWarning) as cm:\n   _runtime_warn()\n   \n  with self.assertWarns((DeprecationWarning, RuntimeWarning)) as cm:\n   _runtime_warn()\n   \n  self.assertIsInstance(cm.warning, RuntimeWarning)\n  self.assertEqual(cm.warning.args[0], \"foo\")\n  self.assertIn(\"test_case.py\", cm.filename)\n  self.assertEqual(cm.lineno, _runtime_warn_lineno + 1)\n  \n  with self.assertWarns(RuntimeWarning):\n   _runtime_warn()\n   _runtime_warn()\n  with self.assertWarns(RuntimeWarning):\n   warnings.warn(\"foo\", category=RuntimeWarning)\n   \n  with self.assertRaises(self.failureException):\n   with self.assertWarns(RuntimeWarning):\n    pass\n    \n  with warnings.catch_warnings():\n  \n   warnings.simplefilter(\"default\", RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    with self.assertWarns(DeprecationWarning):\n     _runtime_warn()\n     \n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\", RuntimeWarning)\n   with self.assertRaises(RuntimeWarning):\n    with self.assertWarns(DeprecationWarning):\n     _runtime_warn()\n     \n def testAssertWarnsRegexCallable(self):\n  def _runtime_warn(msg):\n   warnings.warn(msg, RuntimeWarning)\n  self.assertWarnsRegex(RuntimeWarning, \"o+\",\n  _runtime_warn, \"foox\")\n  \n  with self.assertRaises(self.failureException):\n   self.assertWarnsRegex(RuntimeWarning, \"o+\",\n   lambda: 0)\n   \n  with warnings.catch_warnings():\n  \n   warnings.simplefilter(\"default\", RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    self.assertWarnsRegex(DeprecationWarning, \"o+\",\n    _runtime_warn, \"foox\")\n    \n  with self.assertRaises(self.failureException):\n   self.assertWarnsRegex(RuntimeWarning, \"o+\",\n   _runtime_warn, \"barz\")\n   \n   \n   \n   \n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\", RuntimeWarning)\n   with self.assertRaises((RuntimeWarning, self.failureException)):\n    self.assertWarnsRegex(RuntimeWarning, \"o+\",\n    _runtime_warn, \"barz\")\n    \n def testAssertWarnsRegexContext(self):\n \n  def _runtime_warn(msg):\n   warnings.warn(msg, RuntimeWarning)\n  _runtime_warn_lineno = inspect.getsourcelines(_runtime_warn)[1]\n  with self.assertWarnsRegex(RuntimeWarning, \"o+\") as cm:\n   _runtime_warn(\"foox\")\n  self.assertIsInstance(cm.warning, RuntimeWarning)\n  self.assertEqual(cm.warning.args[0], \"foox\")\n  self.assertIn(\"test_case.py\", cm.filename)\n  self.assertEqual(cm.lineno, _runtime_warn_lineno + 1)\n  \n  with self.assertRaises(self.failureException):\n   with self.assertWarnsRegex(RuntimeWarning, \"o+\"):\n    pass\n    \n  with warnings.catch_warnings():\n  \n   warnings.simplefilter(\"default\", RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    with self.assertWarnsRegex(DeprecationWarning, \"o+\"):\n     _runtime_warn(\"foox\")\n     \n  with self.assertRaises(self.failureException):\n   with self.assertWarnsRegex(RuntimeWarning, \"o+\"):\n    _runtime_warn(\"barz\")\n    \n    \n    \n    \n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\", RuntimeWarning)\n   with self.assertRaises((RuntimeWarning, self.failureException)):\n    with self.assertWarnsRegex(RuntimeWarning, \"o+\"):\n     _runtime_warn(\"barz\")\n     \n def testDeprecatedMethodNames(self):\n  \"\"\n  old = (\n  (self.failIfEqual, (3, 5)),\n  (self.assertNotEquals, (3, 5)),\n  (self.failUnlessEqual, (3, 3)),\n  (self.assertEquals, (3, 3)),\n  (self.failUnlessAlmostEqual, (2.0, 2.0)),\n  (self.assertAlmostEquals, (2.0, 2.0)),\n  (self.failIfAlmostEqual, (3.0, 5.0)),\n  (self.assertNotAlmostEquals, (3.0, 5.0)),\n  (self.failUnless, (True,)),\n  (self.assert_, (True,)),\n  (self.failUnlessRaises, (TypeError, lambda _: 3.14 + 'spam')),\n  (self.failIf, (False,)),\n  (self.assertDictContainsSubset, (dict(a=1, b=2), dict(a=1, b=2, c=3))),\n  (self.assertRaisesRegexp, (KeyError, 'foo', lambda: {}['foo'])),\n  (self.assertRegexpMatches, ('bar', 'bar')),\n  )\n  for meth, args in old:\n   with self.assertWarns(DeprecationWarning):\n    meth(*args)\n    \n    \n    \n def _testDeprecatedFailMethods(self):\n  \"\"\n  if sys.version_info[:2] < (3, 3):\n   return\n  deprecated_names = [\n  'failIfEqual', 'failUnlessEqual', 'failUnlessAlmostEqual',\n  'failIfAlmostEqual', 'failUnless', 'failUnlessRaises', 'failIf',\n  'assertDictContainsSubset',\n  ]\n  for deprecated_name in deprecated_names:\n   with self.assertRaises(AttributeError):\n    getattr(self, deprecated_name) \n    \n def testDeepcopy(self):\n \n  class TestableTest(unittest.TestCase):\n   def testNothing(self):\n    pass\n    \n  test = TestableTest('testNothing')\n  \n  \n  deepcopy(test)\n  \n def testPickle(self):\n \n \n \n \n  test = unittest.TestCase('run')\n  for protocol in range(pickle.HIGHEST_PROTOCOL + 1):\n  \n  \n   pickled_test = pickle.dumps(test, protocol=protocol)\n   unpickled_test = pickle.loads(pickled_test)\n   self.assertEqual(test, unpickled_test)\n   \n   \n   \n   unpickled_test.assertEqual(set(), set())\n   \n def testKeyboardInterrupt(self):\n  def _raise(self=None):\n   raise KeyboardInterrupt\n  def nothing(self):\n   pass\n   \n  class Test1(unittest.TestCase):\n   test_something = _raise\n   \n  class Test2(unittest.TestCase):\n   setUp = _raise\n   test_something = nothing\n   \n  class Test3(unittest.TestCase):\n   test_something = nothing\n   tearDown = _raise\n   \n  class Test4(unittest.TestCase):\n   def test_something(self):\n    self.addCleanup(_raise)\n    \n  for klass in (Test1, Test2, Test3, Test4):\n   with self.assertRaises(KeyboardInterrupt):\n    klass('test_something').run()\n    \n def testSkippingEverywhere(self):\n  def _skip(self=None):\n   raise unittest.SkipTest('some reason')\n  def nothing(self):\n   pass\n   \n  class Test1(unittest.TestCase):\n   test_something = _skip\n   \n  class Test2(unittest.TestCase):\n   setUp = _skip\n   test_something = nothing\n   \n  class Test3(unittest.TestCase):\n   test_something = nothing\n   tearDown = _skip\n   \n  class Test4(unittest.TestCase):\n   def test_something(self):\n    self.addCleanup(_skip)\n    \n  for klass in (Test1, Test2, Test3, Test4):\n   result = unittest.TestResult()\n   klass('test_something').run(result)\n   self.assertEqual(len(result.skipped), 1)\n   self.assertEqual(result.testsRun, 1)\n   \n def testSystemExit(self):\n  def _raise(self=None):\n   raise SystemExit\n  def nothing(self):\n   pass\n   \n  class Test1(unittest.TestCase):\n   test_something = _raise\n   \n  class Test2(unittest.TestCase):\n   setUp = _raise\n   test_something = nothing\n   \n  class Test3(unittest.TestCase):\n   test_something = nothing\n   tearDown = _raise\n   \n  class Test4(unittest.TestCase):\n   def test_something(self):\n    self.addCleanup(_raise)\n    \n  for klass in (Test1, Test2, Test3, Test4):\n   result = unittest.TestResult()\n   klass('test_something').run(result)\n   self.assertEqual(len(result.errors), 1)\n   self.assertEqual(result.testsRun, 1)\n   \n @support.cpython_only\n def testNoCycles(self):\n  case = unittest.TestCase()\n  wr = weakref.ref(case)\n  with support.disable_gc():\n   del case\n   self.assertFalse(wr())\n"], "unittest.__main__": ["\"\"\n\nimport sys\nif sys.argv[0].endswith(\"__main__.py\"):\n import os.path\n \n \n \n \n executable = os.path.basename(sys.executable)\n sys.argv[0] = executable + \" -m unittest\"\n del os\n \n__unittest = True\n\nfrom .main import main, TestProgram, USAGE_AS_MAIN\nTestProgram.USAGE = USAGE_AS_MAIN\n\nmain(module=None)\n"], "unittest.test.testmock.testhelpers": ["import unittest\n\nfrom unittest.mock import (\ncall, _Call, create_autospec, MagicMock,\nMock, ANY, _CallList, patch, PropertyMock\n)\n\nfrom datetime import datetime\n\nclass SomeClass(object):\n def one(self, a, b):\n  pass\n def two(self):\n  pass\n def three(self, a=None):\n  pass\n  \n  \n  \nclass AnyTest(unittest.TestCase):\n\n def test_any(self):\n  self.assertEqual(ANY, object())\n  \n  mock = Mock()\n  mock(ANY)\n  mock.assert_called_with(ANY)\n  \n  mock = Mock()\n  mock(foo=ANY)\n  mock.assert_called_with(foo=ANY)\n  \n def test_repr(self):\n  self.assertEqual(repr(ANY), '<ANY>')\n  self.assertEqual(str(ANY), '<ANY>')\n  \n  \n def test_any_and_datetime(self):\n  mock = Mock()\n  mock(datetime.now(), foo=datetime.now())\n  \n  mock.assert_called_with(ANY, foo=ANY)\n  \n  \n def test_any_mock_calls_comparison_order(self):\n  mock = Mock()\n  d = datetime.now()\n  class Foo(object):\n   def __eq__(self, other):\n    return False\n   def __ne__(self, other):\n    return True\n    \n  for d in datetime.now(), Foo():\n   mock.reset_mock()\n   \n   mock(d, foo=d, bar=d)\n   mock.method(d, zinga=d, alpha=d)\n   mock().method(a1=d, z99=d)\n   \n   expected = [\n   call(ANY, foo=ANY, bar=ANY),\n   call.method(ANY, zinga=ANY, alpha=ANY),\n   call(), call().method(a1=ANY, z99=ANY)\n   ]\n   self.assertEqual(expected, mock.mock_calls)\n   self.assertEqual(mock.mock_calls, expected)\n   \n   \n   \nclass CallTest(unittest.TestCase):\n\n def test_call_with_call(self):\n  kall = _Call()\n  self.assertEqual(kall, _Call())\n  self.assertEqual(kall, _Call(('',)))\n  self.assertEqual(kall, _Call(((),)))\n  self.assertEqual(kall, _Call(({},)))\n  self.assertEqual(kall, _Call(('', ())))\n  self.assertEqual(kall, _Call(('', {})))\n  self.assertEqual(kall, _Call(('', (), {})))\n  self.assertEqual(kall, _Call(('foo',)))\n  self.assertEqual(kall, _Call(('bar', ())))\n  self.assertEqual(kall, _Call(('baz', {})))\n  self.assertEqual(kall, _Call(('spam', (), {})))\n  \n  kall = _Call(((1, 2, 3),))\n  self.assertEqual(kall, _Call(((1, 2, 3),)))\n  self.assertEqual(kall, _Call(('', (1, 2, 3))))\n  self.assertEqual(kall, _Call(((1, 2, 3), {})))\n  self.assertEqual(kall, _Call(('', (1, 2, 3), {})))\n  \n  kall = _Call(((1, 2, 4),))\n  self.assertNotEqual(kall, _Call(('', (1, 2, 3))))\n  self.assertNotEqual(kall, _Call(('', (1, 2, 3), {})))\n  \n  kall = _Call(('foo', (1, 2, 4),))\n  self.assertNotEqual(kall, _Call(('', (1, 2, 4))))\n  self.assertNotEqual(kall, _Call(('', (1, 2, 4), {})))\n  self.assertNotEqual(kall, _Call(('bar', (1, 2, 4))))\n  self.assertNotEqual(kall, _Call(('bar', (1, 2, 4), {})))\n  \n  kall = _Call(({'a': 3},))\n  self.assertEqual(kall, _Call(('', (), {'a': 3})))\n  self.assertEqual(kall, _Call(('', {'a': 3})))\n  self.assertEqual(kall, _Call(((), {'a': 3})))\n  self.assertEqual(kall, _Call(({'a': 3},)))\n  \n  \n def test_empty__Call(self):\n  args = _Call()\n  \n  self.assertEqual(args, ())\n  self.assertEqual(args, ('foo',))\n  self.assertEqual(args, ((),))\n  self.assertEqual(args, ('foo', ()))\n  self.assertEqual(args, ('foo',(), {}))\n  self.assertEqual(args, ('foo', {}))\n  self.assertEqual(args, ({},))\n  \n  \n def test_named_empty_call(self):\n  args = _Call(('foo', (), {}))\n  \n  self.assertEqual(args, ('foo',))\n  self.assertEqual(args, ('foo', ()))\n  self.assertEqual(args, ('foo',(), {}))\n  self.assertEqual(args, ('foo', {}))\n  \n  self.assertNotEqual(args, ((),))\n  self.assertNotEqual(args, ())\n  self.assertNotEqual(args, ({},))\n  self.assertNotEqual(args, ('bar',))\n  self.assertNotEqual(args, ('bar', ()))\n  self.assertNotEqual(args, ('bar', {}))\n  \n  \n def test_call_with_args(self):\n  args = _Call(((1, 2, 3), {}))\n  \n  self.assertEqual(args, ((1, 2, 3),))\n  self.assertEqual(args, ('foo', (1, 2, 3)))\n  self.assertEqual(args, ('foo', (1, 2, 3), {}))\n  self.assertEqual(args, ((1, 2, 3), {}))\n  \n  \n def test_named_call_with_args(self):\n  args = _Call(('foo', (1, 2, 3), {}))\n  \n  self.assertEqual(args, ('foo', (1, 2, 3)))\n  self.assertEqual(args, ('foo', (1, 2, 3), {}))\n  \n  self.assertNotEqual(args, ((1, 2, 3),))\n  self.assertNotEqual(args, ((1, 2, 3), {}))\n  \n  \n def test_call_with_kwargs(self):\n  args = _Call(((), dict(a=3, b=4)))\n  \n  self.assertEqual(args, (dict(a=3, b=4),))\n  self.assertEqual(args, ('foo', dict(a=3, b=4)))\n  self.assertEqual(args, ('foo', (), dict(a=3, b=4)))\n  self.assertEqual(args, ((), dict(a=3, b=4)))\n  \n  \n def test_named_call_with_kwargs(self):\n  args = _Call(('foo', (), dict(a=3, b=4)))\n  \n  self.assertEqual(args, ('foo', dict(a=3, b=4)))\n  self.assertEqual(args, ('foo', (), dict(a=3, b=4)))\n  \n  self.assertNotEqual(args, (dict(a=3, b=4),))\n  self.assertNotEqual(args, ((), dict(a=3, b=4)))\n  \n  \n def test_call_with_args_call_empty_name(self):\n  args = _Call(((1, 2, 3), {}))\n  self.assertEqual(args, call(1, 2, 3))\n  self.assertEqual(call(1, 2, 3), args)\n  self.assertTrue(call(1, 2, 3) in [args])\n  \n  \n def test_call_ne(self):\n  self.assertNotEqual(_Call(((1, 2, 3),)), call(1, 2))\n  self.assertFalse(_Call(((1, 2, 3),)) != call(1, 2, 3))\n  self.assertTrue(_Call(((1, 2), {})) != call(1, 2, 3))\n  \n  \n def test_call_non_tuples(self):\n  kall = _Call(((1, 2, 3),))\n  for value in 1, None, self, int:\n   self.assertNotEqual(kall, value)\n   self.assertFalse(kall == value)\n   \n   \n def test_repr(self):\n  self.assertEqual(repr(_Call()), 'call()')\n  self.assertEqual(repr(_Call(('foo',))), 'call.foo()')\n  \n  self.assertEqual(repr(_Call(((1, 2, 3), {'a': 'b'}))),\n  \"call(1, 2, 3, a='b')\")\n  self.assertEqual(repr(_Call(('bar', (1, 2, 3), {'a': 'b'}))),\n  \"call.bar(1, 2, 3, a='b')\")\n  \n  self.assertEqual(repr(call), 'call')\n  self.assertEqual(str(call), 'call')\n  \n  self.assertEqual(repr(call()), 'call()')\n  self.assertEqual(repr(call(1)), 'call(1)')\n  self.assertEqual(repr(call(zz='thing')), \"call(zz='thing')\")\n  \n  self.assertEqual(repr(call().foo), 'call().foo')\n  self.assertEqual(repr(call(1).foo.bar(a=3).bing),\n  'call().foo.bar().bing')\n  self.assertEqual(\n  repr(call().foo(1, 2, a=3)),\n  \"call().foo(1, 2, a=3)\"\n  )\n  self.assertEqual(repr(call()()), \"call()()\")\n  self.assertEqual(repr(call(1)(2)), \"call()(2)\")\n  self.assertEqual(\n  repr(call()().bar().baz.beep(1)),\n  \"call()().bar().baz.beep(1)\"\n  )\n  \n  \n def test_call(self):\n  self.assertEqual(call(), ('', (), {}))\n  self.assertEqual(call('foo', 'bar', one=3, two=4),\n  ('', ('foo', 'bar'), {'one': 3, 'two': 4}))\n  \n  mock = Mock()\n  mock(1, 2, 3)\n  mock(a=3, b=6)\n  self.assertEqual(mock.call_args_list,\n  [call(1, 2, 3), call(a=3, b=6)])\n  \n def test_attribute_call(self):\n  self.assertEqual(call.foo(1), ('foo', (1,), {}))\n  self.assertEqual(call.bar.baz(fish='eggs'),\n  ('bar.baz', (), {'fish': 'eggs'}))\n  \n  mock = Mock()\n  mock.foo(1, 2 ,3)\n  mock.bar.baz(a=3, b=6)\n  self.assertEqual(mock.method_calls,\n  [call.foo(1, 2, 3), call.bar.baz(a=3, b=6)])\n  \n  \n def test_extended_call(self):\n  result = call(1).foo(2).bar(3, a=4)\n  self.assertEqual(result, ('().foo().bar', (3,), dict(a=4)))\n  \n  mock = MagicMock()\n  mock(1, 2, a=3, b=4)\n  self.assertEqual(mock.call_args, call(1, 2, a=3, b=4))\n  self.assertNotEqual(mock.call_args, call(1, 2, 3))\n  \n  self.assertEqual(mock.call_args_list, [call(1, 2, a=3, b=4)])\n  self.assertEqual(mock.mock_calls, [call(1, 2, a=3, b=4)])\n  \n  mock = MagicMock()\n  mock.foo(1).bar()().baz.beep(a=6)\n  \n  last_call = call.foo(1).bar()().baz.beep(a=6)\n  self.assertEqual(mock.mock_calls[-1], last_call)\n  self.assertEqual(mock.mock_calls, last_call.call_list())\n  \n  \n def test_call_list(self):\n  mock = MagicMock()\n  mock(1)\n  self.assertEqual(call(1).call_list(), mock.mock_calls)\n  \n  mock = MagicMock()\n  mock(1).method(2)\n  self.assertEqual(call(1).method(2).call_list(),\n  mock.mock_calls)\n  \n  mock = MagicMock()\n  mock(1).method(2)(3)\n  self.assertEqual(call(1).method(2)(3).call_list(),\n  mock.mock_calls)\n  \n  mock = MagicMock()\n  int(mock(1).method(2)(3).foo.bar.baz(4)(5))\n  kall = call(1).method(2)(3).foo.bar.baz(4)(5).__int__()\n  self.assertEqual(kall.call_list(), mock.mock_calls)\n  \n  \n def test_call_any(self):\n  self.assertEqual(call, ANY)\n  \n  m = MagicMock()\n  int(m)\n  self.assertEqual(m.mock_calls, [ANY])\n  self.assertEqual([ANY], m.mock_calls)\n  \n  \n def test_two_args_call(self):\n  args = _Call(((1, 2), {'a': 3}), two=True)\n  self.assertEqual(len(args), 2)\n  self.assertEqual(args[0], (1, 2))\n  self.assertEqual(args[1], {'a': 3})\n  \n  other_args = _Call(((1, 2), {'a': 3}))\n  self.assertEqual(args, other_args)\n  \n  \nclass SpecSignatureTest(unittest.TestCase):\n\n def _check_someclass_mock(self, mock):\n  self.assertRaises(AttributeError, getattr, mock, 'foo')\n  mock.one(1, 2)\n  mock.one.assert_called_with(1, 2)\n  self.assertRaises(AssertionError,\n  mock.one.assert_called_with, 3, 4)\n  self.assertRaises(TypeError, mock.one, 1)\n  \n  mock.two()\n  mock.two.assert_called_with()\n  self.assertRaises(AssertionError,\n  mock.two.assert_called_with, 3)\n  self.assertRaises(TypeError, mock.two, 1)\n  \n  mock.three()\n  mock.three.assert_called_with()\n  self.assertRaises(AssertionError,\n  mock.three.assert_called_with, 3)\n  self.assertRaises(TypeError, mock.three, 3, 2)\n  \n  mock.three(1)\n  mock.three.assert_called_with(1)\n  \n  mock.three(a=1)\n  mock.three.assert_called_with(a=1)\n  \n  \n def test_basic(self):\n  for spec in (SomeClass, SomeClass()):\n   mock = create_autospec(spec)\n   self._check_someclass_mock(mock)\n   \n   \n def test_create_autospec_return_value(self):\n  def f():\n   pass\n  mock = create_autospec(f, return_value='foo')\n  self.assertEqual(mock(), 'foo')\n  \n  class Foo(object):\n   pass\n   \n  mock = create_autospec(Foo, return_value='foo')\n  self.assertEqual(mock(), 'foo')\n  \n  \n def test_autospec_reset_mock(self):\n  m = create_autospec(int)\n  int(m)\n  m.reset_mock()\n  self.assertEqual(m.__int__.call_count, 0)\n  \n  \n def test_mocking_unbound_methods(self):\n  class Foo(object):\n   def foo(self, foo):\n    pass\n  p = patch.object(Foo, 'foo')\n  mock_foo = p.start()\n  Foo().foo(1)\n  \n  mock_foo.assert_called_with(1)\n  \n  \n def test_create_autospec_unbound_methods(self):\n \n \n  return\n  class Foo(object):\n   def foo(self):\n    pass\n    \n  klass = create_autospec(Foo)\n  instance = klass()\n  self.assertRaises(TypeError, instance.foo, 1)\n  \n  \n  klass.foo(1)\n  klass.foo.assert_called_with(1)\n  self.assertRaises(TypeError, klass.foo)\n  \n  \n def test_create_autospec_keyword_arguments(self):\n  class Foo(object):\n   a = 3\n  m = create_autospec(Foo, a='3')\n  self.assertEqual(m.a, '3')\n  \n  \n def test_create_autospec_keyword_only_arguments(self):\n  def foo(a, *, b=None):\n   pass\n   \n  m = create_autospec(foo)\n  m(1)\n  m.assert_called_with(1)\n  self.assertRaises(TypeError, m, 1, 2)\n  \n  m(2, b=3)\n  m.assert_called_with(2, b=3)\n  \n  \n def test_function_as_instance_attribute(self):\n  obj = SomeClass()\n  def f(a):\n   pass\n  obj.f = f\n  \n  mock = create_autospec(obj)\n  mock.f('bing')\n  mock.f.assert_called_with('bing')\n  \n  \n def test_spec_as_list(self):\n \n \n  mock = create_autospec([])\n  mock.append('foo')\n  mock.append.assert_called_with('foo')\n  \n  self.assertRaises(AttributeError, getattr, mock, 'foo')\n  \n  class Foo(object):\n   foo = []\n   \n  mock = create_autospec(Foo)\n  mock.foo.append(3)\n  mock.foo.append.assert_called_with(3)\n  self.assertRaises(AttributeError, getattr, mock.foo, 'foo')\n  \n  \n def test_attributes(self):\n  class Sub(SomeClass):\n   attr = SomeClass()\n   \n  sub_mock = create_autospec(Sub)\n  \n  for mock in (sub_mock, sub_mock.attr):\n   self._check_someclass_mock(mock)\n   \n   \n def test_builtin_functions_types(self):\n \n \n \n  class BuiltinSubclass(list):\n   def bar(self, arg):\n    pass\n   sorted = sorted\n   attr = {}\n   \n  mock = create_autospec(BuiltinSubclass)\n  mock.append(3)\n  mock.append.assert_called_with(3)\n  self.assertRaises(AttributeError, getattr, mock.append, 'foo')\n  \n  mock.bar('foo')\n  mock.bar.assert_called_with('foo')\n  self.assertRaises(TypeError, mock.bar, 'foo', 'bar')\n  self.assertRaises(AttributeError, getattr, mock.bar, 'foo')\n  \n  mock.sorted([1, 2])\n  mock.sorted.assert_called_with([1, 2])\n  self.assertRaises(AttributeError, getattr, mock.sorted, 'foo')\n  \n  mock.attr.pop(3)\n  mock.attr.pop.assert_called_with(3)\n  self.assertRaises(AttributeError, getattr, mock.attr, 'foo')\n  \n  \n def test_method_calls(self):\n  class Sub(SomeClass):\n   attr = SomeClass()\n   \n  mock = create_autospec(Sub)\n  mock.one(1, 2)\n  mock.two()\n  mock.three(3)\n  \n  expected = [call.one(1, 2), call.two(), call.three(3)]\n  self.assertEqual(mock.method_calls, expected)\n  \n  mock.attr.one(1, 2)\n  mock.attr.two()\n  mock.attr.three(3)\n  \n  expected.extend(\n  [call.attr.one(1, 2), call.attr.two(), call.attr.three(3)]\n  )\n  self.assertEqual(mock.method_calls, expected)\n  \n  \n def test_magic_methods(self):\n  class BuiltinSubclass(list):\n   attr = {}\n   \n  mock = create_autospec(BuiltinSubclass)\n  self.assertEqual(list(mock), [])\n  self.assertRaises(TypeError, int, mock)\n  self.assertRaises(TypeError, int, mock.attr)\n  self.assertEqual(list(mock), [])\n  \n  self.assertIsInstance(mock['foo'], MagicMock)\n  self.assertIsInstance(mock.attr['foo'], MagicMock)\n  \n  \n def test_spec_set(self):\n  class Sub(SomeClass):\n   attr = SomeClass()\n   \n  for spec in (Sub, Sub()):\n   mock = create_autospec(spec, spec_set=True)\n   self._check_someclass_mock(mock)\n   \n   self.assertRaises(AttributeError, setattr, mock, 'foo', 'bar')\n   self.assertRaises(AttributeError, setattr, mock.attr, 'foo', 'bar')\n   \n   \n def test_descriptors(self):\n  class Foo(object):\n   @classmethod\n   def f(cls, a, b):\n    pass\n   @staticmethod\n   def g(a, b):\n    pass\n    \n  class Bar(Foo):\n   pass\n   \n  class Baz(SomeClass, Bar):\n   pass\n   \n  for spec in (Foo, Foo(), Bar, Bar(), Baz, Baz()):\n   mock = create_autospec(spec)\n   mock.f(1, 2)\n   mock.f.assert_called_once_with(1, 2)\n   \n   mock.g(3, 4)\n   mock.g.assert_called_once_with(3, 4)\n   \n   \n def test_recursive(self):\n  class A(object):\n   def a(self):\n    pass\n   foo = 'foo bar baz'\n   bar = foo\n   \n  A.B = A\n  mock = create_autospec(A)\n  \n  mock()\n  self.assertFalse(mock.B.called)\n  \n  mock.a()\n  mock.B.a()\n  self.assertEqual(mock.method_calls, [call.a(), call.B.a()])\n  \n  self.assertIs(A.foo, A.bar)\n  self.assertIsNot(mock.foo, mock.bar)\n  mock.foo.lower()\n  self.assertRaises(AssertionError, mock.bar.lower.assert_called_with)\n  \n  \n def test_spec_inheritance_for_classes(self):\n  class Foo(object):\n   def a(self):\n    pass\n   class Bar(object):\n    def f(self):\n     pass\n     \n  class_mock = create_autospec(Foo)\n  \n  self.assertIsNot(class_mock, class_mock())\n  \n  for this_mock in class_mock, class_mock():\n   this_mock.a()\n   this_mock.a.assert_called_with()\n   self.assertRaises(TypeError, this_mock.a, 'foo')\n   self.assertRaises(AttributeError, getattr, this_mock, 'b')\n   \n  instance_mock = create_autospec(Foo())\n  instance_mock.a()\n  instance_mock.a.assert_called_with()\n  self.assertRaises(TypeError, instance_mock.a, 'foo')\n  self.assertRaises(AttributeError, getattr, instance_mock, 'b')\n  \n  \n  self.assertRaises(TypeError, instance_mock)\n  \n  instance_mock.Bar.f()\n  instance_mock.Bar.f.assert_called_with()\n  self.assertRaises(AttributeError, getattr, instance_mock.Bar, 'g')\n  \n  instance_mock.Bar().f()\n  instance_mock.Bar().f.assert_called_with()\n  self.assertRaises(AttributeError, getattr, instance_mock.Bar(), 'g')\n  \n  \n def test_inherit(self):\n  class Foo(object):\n   a = 3\n   \n  Foo.Foo = Foo\n  \n  \n  mock = create_autospec(Foo)\n  instance = mock()\n  self.assertRaises(AttributeError, getattr, instance, 'b')\n  \n  attr_instance = mock.Foo()\n  self.assertRaises(AttributeError, getattr, attr_instance, 'b')\n  \n  \n  mock = create_autospec(Foo())\n  self.assertRaises(AttributeError, getattr, mock, 'b')\n  self.assertRaises(TypeError, mock)\n  \n  \n  call_result = mock.Foo()\n  self.assertRaises(AttributeError, getattr, call_result, 'b')\n  \n  \n def test_builtins(self):\n \n  create_autospec(1)\n  \n  create_autospec(int)\n  create_autospec('foo')\n  create_autospec(str)\n  create_autospec({})\n  create_autospec(dict)\n  create_autospec([])\n  create_autospec(list)\n  create_autospec(set())\n  create_autospec(set)\n  create_autospec(1.0)\n  create_autospec(float)\n  create_autospec(1j)\n  create_autospec(complex)\n  create_autospec(False)\n  create_autospec(True)\n  \n  \n def test_function(self):\n  def f(a, b):\n   pass\n   \n  mock = create_autospec(f)\n  self.assertRaises(TypeError, mock)\n  mock(1, 2)\n  mock.assert_called_with(1, 2)\n  \n  f.f = f\n  mock = create_autospec(f)\n  self.assertRaises(TypeError, mock.f)\n  mock.f(3, 4)\n  mock.f.assert_called_with(3, 4)\n  \n  \n def test_skip_attributeerrors(self):\n  class Raiser(object):\n   def __get__(self, obj, type=None):\n    if obj is None:\n     raise AttributeError('Can only be accessed via an instance')\n     \n  class RaiserClass(object):\n   raiser = Raiser()\n   \n   @staticmethod\n   def existing(a, b):\n    return a + b\n    \n  s = create_autospec(RaiserClass)\n  self.assertRaises(TypeError, lambda x: s.existing(1, 2, 3))\n  s.existing(1, 2)\n  self.assertRaises(AttributeError, lambda: s.nonexisting)\n  \n  \n  obj = s.raiser\n  obj.foo, obj.bar\n  \n  \n def test_signature_class(self):\n  class Foo(object):\n   def __init__(self, a, b=3):\n    pass\n    \n  mock = create_autospec(Foo)\n  \n  self.assertRaises(TypeError, mock)\n  mock(1)\n  mock.assert_called_once_with(1)\n  \n  mock(4, 5)\n  mock.assert_called_with(4, 5)\n  \n  \n def test_class_with_no_init(self):\n \n \n  class Foo(object):\n   pass\n  create_autospec(Foo)\n  \n  \n def test_signature_callable(self):\n  class Callable(object):\n   def __init__(self):\n    pass\n   def __call__(self, a):\n    pass\n    \n  mock = create_autospec(Callable)\n  mock()\n  mock.assert_called_once_with()\n  self.assertRaises(TypeError, mock, 'a')\n  \n  instance = mock()\n  self.assertRaises(TypeError, instance)\n  instance(a='a')\n  instance.assert_called_once_with(a='a')\n  instance('a')\n  instance.assert_called_with('a')\n  \n  mock = create_autospec(Callable())\n  mock(a='a')\n  mock.assert_called_once_with(a='a')\n  self.assertRaises(TypeError, mock)\n  mock('a')\n  mock.assert_called_with('a')\n  \n  \n def test_signature_noncallable(self):\n  class NonCallable(object):\n   def __init__(self):\n    pass\n    \n  mock = create_autospec(NonCallable)\n  instance = mock()\n  mock.assert_called_once_with()\n  self.assertRaises(TypeError, mock, 'a')\n  self.assertRaises(TypeError, instance)\n  self.assertRaises(TypeError, instance, 'a')\n  \n  mock = create_autospec(NonCallable())\n  self.assertRaises(TypeError, mock)\n  self.assertRaises(TypeError, mock, 'a')\n  \n  \n def test_create_autospec_none(self):\n  class Foo(object):\n   bar = None\n   \n  mock = create_autospec(Foo)\n  none = mock.bar\n  self.assertNotIsInstance(none, type(None))\n  \n  none.foo()\n  none.foo.assert_called_once_with()\n  \n  \n def test_autospec_functions_with_self_in_odd_place(self):\n  class Foo(object):\n   def f(a, self):\n    pass\n    \n  a = create_autospec(Foo)\n  a.f(self=10)\n  a.f.assert_called_with(self=10)\n  \n  \n def test_autospec_property(self):\n  class Foo(object):\n   @property\n   def foo(self):\n    return 3\n    \n  foo = create_autospec(Foo)\n  mock_property = foo.foo\n  \n  \n  self.assertTrue(isinstance(mock_property, MagicMock))\n  mock_property(1, 2, 3)\n  mock_property.abc(4, 5, 6)\n  mock_property.assert_called_once_with(1, 2, 3)\n  mock_property.abc.assert_called_once_with(4, 5, 6)\n  \n  \n def test_autospec_slots(self):\n  class Foo(object):\n   __slots__ = ['a']\n   \n  foo = create_autospec(Foo)\n  mock_slot = foo.a\n  \n  \n  mock_slot(1, 2, 3)\n  mock_slot.abc(4, 5, 6)\n  mock_slot.assert_called_once_with(1, 2, 3)\n  mock_slot.abc.assert_called_once_with(4, 5, 6)\n  \n  \nclass TestCallList(unittest.TestCase):\n\n def test_args_list_contains_call_list(self):\n  mock = Mock()\n  self.assertIsInstance(mock.call_args_list, _CallList)\n  \n  mock(1, 2)\n  mock(a=3)\n  mock(3, 4)\n  mock(b=6)\n  \n  for kall in call(1, 2), call(a=3), call(3, 4), call(b=6):\n   self.assertTrue(kall in mock.call_args_list)\n   \n  calls = [call(a=3), call(3, 4)]\n  self.assertTrue(calls in mock.call_args_list)\n  calls = [call(1, 2), call(a=3)]\n  self.assertTrue(calls in mock.call_args_list)\n  calls = [call(3, 4), call(b=6)]\n  self.assertTrue(calls in mock.call_args_list)\n  calls = [call(3, 4)]\n  self.assertTrue(calls in mock.call_args_list)\n  \n  self.assertFalse(call('fish') in mock.call_args_list)\n  self.assertFalse([call('fish')] in mock.call_args_list)\n  \n  \n def test_call_list_str(self):\n  mock = Mock()\n  mock(1, 2)\n  mock.foo(a=3)\n  mock.foo.bar().baz('fish', cat='dog')\n  \n  expected = (\n  \"[call(1, 2),\\n\"\n  \" call.foo(a=3),\\n\"\n  \" call.foo.bar(),\\n\"\n  \" call.foo.bar().baz('fish', cat='dog')]\"\n  )\n  self.assertEqual(str(mock.mock_calls), expected)\n  \n  \n def test_propertymock(self):\n  p = patch('%s.SomeClass.one' % __name__, new_callable=PropertyMock)\n  mock = p.start()\n  try:\n   SomeClass.one\n   mock.assert_called_once_with()\n   \n   s = SomeClass()\n   s.one\n   mock.assert_called_with()\n   self.assertEqual(mock.mock_calls, [call(), call()])\n   \n   s.one = 3\n   self.assertEqual(mock.mock_calls, [call(), call(), call(3)])\n  finally:\n   p.stop()\n   \n   \n def test_propertymock_returnvalue(self):\n  m = MagicMock()\n  p = PropertyMock()\n  type(m).foo = p\n  \n  returned = m.foo\n  p.assert_called_once_with()\n  self.assertIsInstance(returned, MagicMock)\n  self.assertNotIsInstance(returned, PropertyMock)\n  \n  \nif __name__ == '__main__':\n unittest.main()\n"], "unittest.test.test_functiontestcase": ["import unittest\n\nfrom .support import LoggingResult\n\n\nclass Test_FunctionTestCase(unittest.TestCase):\n\n\n\n def test_countTestCases(self):\n  test = unittest.FunctionTestCase(lambda: None)\n  \n  self.assertEqual(test.countTestCases(), 1)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__error_in_setUp(self):\n  events = []\n  result = LoggingResult(events)\n  \n  def setUp():\n   events.append('setUp')\n   raise RuntimeError('raised by setUp')\n   \n  def test():\n   events.append('test')\n   \n  def tearDown():\n   events.append('tearDown')\n   \n  expected = ['startTest', 'setUp', 'addError', 'stopTest']\n  unittest.FunctionTestCase(test, setUp, tearDown).run(result)\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__error_in_test(self):\n  events = []\n  result = LoggingResult(events)\n  \n  def setUp():\n   events.append('setUp')\n   \n  def test():\n   events.append('test')\n   raise RuntimeError('raised by test')\n   \n  def tearDown():\n   events.append('tearDown')\n   \n  expected = ['startTest', 'setUp', 'test', 'tearDown',\n  'addError', 'stopTest']\n  unittest.FunctionTestCase(test, setUp, tearDown).run(result)\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__failure_in_test(self):\n  events = []\n  result = LoggingResult(events)\n  \n  def setUp():\n   events.append('setUp')\n   \n  def test():\n   events.append('test')\n   self.fail('raised by test')\n   \n  def tearDown():\n   events.append('tearDown')\n   \n  expected = ['startTest', 'setUp', 'test', 'tearDown',\n  'addFailure', 'stopTest']\n  unittest.FunctionTestCase(test, setUp, tearDown).run(result)\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n  \n def test_run_call_order__error_in_tearDown(self):\n  events = []\n  result = LoggingResult(events)\n  \n  def setUp():\n   events.append('setUp')\n   \n  def test():\n   events.append('test')\n   \n  def tearDown():\n   events.append('tearDown')\n   raise RuntimeError('raised by tearDown')\n   \n  expected = ['startTest', 'setUp', 'test', 'tearDown', 'addError',\n  'stopTest']\n  unittest.FunctionTestCase(test, setUp, tearDown).run(result)\n  self.assertEqual(events, expected)\n  \n  \n  \n  \n  \n  \n  \n def test_id(self):\n  test = unittest.FunctionTestCase(lambda: None)\n  \n  self.assertIsInstance(test.id(), str)\n  \n  \n  \n  \n def test_shortDescription__no_docstring(self):\n  test = unittest.FunctionTestCase(lambda: None)\n  \n  self.assertEqual(test.shortDescription(), None)\n  \n  \n  \n  \n def test_shortDescription__singleline_docstring(self):\n  desc = \"this tests foo\"\n  test = unittest.FunctionTestCase(lambda: None, description=desc)\n  \n  self.assertEqual(test.shortDescription(), \"this tests foo\")\n"], "test.re_tests": ["\n\n\n\n\n\n[SUCCEED, FAIL, SYNTAX_ERROR] = range(3)\n\n\n\n\n\n\n\n\n\nbenchmarks = [\n\n\n('Python|Perl', 'Perl'), \n('(Python|Perl)', 'Perl'), \n\n('Python|Perl|Tcl', 'Perl'), \n('(Python|Perl|Tcl)', 'Perl'), \n\n('(Python)\\\\1', 'PythonPython'), \n('([0a-z][a-z0-9]*,)+', 'a5,b7,c9,'), \n('([a-z][a-z0-9]*,)+', 'a5,b7,c9,'), \n\n('Python', 'Python'), \n('.*Python', 'Python'), \n('.*Python.*', 'Python'), \n('.*(Python)', 'Python'), \n\n]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntests = [\n\n('(?P<foo_123', '', SYNTAX_ERROR), \n('(?P<1>a)', '', SYNTAX_ERROR), \n('(?P<!>a)', '', SYNTAX_ERROR), \n('(?P<foo!>a)', '', SYNTAX_ERROR), \n\n\n('(?P<foo_123>a)(?P=foo_123', 'aa', SYNTAX_ERROR),\n('(?P<foo_123>a)(?P=1)', 'aa', SYNTAX_ERROR),\n('(?P<foo_123>a)(?P=!)', 'aa', SYNTAX_ERROR),\n('(?P<foo_123>a)(?P=foo_124', 'aa', SYNTAX_ERROR), \n\n('(?P<foo_123>a)', 'a', SUCCEED, 'g1', 'a'),\n('(?P<foo_123>a)(?P=foo_123)', 'aa', SUCCEED, 'g1', 'a'),\n\n\n('\\\\1', 'a', SYNTAX_ERROR), \n('[\\\\1]', '\\1', SUCCEED, 'found', '\\1'), \n('\\\\09', chr(0) + '9', SUCCEED, 'found', chr(0) + '9'),\n('\\\\141', 'a', SUCCEED, 'found', 'a'),\n('(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)\\\\119', 'abcdefghijklk9', SUCCEED, 'found+\"-\"+g11', 'abcdefghijklk9-k'),\n\n\n(r'\\0', '\\0', SUCCEED, 'found', '\\0'),\n(r'[\\0a]', '\\0', SUCCEED, 'found', '\\0'),\n(r'[a\\0]', '\\0', SUCCEED, 'found', '\\0'),\n(r'[^a\\0]', '\\0', FAIL),\n\n\n(r'\\a[\\b]\\f\\n\\r\\t\\v', '\\a\\b\\f\\n\\r\\t\\v', SUCCEED, 'found', '\\a\\b\\f\\n\\r\\t\\v'),\n(r'[\\a][\\b][\\f][\\n][\\r][\\t][\\v]', '\\a\\b\\f\\n\\r\\t\\v', SUCCEED, 'found', '\\a\\b\\f\\n\\r\\t\\v'),\n\n\n(r'\\c\\e\\g\\h\\i\\j\\k\\m\\o\\p\\q\\y\\z', 'ceghijkmopqyz', SUCCEED, 'found', 'ceghijkmopqyz'),\n(r'\\xff', '\\377', SUCCEED, 'found', chr(255)),\n\n(r'\\x00ffffffffffffff', '\\377', FAIL, 'found', chr(255)),\n(r'\\x00f', '\\017', FAIL, 'found', chr(15)),\n(r'\\x00fe', '\\376', FAIL, 'found', chr(254)),\n\n\n\n\n(r\"^\\w+=(\\\\[\\000-\\277]|[^\\n\\\\])*\", \"SRC=eval.c g.c blah blah blah \\\\\\\\\\n\\tapes.c\",\nSUCCEED, 'found', \"SRC=eval.c g.c blah blah blah \\\\\\\\\"),\n\n\n('a.b', 'acb', SUCCEED, 'found', 'acb'),\n('a.b', 'a\\nb', FAIL),\n('a.*b', 'acc\\nccb', FAIL),\n('a.{4,5}b', 'acc\\nccb', FAIL),\n('a.b', 'a\\rb', SUCCEED, 'found', 'a\\rb'),\n('a.b(?s)', 'a\\nb', SUCCEED, 'found', 'a\\nb'),\n('a.*(?s)b', 'acc\\nccb', SUCCEED, 'found', 'acc\\nccb'),\n('(?s)a.{4,5}b', 'acc\\nccb', SUCCEED, 'found', 'acc\\nccb'),\n('(?s)a.b', 'a\\nb', SUCCEED, 'found', 'a\\nb'),\n\n(')', '', SYNTAX_ERROR), \n('', '', SUCCEED, 'found', ''), \n('abc', 'abc', SUCCEED, 'found', 'abc'),\n('abc', 'xbc', FAIL),\n('abc', 'axc', FAIL),\n('abc', 'abx', FAIL),\n('abc', 'xabcy', SUCCEED, 'found', 'abc'),\n('abc', 'ababc', SUCCEED, 'found', 'abc'),\n('ab*c', 'abc', SUCCEED, 'found', 'abc'),\n('ab*bc', 'abc', SUCCEED, 'found', 'abc'),\n('ab*bc', 'abbc', SUCCEED, 'found', 'abbc'),\n('ab*bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab+bc', 'abbc', SUCCEED, 'found', 'abbc'),\n('ab+bc', 'abc', FAIL),\n('ab+bc', 'abq', FAIL),\n('ab+bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab?bc', 'abbc', SUCCEED, 'found', 'abbc'),\n('ab?bc', 'abc', SUCCEED, 'found', 'abc'),\n('ab?bc', 'abbbbc', FAIL),\n('ab?c', 'abc', SUCCEED, 'found', 'abc'),\n('^abc$', 'abc', SUCCEED, 'found', 'abc'),\n('^abc$', 'abcc', FAIL),\n('^abc', 'abcc', SUCCEED, 'found', 'abc'),\n('^abc$', 'aabc', FAIL),\n('abc$', 'aabc', SUCCEED, 'found', 'abc'),\n('^', 'abc', SUCCEED, 'found+\"-\"', '-'),\n('$', 'abc', SUCCEED, 'found+\"-\"', '-'),\n('a.c', 'abc', SUCCEED, 'found', 'abc'),\n('a.c', 'axc', SUCCEED, 'found', 'axc'),\n('a.*c', 'axyzc', SUCCEED, 'found', 'axyzc'),\n('a.*c', 'axyzd', FAIL),\n('a[bc]d', 'abc', FAIL),\n('a[bc]d', 'abd', SUCCEED, 'found', 'abd'),\n('a[b-d]e', 'abd', FAIL),\n('a[b-d]e', 'ace', SUCCEED, 'found', 'ace'),\n('a[b-d]', 'aac', SUCCEED, 'found', 'ac'),\n('a[-b]', 'a-', SUCCEED, 'found', 'a-'),\n('a[\\\\-b]', 'a-', SUCCEED, 'found', 'a-'),\n\n\n('a[]b', '-', SYNTAX_ERROR),\n('a[', '-', SYNTAX_ERROR),\n('a\\\\', '-', SYNTAX_ERROR),\n('abc)', '-', SYNTAX_ERROR),\n('(abc', '-', SYNTAX_ERROR),\n('a]', 'a]', SUCCEED, 'found', 'a]'),\n('a[]]b', 'a]b', SUCCEED, 'found', 'a]b'),\n('a[\\]]b', 'a]b', SUCCEED, 'found', 'a]b'),\n('a[^bc]d', 'aed', SUCCEED, 'found', 'aed'),\n('a[^bc]d', 'abd', FAIL),\n('a[^-b]c', 'adc', SUCCEED, 'found', 'adc'),\n('a[^-b]c', 'a-c', FAIL),\n('a[^]b]c', 'a]c', FAIL),\n('a[^]b]c', 'adc', SUCCEED, 'found', 'adc'),\n('\\\\ba\\\\b', 'a-', SUCCEED, '\"-\"', '-'),\n('\\\\ba\\\\b', '-a', SUCCEED, '\"-\"', '-'),\n('\\\\ba\\\\b', '-a-', SUCCEED, '\"-\"', '-'),\n('\\\\by\\\\b', 'xy', FAIL),\n('\\\\by\\\\b', 'yz', FAIL),\n('\\\\by\\\\b', 'xyz', FAIL),\n('x\\\\b', 'xyz', FAIL),\n('x\\\\B', 'xyz', SUCCEED, '\"-\"', '-'),\n('\\\\Bz', 'xyz', SUCCEED, '\"-\"', '-'),\n('z\\\\B', 'xyz', FAIL),\n('\\\\Bx', 'xyz', FAIL),\n('\\\\Ba\\\\B', 'a-', FAIL, '\"-\"', '-'),\n('\\\\Ba\\\\B', '-a', FAIL, '\"-\"', '-'),\n('\\\\Ba\\\\B', '-a-', FAIL, '\"-\"', '-'),\n('\\\\By\\\\B', 'xy', FAIL),\n('\\\\By\\\\B', 'yz', FAIL),\n('\\\\By\\\\b', 'xy', SUCCEED, '\"-\"', '-'),\n('\\\\by\\\\B', 'yz', SUCCEED, '\"-\"', '-'),\n('\\\\By\\\\B', 'xyz', SUCCEED, '\"-\"', '-'),\n('ab|cd', 'abc', SUCCEED, 'found', 'ab'),\n('ab|cd', 'abcd', SUCCEED, 'found', 'ab'),\n('()ef', 'def', SUCCEED, 'found+\"-\"+g1', 'ef-'),\n('$b', 'b', FAIL),\n('a\\\\(b', 'a(b', SUCCEED, 'found+\"-\"+g1', 'a(b-Error'),\n('a\\\\(*b', 'ab', SUCCEED, 'found', 'ab'),\n('a\\\\(*b', 'a((b', SUCCEED, 'found', 'a((b'),\n('a\\\\\\\\b', 'a\\\\b', SUCCEED, 'found', 'a\\\\b'),\n('((a))', 'abc', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'a-a-a'),\n('(a)b(c)', 'abc', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abc-a-c'),\n('a+b+c', 'aabbabc', SUCCEED, 'found', 'abc'),\n('(a+|b)*', 'ab', SUCCEED, 'found+\"-\"+g1', 'ab-b'),\n('(a+|b)+', 'ab', SUCCEED, 'found+\"-\"+g1', 'ab-b'),\n('(a+|b)?', 'ab', SUCCEED, 'found+\"-\"+g1', 'a-a'),\n(')(', '-', SYNTAX_ERROR),\n('[^ab]*', 'cde', SUCCEED, 'found', 'cde'),\n('abc', '', FAIL),\n('a*', '', SUCCEED, 'found', ''),\n('a|b|c|d|e', 'e', SUCCEED, 'found', 'e'),\n('(a|b|c|d|e)f', 'ef', SUCCEED, 'found+\"-\"+g1', 'ef-e'),\n('abcd*efg', 'abcdefg', SUCCEED, 'found', 'abcdefg'),\n('ab*', 'xabyabbbz', SUCCEED, 'found', 'ab'),\n('ab*', 'xayabbbz', SUCCEED, 'found', 'a'),\n('(ab|cd)e', 'abcde', SUCCEED, 'found+\"-\"+g1', 'cde-cd'),\n('[abhgefdc]ij', 'hij', SUCCEED, 'found', 'hij'),\n('^(ab|cd)e', 'abcde', FAIL, 'xg1y', 'xy'),\n('(abc|)ef', 'abcdef', SUCCEED, 'found+\"-\"+g1', 'ef-'),\n('(a|b)c*d', 'abcd', SUCCEED, 'found+\"-\"+g1', 'bcd-b'),\n('(ab|ab*)bc', 'abc', SUCCEED, 'found+\"-\"+g1', 'abc-a'),\n('a([bc]*)c*', 'abc', SUCCEED, 'found+\"-\"+g1', 'abc-bc'),\n('a([bc]*)(c*d)', 'abcd', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcd-bc-d'),\n('a([bc]+)(c*d)', 'abcd', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcd-bc-d'),\n('a([bc]*)(c+d)', 'abcd', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcd-b-cd'),\n('a[bcd]*dcdcde', 'adcdcde', SUCCEED, 'found', 'adcdcde'),\n('a[bcd]+dcdcde', 'adcdcde', FAIL),\n('(ab|a)b*c', 'abc', SUCCEED, 'found+\"-\"+g1', 'abc-ab'),\n('((a)(b)c)(d)', 'abcd', SUCCEED, 'g1+\"-\"+g2+\"-\"+g3+\"-\"+g4', 'abc-a-b-d'),\n('[a-zA-Z_][a-zA-Z0-9_]*', 'alpha', SUCCEED, 'found', 'alpha'),\n('^a(bc+|b[eh])g|.h$', 'abh', SUCCEED, 'found+\"-\"+g1', 'bh-None'),\n('(bc+d$|ef*g.|h?i(j|k))', 'effgz', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'effgz-effgz-None'),\n('(bc+d$|ef*g.|h?i(j|k))', 'ij', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ij-ij-j'),\n('(bc+d$|ef*g.|h?i(j|k))', 'effg', FAIL),\n('(bc+d$|ef*g.|h?i(j|k))', 'bcdd', FAIL),\n('(bc+d$|ef*g.|h?i(j|k))', 'reffgz', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'effgz-effgz-None'),\n('(((((((((a)))))))))', 'a', SUCCEED, 'found', 'a'),\n('multiple words of text', 'uh-uh', FAIL),\n('multiple words', 'multiple words, yeah', SUCCEED, 'found', 'multiple words'),\n('(.*)c(.*)', 'abcde', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcde-ab-de'),\n('\\\\((.*), (.*)\\\\)', '(a, b)', SUCCEED, 'g2+\"-\"+g1', 'b-a'),\n('[k]', 'ab', FAIL),\n('a[-]?c', 'ac', SUCCEED, 'found', 'ac'),\n('(abc)\\\\1', 'abcabc', SUCCEED, 'g1', 'abc'),\n('([a-c]*)\\\\1', 'abcabc', SUCCEED, 'g1', 'abc'),\n('^(.+)?B', 'AB', SUCCEED, 'g1', 'A'),\n('(a+).\\\\1$', 'aaaaa', SUCCEED, 'found+\"-\"+g1', 'aaaaa-aa'),\n('^(a+).\\\\1$', 'aaaa', FAIL),\n('(abc)\\\\1', 'abcabc', SUCCEED, 'found+\"-\"+g1', 'abcabc-abc'),\n('([a-c]+)\\\\1', 'abcabc', SUCCEED, 'found+\"-\"+g1', 'abcabc-abc'),\n('(a)\\\\1', 'aa', SUCCEED, 'found+\"-\"+g1', 'aa-a'),\n('(a+)\\\\1', 'aa', SUCCEED, 'found+\"-\"+g1', 'aa-a'),\n('(a+)+\\\\1', 'aa', SUCCEED, 'found+\"-\"+g1', 'aa-a'),\n('(a).+\\\\1', 'aba', SUCCEED, 'found+\"-\"+g1', 'aba-a'),\n('(a)ba*\\\\1', 'aba', SUCCEED, 'found+\"-\"+g1', 'aba-a'),\n('(aa|a)a\\\\1$', 'aaa', SUCCEED, 'found+\"-\"+g1', 'aaa-a'),\n('(a|aa)a\\\\1$', 'aaa', SUCCEED, 'found+\"-\"+g1', 'aaa-a'),\n('(a+)a\\\\1$', 'aaa', SUCCEED, 'found+\"-\"+g1', 'aaa-a'),\n('([abc]*)\\\\1', 'abcabc', SUCCEED, 'found+\"-\"+g1', 'abcabc-abc'),\n('(a)(b)c|ab', 'ab', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ab-None-None'),\n('(a)+x', 'aaax', SUCCEED, 'found+\"-\"+g1', 'aaax-a'),\n('([ac])+x', 'aacx', SUCCEED, 'found+\"-\"+g1', 'aacx-c'),\n('([^/]*/)*sub1/', 'd:msgs/tdir/sub1/trial/away.cpp', SUCCEED, 'found+\"-\"+g1', 'd:msgs/tdir/sub1/-tdir/'),\n('([^.]*)\\\\.([^:]*):[T ]+(.*)', 'track1.title:TBlah blah blah', SUCCEED, 'found+\"-\"+g1+\"-\"+g2+\"-\"+g3', 'track1.title:TBlah blah blah-track1-title-Blah blah blah'),\n('([^N]*N)+', 'abNNxyzN', SUCCEED, 'found+\"-\"+g1', 'abNNxyzN-xyzN'),\n('([^N]*N)+', 'abNNxyz', SUCCEED, 'found+\"-\"+g1', 'abNN-N'),\n('([abc]*)x', 'abcx', SUCCEED, 'found+\"-\"+g1', 'abcx-abc'),\n('([abc]*)x', 'abc', FAIL),\n('([xyz]*)x', 'abcx', SUCCEED, 'found+\"-\"+g1', 'x-'),\n('(a)+b|aac', 'aac', SUCCEED, 'found+\"-\"+g1', 'aac-None'),\n\n\n\n('(?P<i d>aaa)a', 'aaaa', SYNTAX_ERROR),\n('(?P<id>aaa)a', 'aaaa', SUCCEED, 'found+\"-\"+id', 'aaaa-aaa'),\n('(?P<id>aa)(?P=id)', 'aaaa', SUCCEED, 'found+\"-\"+id', 'aaaa-aa'),\n('(?P<id>aa)(?P=xd)', 'aaaa', SYNTAX_ERROR),\n\n\n\n('\\\\1', 'a', SYNTAX_ERROR),\n('\\\\09', chr(0) + '9', SUCCEED, 'found', chr(0) + '9'),\n('\\\\141', 'a', SUCCEED, 'found', 'a'),\n('(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)\\\\119', 'abcdefghijklk9', SUCCEED, 'found+\"-\"+g11', 'abcdefghijklk9-k'),\n\n\n\n('abc', 'abc', SUCCEED, 'found', 'abc'),\n('abc', 'xbc', FAIL),\n('abc', 'axc', FAIL),\n('abc', 'abx', FAIL),\n('abc', 'xabcy', SUCCEED, 'found', 'abc'),\n('abc', 'ababc', SUCCEED, 'found', 'abc'),\n('ab*c', 'abc', SUCCEED, 'found', 'abc'),\n('ab*bc', 'abc', SUCCEED, 'found', 'abc'),\n('ab*bc', 'abbc', SUCCEED, 'found', 'abbc'),\n('ab*bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab{0,}bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab+bc', 'abbc', SUCCEED, 'found', 'abbc'),\n('ab+bc', 'abc', FAIL),\n('ab+bc', 'abq', FAIL),\n('ab{1,}bc', 'abq', FAIL),\n('ab+bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab{1,}bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab{1,3}bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab{3,4}bc', 'abbbbc', SUCCEED, 'found', 'abbbbc'),\n('ab{4,5}bc', 'abbbbc', FAIL),\n('ab?bc', 'abbc', SUCCEED, 'found', 'abbc'),\n('ab?bc', 'abc', SUCCEED, 'found', 'abc'),\n('ab{0,1}bc', 'abc', SUCCEED, 'found', 'abc'),\n('ab?bc', 'abbbbc', FAIL),\n('ab?c', 'abc', SUCCEED, 'found', 'abc'),\n('ab{0,1}c', 'abc', SUCCEED, 'found', 'abc'),\n('^abc$', 'abc', SUCCEED, 'found', 'abc'),\n('^abc$', 'abcc', FAIL),\n('^abc', 'abcc', SUCCEED, 'found', 'abc'),\n('^abc$', 'aabc', FAIL),\n('abc$', 'aabc', SUCCEED, 'found', 'abc'),\n('^', 'abc', SUCCEED, 'found', ''),\n('$', 'abc', SUCCEED, 'found', ''),\n('a.c', 'abc', SUCCEED, 'found', 'abc'),\n('a.c', 'axc', SUCCEED, 'found', 'axc'),\n('a.*c', 'axyzc', SUCCEED, 'found', 'axyzc'),\n('a.*c', 'axyzd', FAIL),\n('a[bc]d', 'abc', FAIL),\n('a[bc]d', 'abd', SUCCEED, 'found', 'abd'),\n('a[b-d]e', 'abd', FAIL),\n('a[b-d]e', 'ace', SUCCEED, 'found', 'ace'),\n('a[b-d]', 'aac', SUCCEED, 'found', 'ac'),\n('a[-b]', 'a-', SUCCEED, 'found', 'a-'),\n('a[b-]', 'a-', SUCCEED, 'found', 'a-'),\n('a[b-a]', '-', SYNTAX_ERROR),\n('a[]b', '-', SYNTAX_ERROR),\n('a[', '-', SYNTAX_ERROR),\n('a]', 'a]', SUCCEED, 'found', 'a]'),\n('a[]]b', 'a]b', SUCCEED, 'found', 'a]b'),\n('a[^bc]d', 'aed', SUCCEED, 'found', 'aed'),\n('a[^bc]d', 'abd', FAIL),\n('a[^-b]c', 'adc', SUCCEED, 'found', 'adc'),\n('a[^-b]c', 'a-c', FAIL),\n('a[^]b]c', 'a]c', FAIL),\n('a[^]b]c', 'adc', SUCCEED, 'found', 'adc'),\n('ab|cd', 'abc', SUCCEED, 'found', 'ab'),\n('ab|cd', 'abcd', SUCCEED, 'found', 'ab'),\n('()ef', 'def', SUCCEED, 'found+\"-\"+g1', 'ef-'),\n('*a', '-', SYNTAX_ERROR),\n('(*)b', '-', SYNTAX_ERROR),\n('$b', 'b', FAIL),\n('a\\\\', '-', SYNTAX_ERROR),\n('a\\\\(b', 'a(b', SUCCEED, 'found+\"-\"+g1', 'a(b-Error'),\n('a\\\\(*b', 'ab', SUCCEED, 'found', 'ab'),\n('a\\\\(*b', 'a((b', SUCCEED, 'found', 'a((b'),\n('a\\\\\\\\b', 'a\\\\b', SUCCEED, 'found', 'a\\\\b'),\n('abc)', '-', SYNTAX_ERROR),\n('(abc', '-', SYNTAX_ERROR),\n('((a))', 'abc', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'a-a-a'),\n('(a)b(c)', 'abc', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abc-a-c'),\n('a+b+c', 'aabbabc', SUCCEED, 'found', 'abc'),\n('a{1,}b{1,}c', 'aabbabc', SUCCEED, 'found', 'abc'),\n('a**', '-', SYNTAX_ERROR),\n('a.+?c', 'abcabc', SUCCEED, 'found', 'abc'),\n('(a+|b)*', 'ab', SUCCEED, 'found+\"-\"+g1', 'ab-b'),\n('(a+|b){0,}', 'ab', SUCCEED, 'found+\"-\"+g1', 'ab-b'),\n('(a+|b)+', 'ab', SUCCEED, 'found+\"-\"+g1', 'ab-b'),\n('(a+|b){1,}', 'ab', SUCCEED, 'found+\"-\"+g1', 'ab-b'),\n('(a+|b)?', 'ab', SUCCEED, 'found+\"-\"+g1', 'a-a'),\n('(a+|b){0,1}', 'ab', SUCCEED, 'found+\"-\"+g1', 'a-a'),\n(')(', '-', SYNTAX_ERROR),\n('[^ab]*', 'cde', SUCCEED, 'found', 'cde'),\n('abc', '', FAIL),\n('a*', '', SUCCEED, 'found', ''),\n('([abc])*d', 'abbbcd', SUCCEED, 'found+\"-\"+g1', 'abbbcd-c'),\n('([abc])*bcd', 'abcd', SUCCEED, 'found+\"-\"+g1', 'abcd-a'),\n('a|b|c|d|e', 'e', SUCCEED, 'found', 'e'),\n('(a|b|c|d|e)f', 'ef', SUCCEED, 'found+\"-\"+g1', 'ef-e'),\n('abcd*efg', 'abcdefg', SUCCEED, 'found', 'abcdefg'),\n('ab*', 'xabyabbbz', SUCCEED, 'found', 'ab'),\n('ab*', 'xayabbbz', SUCCEED, 'found', 'a'),\n('(ab|cd)e', 'abcde', SUCCEED, 'found+\"-\"+g1', 'cde-cd'),\n('[abhgefdc]ij', 'hij', SUCCEED, 'found', 'hij'),\n('^(ab|cd)e', 'abcde', FAIL),\n('(abc|)ef', 'abcdef', SUCCEED, 'found+\"-\"+g1', 'ef-'),\n('(a|b)c*d', 'abcd', SUCCEED, 'found+\"-\"+g1', 'bcd-b'),\n('(ab|ab*)bc', 'abc', SUCCEED, 'found+\"-\"+g1', 'abc-a'),\n('a([bc]*)c*', 'abc', SUCCEED, 'found+\"-\"+g1', 'abc-bc'),\n('a([bc]*)(c*d)', 'abcd', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcd-bc-d'),\n('a([bc]+)(c*d)', 'abcd', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcd-bc-d'),\n('a([bc]*)(c+d)', 'abcd', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcd-b-cd'),\n('a[bcd]*dcdcde', 'adcdcde', SUCCEED, 'found', 'adcdcde'),\n('a[bcd]+dcdcde', 'adcdcde', FAIL),\n('(ab|a)b*c', 'abc', SUCCEED, 'found+\"-\"+g1', 'abc-ab'),\n('((a)(b)c)(d)', 'abcd', SUCCEED, 'g1+\"-\"+g2+\"-\"+g3+\"-\"+g4', 'abc-a-b-d'),\n('[a-zA-Z_][a-zA-Z0-9_]*', 'alpha', SUCCEED, 'found', 'alpha'),\n('^a(bc+|b[eh])g|.h$', 'abh', SUCCEED, 'found+\"-\"+g1', 'bh-None'),\n('(bc+d$|ef*g.|h?i(j|k))', 'effgz', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'effgz-effgz-None'),\n('(bc+d$|ef*g.|h?i(j|k))', 'ij', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ij-ij-j'),\n('(bc+d$|ef*g.|h?i(j|k))', 'effg', FAIL),\n('(bc+d$|ef*g.|h?i(j|k))', 'bcdd', FAIL),\n('(bc+d$|ef*g.|h?i(j|k))', 'reffgz', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'effgz-effgz-None'),\n('((((((((((a))))))))))', 'a', SUCCEED, 'g10', 'a'),\n('((((((((((a))))))))))\\\\10', 'aa', SUCCEED, 'found', 'aa'),\n\n\n\n('((((((((((a))))))))))\\\\41', '', SYNTAX_ERROR),\n('(?i)((((((((((a))))))))))\\\\41', '', SYNTAX_ERROR),\n('(((((((((a)))))))))', 'a', SUCCEED, 'found', 'a'),\n('multiple words of text', 'uh-uh', FAIL),\n('multiple words', 'multiple words, yeah', SUCCEED, 'found', 'multiple words'),\n('(.*)c(.*)', 'abcde', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'abcde-ab-de'),\n('\\\\((.*), (.*)\\\\)', '(a, b)', SUCCEED, 'g2+\"-\"+g1', 'b-a'),\n('[k]', 'ab', FAIL),\n('a[-]?c', 'ac', SUCCEED, 'found', 'ac'),\n('(abc)\\\\1', 'abcabc', SUCCEED, 'g1', 'abc'),\n('([a-c]*)\\\\1', 'abcabc', SUCCEED, 'g1', 'abc'),\n('(?i)abc', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)abc', 'XBC', FAIL),\n('(?i)abc', 'AXC', FAIL),\n('(?i)abc', 'ABX', FAIL),\n('(?i)abc', 'XABCY', SUCCEED, 'found', 'ABC'),\n('(?i)abc', 'ABABC', SUCCEED, 'found', 'ABC'),\n('(?i)ab*c', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)ab*bc', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)ab*bc', 'ABBC', SUCCEED, 'found', 'ABBC'),\n('(?i)ab*?bc', 'ABBBBC', SUCCEED, 'found', 'ABBBBC'),\n('(?i)ab{0,}?bc', 'ABBBBC', SUCCEED, 'found', 'ABBBBC'),\n('(?i)ab+?bc', 'ABBC', SUCCEED, 'found', 'ABBC'),\n('(?i)ab+bc', 'ABC', FAIL),\n('(?i)ab+bc', 'ABQ', FAIL),\n('(?i)ab{1,}bc', 'ABQ', FAIL),\n('(?i)ab+bc', 'ABBBBC', SUCCEED, 'found', 'ABBBBC'),\n('(?i)ab{1,}?bc', 'ABBBBC', SUCCEED, 'found', 'ABBBBC'),\n('(?i)ab{1,3}?bc', 'ABBBBC', SUCCEED, 'found', 'ABBBBC'),\n('(?i)ab{3,4}?bc', 'ABBBBC', SUCCEED, 'found', 'ABBBBC'),\n('(?i)ab{4,5}?bc', 'ABBBBC', FAIL),\n('(?i)ab??bc', 'ABBC', SUCCEED, 'found', 'ABBC'),\n('(?i)ab??bc', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)ab{0,1}?bc', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)ab??bc', 'ABBBBC', FAIL),\n('(?i)ab??c', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)ab{0,1}?c', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)^abc$', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)^abc$', 'ABCC', FAIL),\n('(?i)^abc', 'ABCC', SUCCEED, 'found', 'ABC'),\n('(?i)^abc$', 'AABC', FAIL),\n('(?i)abc$', 'AABC', SUCCEED, 'found', 'ABC'),\n('(?i)^', 'ABC', SUCCEED, 'found', ''),\n('(?i)$', 'ABC', SUCCEED, 'found', ''),\n('(?i)a.c', 'ABC', SUCCEED, 'found', 'ABC'),\n('(?i)a.c', 'AXC', SUCCEED, 'found', 'AXC'),\n('(?i)a.*?c', 'AXYZC', SUCCEED, 'found', 'AXYZC'),\n('(?i)a.*c', 'AXYZD', FAIL),\n('(?i)a[bc]d', 'ABC', FAIL),\n('(?i)a[bc]d', 'ABD', SUCCEED, 'found', 'ABD'),\n('(?i)a[b-d]e', 'ABD', FAIL),\n('(?i)a[b-d]e', 'ACE', SUCCEED, 'found', 'ACE'),\n('(?i)a[b-d]', 'AAC', SUCCEED, 'found', 'AC'),\n('(?i)a[-b]', 'A-', SUCCEED, 'found', 'A-'),\n('(?i)a[b-]', 'A-', SUCCEED, 'found', 'A-'),\n('(?i)a[b-a]', '-', SYNTAX_ERROR),\n('(?i)a[]b', '-', SYNTAX_ERROR),\n('(?i)a[', '-', SYNTAX_ERROR),\n('(?i)a]', 'A]', SUCCEED, 'found', 'A]'),\n('(?i)a[]]b', 'A]B', SUCCEED, 'found', 'A]B'),\n('(?i)a[^bc]d', 'AED', SUCCEED, 'found', 'AED'),\n('(?i)a[^bc]d', 'ABD', FAIL),\n('(?i)a[^-b]c', 'ADC', SUCCEED, 'found', 'ADC'),\n('(?i)a[^-b]c', 'A-C', FAIL),\n('(?i)a[^]b]c', 'A]C', FAIL),\n('(?i)a[^]b]c', 'ADC', SUCCEED, 'found', 'ADC'),\n('(?i)ab|cd', 'ABC', SUCCEED, 'found', 'AB'),\n('(?i)ab|cd', 'ABCD', SUCCEED, 'found', 'AB'),\n('(?i)()ef', 'DEF', SUCCEED, 'found+\"-\"+g1', 'EF-'),\n('(?i)*a', '-', SYNTAX_ERROR),\n('(?i)(*)b', '-', SYNTAX_ERROR),\n('(?i)$b', 'B', FAIL),\n('(?i)a\\\\', '-', SYNTAX_ERROR),\n('(?i)a\\\\(b', 'A(B', SUCCEED, 'found+\"-\"+g1', 'A(B-Error'),\n('(?i)a\\\\(*b', 'AB', SUCCEED, 'found', 'AB'),\n('(?i)a\\\\(*b', 'A((B', SUCCEED, 'found', 'A((B'),\n('(?i)a\\\\\\\\b', 'A\\\\B', SUCCEED, 'found', 'A\\\\B'),\n('(?i)abc)', '-', SYNTAX_ERROR),\n('(?i)(abc', '-', SYNTAX_ERROR),\n('(?i)((a))', 'ABC', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'A-A-A'),\n('(?i)(a)b(c)', 'ABC', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ABC-A-C'),\n('(?i)a+b+c', 'AABBABC', SUCCEED, 'found', 'ABC'),\n('(?i)a{1,}b{1,}c', 'AABBABC', SUCCEED, 'found', 'ABC'),\n('(?i)a**', '-', SYNTAX_ERROR),\n('(?i)a.+?c', 'ABCABC', SUCCEED, 'found', 'ABC'),\n('(?i)a.*?c', 'ABCABC', SUCCEED, 'found', 'ABC'),\n('(?i)a.{0,5}?c', 'ABCABC', SUCCEED, 'found', 'ABC'),\n('(?i)(a+|b)*', 'AB', SUCCEED, 'found+\"-\"+g1', 'AB-B'),\n('(?i)(a+|b){0,}', 'AB', SUCCEED, 'found+\"-\"+g1', 'AB-B'),\n('(?i)(a+|b)+', 'AB', SUCCEED, 'found+\"-\"+g1', 'AB-B'),\n('(?i)(a+|b){1,}', 'AB', SUCCEED, 'found+\"-\"+g1', 'AB-B'),\n('(?i)(a+|b)?', 'AB', SUCCEED, 'found+\"-\"+g1', 'A-A'),\n('(?i)(a+|b){0,1}', 'AB', SUCCEED, 'found+\"-\"+g1', 'A-A'),\n('(?i)(a+|b){0,1}?', 'AB', SUCCEED, 'found+\"-\"+g1', '-None'),\n('(?i))(', '-', SYNTAX_ERROR),\n('(?i)[^ab]*', 'CDE', SUCCEED, 'found', 'CDE'),\n('(?i)abc', '', FAIL),\n('(?i)a*', '', SUCCEED, 'found', ''),\n('(?i)([abc])*d', 'ABBBCD', SUCCEED, 'found+\"-\"+g1', 'ABBBCD-C'),\n('(?i)([abc])*bcd', 'ABCD', SUCCEED, 'found+\"-\"+g1', 'ABCD-A'),\n('(?i)a|b|c|d|e', 'E', SUCCEED, 'found', 'E'),\n('(?i)(a|b|c|d|e)f', 'EF', SUCCEED, 'found+\"-\"+g1', 'EF-E'),\n('(?i)abcd*efg', 'ABCDEFG', SUCCEED, 'found', 'ABCDEFG'),\n('(?i)ab*', 'XABYABBBZ', SUCCEED, 'found', 'AB'),\n('(?i)ab*', 'XAYABBBZ', SUCCEED, 'found', 'A'),\n('(?i)(ab|cd)e', 'ABCDE', SUCCEED, 'found+\"-\"+g1', 'CDE-CD'),\n('(?i)[abhgefdc]ij', 'HIJ', SUCCEED, 'found', 'HIJ'),\n('(?i)^(ab|cd)e', 'ABCDE', FAIL),\n('(?i)(abc|)ef', 'ABCDEF', SUCCEED, 'found+\"-\"+g1', 'EF-'),\n('(?i)(a|b)c*d', 'ABCD', SUCCEED, 'found+\"-\"+g1', 'BCD-B'),\n('(?i)(ab|ab*)bc', 'ABC', SUCCEED, 'found+\"-\"+g1', 'ABC-A'),\n('(?i)a([bc]*)c*', 'ABC', SUCCEED, 'found+\"-\"+g1', 'ABC-BC'),\n('(?i)a([bc]*)(c*d)', 'ABCD', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ABCD-BC-D'),\n('(?i)a([bc]+)(c*d)', 'ABCD', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ABCD-BC-D'),\n('(?i)a([bc]*)(c+d)', 'ABCD', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ABCD-B-CD'),\n('(?i)a[bcd]*dcdcde', 'ADCDCDE', SUCCEED, 'found', 'ADCDCDE'),\n('(?i)a[bcd]+dcdcde', 'ADCDCDE', FAIL),\n('(?i)(ab|a)b*c', 'ABC', SUCCEED, 'found+\"-\"+g1', 'ABC-AB'),\n('(?i)((a)(b)c)(d)', 'ABCD', SUCCEED, 'g1+\"-\"+g2+\"-\"+g3+\"-\"+g4', 'ABC-A-B-D'),\n('(?i)[a-zA-Z_][a-zA-Z0-9_]*', 'ALPHA', SUCCEED, 'found', 'ALPHA'),\n('(?i)^a(bc+|b[eh])g|.h$', 'ABH', SUCCEED, 'found+\"-\"+g1', 'BH-None'),\n('(?i)(bc+d$|ef*g.|h?i(j|k))', 'EFFGZ', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'EFFGZ-EFFGZ-None'),\n('(?i)(bc+d$|ef*g.|h?i(j|k))', 'IJ', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'IJ-IJ-J'),\n('(?i)(bc+d$|ef*g.|h?i(j|k))', 'EFFG', FAIL),\n('(?i)(bc+d$|ef*g.|h?i(j|k))', 'BCDD', FAIL),\n('(?i)(bc+d$|ef*g.|h?i(j|k))', 'REFFGZ', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'EFFGZ-EFFGZ-None'),\n('(?i)((((((((((a))))))))))', 'A', SUCCEED, 'g10', 'A'),\n('(?i)((((((((((a))))))))))\\\\10', 'AA', SUCCEED, 'found', 'AA'),\n\n\n('(?i)(((((((((a)))))))))', 'A', SUCCEED, 'found', 'A'),\n('(?i)(?:(?:(?:(?:(?:(?:(?:(?:(?:(a))))))))))', 'A', SUCCEED, 'g1', 'A'),\n('(?i)(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))', 'C', SUCCEED, 'g1', 'C'),\n('(?i)multiple words of text', 'UH-UH', FAIL),\n('(?i)multiple words', 'MULTIPLE WORDS, YEAH', SUCCEED, 'found', 'MULTIPLE WORDS'),\n('(?i)(.*)c(.*)', 'ABCDE', SUCCEED, 'found+\"-\"+g1+\"-\"+g2', 'ABCDE-AB-DE'),\n('(?i)\\\\((.*), (.*)\\\\)', '(A, B)', SUCCEED, 'g2+\"-\"+g1', 'B-A'),\n('(?i)[k]', 'AB', FAIL),\n\n\n('(?i)a[-]?c', 'AC', SUCCEED, 'found', 'AC'),\n('(?i)(abc)\\\\1', 'ABCABC', SUCCEED, 'g1', 'ABC'),\n('(?i)([a-c]*)\\\\1', 'ABCABC', SUCCEED, 'g1', 'ABC'),\n('a(?!b).', 'abad', SUCCEED, 'found', 'ad'),\n('a(?=d).', 'abad', SUCCEED, 'found', 'ad'),\n('a(?=c|d).', 'abad', SUCCEED, 'found', 'ad'),\n('a(?:b|c|d)(.)', 'ace', SUCCEED, 'g1', 'e'),\n('a(?:b|c|d)*(.)', 'ace', SUCCEED, 'g1', 'e'),\n('a(?:b|c|d)+?(.)', 'ace', SUCCEED, 'g1', 'e'),\n('a(?:b|(c|e){1,2}?|d)+?(.)', 'ace', SUCCEED, 'g1 + g2', 'ce'),\n('^(.+)?B', 'AB', SUCCEED, 'g1', 'A'),\n\n\n('(?<!-):(.*?)(?<!-):', 'a:bc-:de:f', SUCCEED, 'g1', 'bc-:de' ),\n\n('(?<!\\\\\\):(.*?)(?<!\\\\\\):', 'a:bc\\\\:de:f', SUCCEED, 'g1', 'bc\\\\:de' ),\n\n(\"(?<!\\\\?)'(.*?)(?<!\\\\?)'\", \"a'bc?'de'f\", SUCCEED, 'g1', \"bc?'de\" ),\n\n\n\n('w(?# comment', 'w', SYNTAX_ERROR),\n('w(?# comment 1)xy(?# comment 2)z', 'wxyz', SUCCEED, 'found', 'wxyz'),\n\n\n\n\n('w(?i)', 'W', SUCCEED, 'found', 'W'),\n\n\n\n\n(\"\"\"(?x)w# comment 1\n        x y\n        # comment 2\n        z\"\"\", 'wxyz', SUCCEED, 'found', 'wxyz'),\n\n\n\n('^abc', \"\"\"jkl\nabc\nxyz\"\"\", FAIL),\n('(?m)^abc', \"\"\"jkl\nabc\nxyz\"\"\", SUCCEED, 'found', 'abc'),\n\n('(?m)abc$', \"\"\"jkl\nxyzabc\n123\"\"\", SUCCEED, 'found', 'abc'),\n\n\n\n('a.b', 'a\\nb', FAIL),\n('(?s)a.b', 'a\\nb', SUCCEED, 'found', 'a\\nb'),\n\n\n\n('\\\\w+', '--ab_cd0123--', SUCCEED, 'found', 'ab_cd0123'),\n('[\\\\w]+', '--ab_cd0123--', SUCCEED, 'found', 'ab_cd0123'),\n('\\\\D+', '1234abc5678', SUCCEED, 'found', 'abc'),\n('[\\\\D]+', '1234abc5678', SUCCEED, 'found', 'abc'),\n('[\\\\da-fA-F]+', '123abc', SUCCEED, 'found', '123abc'),\n\n\n(r'([\\s]*)([\\S]*)([\\s]*)', ' testing!1972', SUCCEED, 'g3+g2+g1', 'testing!1972 '),\n(r'(\\s*)(\\S*)(\\s*)', ' testing!1972', SUCCEED, 'g3+g2+g1', 'testing!1972 '),\n\n(r'\\xff', '\\377', SUCCEED, 'found', chr(255)),\n\n(r'\\x00ff', '\\377', FAIL),\n\n(r'\\t\\n\\v\\r\\f\\a\\g', '\\t\\n\\v\\r\\f\\ag', SUCCEED, 'found', '\\t\\n\\v\\r\\f\\ag'),\n('\\t\\n\\v\\r\\f\\a\\g', '\\t\\n\\v\\r\\f\\ag', SUCCEED, 'found', '\\t\\n\\v\\r\\f\\ag'),\n(r'\\t\\n\\v\\r\\f\\a', '\\t\\n\\v\\r\\f\\a', SUCCEED, 'found', chr(9)+chr(10)+chr(11)+chr(13)+chr(12)+chr(7)),\n(r'[\\t][\\n][\\v][\\r][\\f][\\b]', '\\t\\n\\v\\r\\f\\b', SUCCEED, 'found', '\\t\\n\\v\\r\\f\\b'),\n\n\n\n\n\n(r'(([a-z]+):)?([a-z]+)$', 'smil', SUCCEED, 'g1+\"-\"+g2+\"-\"+g3', 'None-None-smil'),\n\n(r'((.)\\1+)', '', SYNTAX_ERROR),\n\n(r'.*d', 'abc\\nabd', SUCCEED, 'found', 'abd'),\n\n(r'(', '', SYNTAX_ERROR),\n(r'[\\41]', '!', SUCCEED, 'found', '!'),\n\n(r'(x?)?', 'x', SUCCEED, 'found', 'x'),\n\n(r' (?x)foo ', 'foo', SUCCEED, 'found', 'foo'),\n\n(r'(?<!abc)(d.f)', 'abcdefdof', SUCCEED, 'found', 'dof'),\n\n(r'[\\w-]+', 'laser_beam', SUCCEED, 'found', 'laser_beam'),\n\n(r'.*?\\S *:', 'xx:', SUCCEED, 'found', 'xx:'),\n(r'a[ ]*?\\ (\\d+).*', 'a   10', SUCCEED, 'found', 'a   10'),\n(r'a[ ]*?\\ (\\d+).*', 'a    10', SUCCEED, 'found', 'a    10'),\n\n(r'(?ms).*?x\\s*\\Z(.*)','xx\\nx\\n', SUCCEED, 'g1', ''),\n\n(r'(?i)M+', 'MMM', SUCCEED, 'found', 'MMM'),\n(r'(?i)m+', 'MMM', SUCCEED, 'found', 'MMM'),\n(r'(?i)[M]+', 'MMM', SUCCEED, 'found', 'MMM'),\n(r'(?i)[m]+', 'MMM', SUCCEED, 'found', 'MMM'),\n\n(r'^*', '', SYNTAX_ERROR),\n\n(r'\"(?:\\\\\"|[^\"])*?\"', r'\"\\\"\"', SUCCEED, 'found', r'\"\\\"\"'),\n\n(r'^.*?$', 'one\\ntwo\\nthree\\n', FAIL),\n\n(r'a[^>]*?b', 'a>b', FAIL),\n\n(r'^a*?$', 'foo', FAIL),\n\n(r'^((a)c)?(ab)$', 'ab', SUCCEED, 'g1+\"-\"+g2+\"-\"+g3', 'None-None-ab'),\n\n('^([ab]*?)(?=(b)?)c', 'abc', SUCCEED, 'g1+\"-\"+g2', 'ab-None'),\n('^([ab]*?)(?!(b))c', 'abc', SUCCEED, 'g1+\"-\"+g2', 'ab-None'),\n('^([ab]*?)(?<!(a))c', 'abc', SUCCEED, 'g1+\"-\"+g2', 'ab-None'),\n]\n\nu = '\\N{LATIN CAPITAL LETTER A WITH DIAERESIS}'\ntests.extend([\n\n(r'\\b.\\b', 'a', SUCCEED, 'found', 'a'),\n(r'(?u)\\b.\\b', u, SUCCEED, 'found', u),\n(r'(?u)\\w', u, SUCCEED, 'found', u),\n])\n"], "unittest.test.testmock.testcallable": ["\n\n\n\nimport unittest\nfrom unittest.test.testmock.support import is_instance, X, SomeClass\n\nfrom unittest.mock import (\nMock, MagicMock, NonCallableMagicMock,\nNonCallableMock, patch, create_autospec,\nCallableMixin\n)\n\n\n\nclass TestCallable(unittest.TestCase):\n\n def assertNotCallable(self, mock):\n  self.assertTrue(is_instance(mock, NonCallableMagicMock))\n  self.assertFalse(is_instance(mock, CallableMixin))\n  \n  \n def test_non_callable(self):\n  for mock in NonCallableMagicMock(), NonCallableMock():\n   self.assertRaises(TypeError, mock)\n   self.assertFalse(hasattr(mock, '__call__'))\n   self.assertIn(mock.__class__.__name__, repr(mock))\n   \n   \n def test_heirarchy(self):\n  self.assertTrue(issubclass(MagicMock, Mock))\n  self.assertTrue(issubclass(NonCallableMagicMock, NonCallableMock))\n  \n  \n def test_attributes(self):\n  one = NonCallableMock()\n  self.assertTrue(issubclass(type(one.one), Mock))\n  \n  two = NonCallableMagicMock()\n  self.assertTrue(issubclass(type(two.two), MagicMock))\n  \n  \n def test_subclasses(self):\n  class MockSub(Mock):\n   pass\n   \n  one = MockSub()\n  self.assertTrue(issubclass(type(one.one), MockSub))\n  \n  class MagicSub(MagicMock):\n   pass\n   \n  two = MagicSub()\n  self.assertTrue(issubclass(type(two.two), MagicSub))\n  \n  \n def test_patch_spec(self):\n  patcher = patch('%s.X' % __name__, spec=True)\n  mock = patcher.start()\n  self.addCleanup(patcher.stop)\n  \n  instance = mock()\n  mock.assert_called_once_with()\n  \n  self.assertNotCallable(instance)\n  self.assertRaises(TypeError, instance)\n  \n  \n def test_patch_spec_set(self):\n  patcher = patch('%s.X' % __name__, spec_set=True)\n  mock = patcher.start()\n  self.addCleanup(patcher.stop)\n  \n  instance = mock()\n  mock.assert_called_once_with()\n  \n  self.assertNotCallable(instance)\n  self.assertRaises(TypeError, instance)\n  \n  \n def test_patch_spec_instance(self):\n  patcher = patch('%s.X' % __name__, spec=X())\n  mock = patcher.start()\n  self.addCleanup(patcher.stop)\n  \n  self.assertNotCallable(mock)\n  self.assertRaises(TypeError, mock)\n  \n  \n def test_patch_spec_set_instance(self):\n  patcher = patch('%s.X' % __name__, spec_set=X())\n  mock = patcher.start()\n  self.addCleanup(patcher.stop)\n  \n  self.assertNotCallable(mock)\n  self.assertRaises(TypeError, mock)\n  \n  \n def test_patch_spec_callable_class(self):\n  class CallableX(X):\n   def __call__(self):\n    pass\n    \n  class Sub(CallableX):\n   pass\n   \n  class Multi(SomeClass, Sub):\n   pass\n   \n  for arg in 'spec', 'spec_set':\n   for Klass in CallableX, Sub, Multi:\n    with patch('%s.X' % __name__, **{arg: Klass}) as mock:\n     instance = mock()\n     mock.assert_called_once_with()\n     \n     self.assertTrue(is_instance(instance, MagicMock))\n     \n     self.assertRaises(AttributeError, getattr, instance,\n     'foobarbaz')\n     \n     result = instance()\n     \n     instance.assert_called_once_with()\n     \n     result(3, 2, 1)\n     result.assert_called_once_with(3, 2, 1)\n     result.foo(3, 2, 1)\n     result.foo.assert_called_once_with(3, 2, 1)\n     \n     \n def test_create_autopsec(self):\n  mock = create_autospec(X)\n  instance = mock()\n  self.assertRaises(TypeError, instance)\n  \n  mock = create_autospec(X())\n  self.assertRaises(TypeError, mock)\n  \n  \n def test_create_autospec_instance(self):\n  mock = create_autospec(SomeClass, instance=True)\n  \n  self.assertRaises(TypeError, mock)\n  mock.wibble()\n  mock.wibble.assert_called_once_with()\n  \n  self.assertRaises(TypeError, mock.wibble, 'some', 'args')\n"], "unittest.test.test_assertions": ["import datetime\nimport warnings\nimport unittest\nfrom itertools import product\n\n\nclass Test_Assertions(unittest.TestCase):\n def test_AlmostEqual(self):\n  self.assertAlmostEqual(1.00000001, 1.0)\n  self.assertNotAlmostEqual(1.0000001, 1.0)\n  self.assertRaises(self.failureException,\n  self.assertAlmostEqual, 1.0000001, 1.0)\n  self.assertRaises(self.failureException,\n  self.assertNotAlmostEqual, 1.00000001, 1.0)\n  \n  self.assertAlmostEqual(1.1, 1.0, places=0)\n  self.assertRaises(self.failureException,\n  self.assertAlmostEqual, 1.1, 1.0, places=1)\n  \n  self.assertAlmostEqual(0, .1+.1j, places=0)\n  self.assertNotAlmostEqual(0, .1+.1j, places=1)\n  self.assertRaises(self.failureException,\n  self.assertAlmostEqual, 0, .1+.1j, places=1)\n  self.assertRaises(self.failureException,\n  self.assertNotAlmostEqual, 0, .1+.1j, places=0)\n  \n  self.assertAlmostEqual(float('inf'), float('inf'))\n  self.assertRaises(self.failureException, self.assertNotAlmostEqual,\n  float('inf'), float('inf'))\n  \n def test_AmostEqualWithDelta(self):\n  self.assertAlmostEqual(1.1, 1.0, delta=0.5)\n  self.assertAlmostEqual(1.0, 1.1, delta=0.5)\n  self.assertNotAlmostEqual(1.1, 1.0, delta=0.05)\n  self.assertNotAlmostEqual(1.0, 1.1, delta=0.05)\n  \n  self.assertRaises(self.failureException, self.assertAlmostEqual,\n  1.1, 1.0, delta=0.05)\n  self.assertRaises(self.failureException, self.assertNotAlmostEqual,\n  1.1, 1.0, delta=0.5)\n  \n  self.assertRaises(TypeError, self.assertAlmostEqual,\n  1.1, 1.0, places=2, delta=2)\n  self.assertRaises(TypeError, self.assertNotAlmostEqual,\n  1.1, 1.0, places=2, delta=2)\n  \n  first = datetime.datetime.now()\n  second = first + datetime.timedelta(seconds=10)\n  self.assertAlmostEqual(first, second,\n  delta=datetime.timedelta(seconds=20))\n  self.assertNotAlmostEqual(first, second,\n  delta=datetime.timedelta(seconds=5))\n  \n def test_assertRaises(self):\n  def _raise(e):\n   raise e\n  self.assertRaises(KeyError, _raise, KeyError)\n  self.assertRaises(KeyError, _raise, KeyError(\"key\"))\n  try:\n   self.assertRaises(KeyError, lambda: None)\n  except self.failureException as e:\n   self.assertIn(\"KeyError not raised\", str(e))\n  else:\n   self.fail(\"assertRaises() didn't fail\")\n  try:\n   self.assertRaises(KeyError, _raise, ValueError)\n  except ValueError:\n   pass\n  else:\n   self.fail(\"assertRaises() didn't let exception pass through\")\n  with self.assertRaises(KeyError) as cm:\n   try:\n    raise KeyError\n   except Exception as e:\n    exc = e\n    raise\n  self.assertIs(cm.exception, exc)\n  \n  with self.assertRaises(KeyError):\n   raise KeyError(\"key\")\n  try:\n   with self.assertRaises(KeyError):\n    pass\n  except self.failureException as e:\n   self.assertIn(\"KeyError not raised\", str(e))\n  else:\n   self.fail(\"assertRaises() didn't fail\")\n  try:\n   with self.assertRaises(KeyError):\n    raise ValueError\n  except ValueError:\n   pass\n  else:\n   self.fail(\"assertRaises() didn't let exception pass through\")\n   \n def testAssertNotRegex(self):\n  self.assertNotRegex('Ala ma kota', r'r+')\n  try:\n   self.assertNotRegex('Ala ma kota', r'k.t', 'Message')\n  except self.failureException as e:\n   self.assertIn(\"'kot'\", e.args[0])\n   self.assertIn('Message', e.args[0])\n  else:\n   self.fail('assertNotRegex should have failed.')\n   \n   \nclass TestLongMessage(unittest.TestCase):\n \"\"\n \n def setUp(self):\n  class TestableTestFalse(unittest.TestCase):\n   longMessage = False\n   failureException = self.failureException\n   \n   def testTest(self):\n    pass\n    \n  class TestableTestTrue(unittest.TestCase):\n   longMessage = True\n   failureException = self.failureException\n   \n   def testTest(self):\n    pass\n    \n  self.testableTrue = TestableTestTrue('testTest')\n  self.testableFalse = TestableTestFalse('testTest')\n  \n def testDefault(self):\n  self.assertTrue(unittest.TestCase.longMessage)\n  \n def test_formatMsg(self):\n  self.assertEqual(self.testableFalse._formatMessage(None, \"foo\"), \"foo\")\n  self.assertEqual(self.testableFalse._formatMessage(\"foo\", \"bar\"), \"foo\")\n  \n  self.assertEqual(self.testableTrue._formatMessage(None, \"foo\"), \"foo\")\n  self.assertEqual(self.testableTrue._formatMessage(\"foo\", \"bar\"), \"bar : foo\")\n  \n  \n  self.testableTrue._formatMessage(object(), 'foo')\n  \n def test_formatMessage_unicode_error(self):\n  one = ''.join(chr(i) for i in range(255))\n  \n  self.testableTrue._formatMessage(one, '\\uFFFD')\n  \n def assertMessages(self, methodName, args, errors):\n  \"\"\n  def getMethod(i):\n   useTestableFalse = i < 2\n   if useTestableFalse:\n    test = self.testableFalse\n   else:\n    test = self.testableTrue\n   return getattr(test, methodName)\n   \n  for i, expected_regex in enumerate(errors):\n   testMethod = getMethod(i)\n   kwargs = {}\n   withMsg = i % 2\n   if withMsg:\n    kwargs = {\"msg\": \"oops\"}\n    \n   with self.assertRaisesRegex(self.failureException,\n   expected_regex=expected_regex):\n    testMethod(*args, **kwargs)\n    \n def testAssertTrue(self):\n  self.assertMessages('assertTrue', (False,),\n  [\"^False is not true$\", \"^oops$\", \"^False is not true$\",\n  \"^False is not true : oops$\"])\n  \n def testAssertFalse(self):\n  self.assertMessages('assertFalse', (True,),\n  [\"^True is not false$\", \"^oops$\", \"^True is not false$\",\n  \"^True is not false : oops$\"])\n  \n def testNotEqual(self):\n  self.assertMessages('assertNotEqual', (1, 1),\n  [\"^1 == 1$\", \"^oops$\", \"^1 == 1$\",\n  \"^1 == 1 : oops$\"])\n  \n def testAlmostEqual(self):\n  self.assertMessages('assertAlmostEqual', (1, 2),\n  [\"^1 != 2 within 7 places$\", \"^oops$\",\n  \"^1 != 2 within 7 places$\", \"^1 != 2 within 7 places : oops$\"])\n  \n def testNotAlmostEqual(self):\n  self.assertMessages('assertNotAlmostEqual', (1, 1),\n  [\"^1 == 1 within 7 places$\", \"^oops$\",\n  \"^1 == 1 within 7 places$\", \"^1 == 1 within 7 places : oops$\"])\n  \n def test_baseAssertEqual(self):\n  self.assertMessages('_baseAssertEqual', (1, 2),\n  [\"^1 != 2$\", \"^oops$\", \"^1 != 2$\", \"^1 != 2 : oops$\"])\n  \n def testAssertSequenceEqual(self):\n \n \n  self.assertMessages('assertSequenceEqual', ([], [None]),\n  [\"\\+ \\[None\\]$\", \"^oops$\", r\"\\+ \\[None\\]$\",\n  r\"\\+ \\[None\\] : oops$\"])\n  \n def testAssertSetEqual(self):\n  self.assertMessages('assertSetEqual', (set(), set([None])),\n  [\"None$\", \"^oops$\", \"None$\",\n  \"None : oops$\"])\n  \n def testAssertIn(self):\n  self.assertMessages('assertIn', (None, []),\n  ['^None not found in \\[\\]$', \"^oops$\",\n  '^None not found in \\[\\]$',\n  '^None not found in \\[\\] : oops$'])\n  \n def testAssertNotIn(self):\n  self.assertMessages('assertNotIn', (None, [None]),\n  ['^None unexpectedly found in \\[None\\]$', \"^oops$\",\n  '^None unexpectedly found in \\[None\\]$',\n  '^None unexpectedly found in \\[None\\] : oops$'])\n  \n def testAssertDictEqual(self):\n  self.assertMessages('assertDictEqual', ({}, {'key': 'value'}),\n  [r\"\\+ \\{'key': 'value'\\}$\", \"^oops$\",\n  \"\\+ \\{'key': 'value'\\}$\",\n  \"\\+ \\{'key': 'value'\\} : oops$\"])\n  \n def testAssertDictContainsSubset(self):\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"ignore\", DeprecationWarning)\n   \n   self.assertMessages('assertDictContainsSubset', ({'key': 'value'}, {}),\n   [\"^Missing: 'key'$\", \"^oops$\",\n   \"^Missing: 'key'$\",\n   \"^Missing: 'key' : oops$\"])\n   \n def testAssertMultiLineEqual(self):\n  self.assertMessages('assertMultiLineEqual', (\"\", \"foo\"),\n  [r\"\\+ foo$\", \"^oops$\",\n  r\"\\+ foo$\",\n  r\"\\+ foo : oops$\"])\n  \n def testAssertLess(self):\n  self.assertMessages('assertLess', (2, 1),\n  [\"^2 not less than 1$\", \"^oops$\",\n  \"^2 not less than 1$\", \"^2 not less than 1 : oops$\"])\n  \n def testAssertLessEqual(self):\n  self.assertMessages('assertLessEqual', (2, 1),\n  [\"^2 not less than or equal to 1$\", \"^oops$\",\n  \"^2 not less than or equal to 1$\",\n  \"^2 not less than or equal to 1 : oops$\"])\n  \n def testAssertGreater(self):\n  self.assertMessages('assertGreater', (1, 2),\n  [\"^1 not greater than 2$\", \"^oops$\",\n  \"^1 not greater than 2$\",\n  \"^1 not greater than 2 : oops$\"])\n  \n def testAssertGreaterEqual(self):\n  self.assertMessages('assertGreaterEqual', (1, 2),\n  [\"^1 not greater than or equal to 2$\", \"^oops$\",\n  \"^1 not greater than or equal to 2$\",\n  \"^1 not greater than or equal to 2 : oops$\"])\n  \n def testAssertIsNone(self):\n  self.assertMessages('assertIsNone', ('not None',),\n  [\"^'not None' is not None$\", \"^oops$\",\n  \"^'not None' is not None$\",\n  \"^'not None' is not None : oops$\"])\n  \n def testAssertIsNotNone(self):\n  self.assertMessages('assertIsNotNone', (None,),\n  [\"^unexpectedly None$\", \"^oops$\",\n  \"^unexpectedly None$\",\n  \"^unexpectedly None : oops$\"])\n  \n def testAssertIs(self):\n  self.assertMessages('assertIs', (None, 'foo'),\n  [\"^None is not 'foo'$\", \"^oops$\",\n  \"^None is not 'foo'$\",\n  \"^None is not 'foo' : oops$\"])\n  \n def testAssertIsNot(self):\n  self.assertMessages('assertIsNot', (None, None),\n  [\"^unexpectedly identical: None$\", \"^oops$\",\n  \"^unexpectedly identical: None$\",\n  \"^unexpectedly identical: None : oops$\"])\n  \n  \n def assertMessagesCM(self, methodName, args, func, errors):\n  \"\"\n  p = product((self.testableFalse, self.testableTrue),\n  ({}, {\"msg\": \"oops\"}))\n  for (cls, kwargs), err in zip(p, errors):\n   method = getattr(cls, methodName)\n   with self.assertRaisesRegex(cls.failureException, err):\n    with method(*args, **kwargs) as cm:\n     func()\n     \n def testAssertRaises(self):\n  self.assertMessagesCM('assertRaises', (TypeError,), lambda: None,\n  ['^TypeError not raised$', '^oops$',\n  '^TypeError not raised$',\n  '^TypeError not raised : oops$'])\n  \n def testAssertRaisesRegex(self):\n \n  self.assertMessagesCM('assertRaisesRegex', (TypeError, 'unused regex'),\n  lambda: None,\n  ['^TypeError not raised$', '^oops$',\n  '^TypeError not raised$',\n  '^TypeError not raised : oops$'])\n  \n  def raise_wrong_message():\n   raise TypeError('foo')\n  self.assertMessagesCM('assertRaisesRegex', (TypeError, 'regex'),\n  raise_wrong_message,\n  ['^\"regex\" does not match \"foo\"$', '^oops$',\n  '^\"regex\" does not match \"foo\"$',\n  '^\"regex\" does not match \"foo\" : oops$'])\n  \n def testAssertWarns(self):\n  self.assertMessagesCM('assertWarns', (UserWarning,), lambda: None,\n  ['^UserWarning not triggered$', '^oops$',\n  '^UserWarning not triggered$',\n  '^UserWarning not triggered : oops$'])\n  \n def testAssertWarnsRegex(self):\n \n  self.assertMessagesCM('assertWarnsRegex', (UserWarning, 'unused regex'),\n  lambda: None,\n  ['^UserWarning not triggered$', '^oops$',\n  '^UserWarning not triggered$',\n  '^UserWarning not triggered : oops$'])\n  \n  def raise_wrong_message():\n   warnings.warn('foo')\n  self.assertMessagesCM('assertWarnsRegex', (UserWarning, 'regex'),\n  raise_wrong_message,\n  ['^\"regex\" does not match \"foo\"$', '^oops$',\n  '^\"regex\" does not match \"foo\"$',\n  '^\"regex\" does not match \"foo\" : oops$'])\n"], "unittest.test.testmock": ["import os\nimport sys\nimport unittest\n\n\nhere = os.path.dirname(__file__)\nloader = unittest.defaultTestLoader\n\ndef load_tests(*args):\n suite = unittest.TestSuite()\n for fn in os.listdir(here):\n  if fn.startswith(\"test\") and fn.endswith(\".py\"):\n   modname = \"unittest.test.testmock.\" + fn[:-3]\n   __import__(modname)\n   module = sys.modules[modname]\n   suite.addTest(loader.loadTestsFromModule(module))\n return suite\n", 1], "unittest.test.testmock.support": ["import sys\n\ndef is_instance(obj, klass):\n \"\"\n return issubclass(type(obj), klass)\n \n \nclass SomeClass(object):\n class_attribute = None\n \n def wibble(self):\n  pass\n  \n  \nclass X(object):\n pass\n \n \ndef examine_warnings(func):\n def wrapper():\n  with catch_warnings(record=True) as ws:\n   func(ws)\n return wrapper\n"]};


  __BRYTHON__.import_from_unittest function(mod_name){
  var stored = __BRYTHON__.libs['unittest'][mod_name]
  if(stored!==undefined){
    var module_contents = stored[0]
    var is_package = stored[1]
    var path = 'py_unittest'
    var module = {name:mod_name,__class__:$B.$ModuleDict,is_package:is_package}
    if(is_package){var package=mod_name}
    else{
      var elts = mod_name.split('.')
      elts.pop()
      var package = elts.join('.')
    }
    $B.modules[mod_name].$package = is_package
    $B.modules[mod_name].__package__ = package

    run_py(module,path,module_contents)
    return true
  }
  return null
}
// add this import function to brython by doing the following:
// <body onload="brython({custom_import_funcs:[__BRYTHON__.import_from_unittest]})">
// this will allow us to import unittest modules.
