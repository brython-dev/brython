"""Scan CPython files in /Objects to get the information on type
getset, methods and members"""

import os
import re
import shlex
import pprint

from directories import src_dir
from get_cpython_objects_defines import defines
import get_type_slots

fields = """tp_name
tp_basicsize
tp_itemsize
tp_dealloc
tp_vectorcall_offset
tp_getattr
tp_setattr
tp_as_async
tp_repr
tp_as_number
tp_as_sequence
tp_as_mapping
tp_hash
tp_call
tp_str
tp_getattro
tp_setattro
tp_as_buffer
tp_flags
tp_doc
tp_traverse
tp_clear
tp_richcompare
tp_weaklistoffset
tp_iter
tp_iternext
tp_methods
tp_members
tp_getset
tp_base
tp_dict
tp_descr_get
tp_descr_set
tp_dictoffset
tp_init
tp_alloc
tp_new
tp_free
tp_is_gc
tp_bases
tp_mro
tp_cache
tp_subclasses
tp_weaklist
tp_del
tp_version_tag
tp_finalize
tp_vectorcall
tp_watched
tp_versions_used""".split()

init_type = """
$B.builtin_types = {}

function init_type(ns, name, data){
    var cls = ns[name] = Object.create(null)
    Object.assign(cls, data)
    $B.builtin_types[name] = cls
}

"""

set_additional_data = """

for(var name in $B.builtin_types){
    var cls = $B.builtin_types[name]
    cls.ob_type = _b_.type
    cls.dict = Object.create(null)
    cls.tp_mro = $B.make_mro(cls)
}

"""
init_path = os.path.join(src_dir, 'init_builtin_types.js')

with open(init_path, 'w', encoding='utf-8') as out:
    out.write(f'/* generated by {__file__} */\n')
    out.write('(function($B){\n')
    out.write('var _b_ = $B.builtins\n')
    out.write(init_type)
    out.write(get_type_slots.make_builtins_init(__builtins__))
    out.write(set_additional_data)
    out.write('})(__BRYTHON__)\n')

props = {
    'tp_getset': 'PyGetSetDef',
    'tp_methods': 'PyMethodDef',
    'tp_members': 'PyMemberDef'
}

#format1 = r'(?P<name>.*),\s*/\*\s*tp_getset\s*\*/'
#format2 = r'\.tp_getset\s*=\s*(?P<name>.*),\s*'

defline_re = r'^(.*)\s*=\s*{'

def scan(lines, prop):
    format1 = rf'(?P<name>.*),\s*/\*\s*{prop}\s*\*/'
    format2 = rf'\.{prop}\s*=\s*(?P<name>.*),\s*'
    infos = {}
    for i, line in enumerate(lines):
        if mo := re.search(format1, line) or re.search(format2, line):
            name = mo.group('name').strip()
            if name == '0':
                continue
            type_name = get_pytype_name(lines, i)
            defs, functions = get_list(prop, lines, name)
            defs = ',\n'.join(defs)
            funcs = ''
            for gs, name in functions:
                if gs == 'get':
                    funcs += 'function ' + name + '(){\n\n}\n\n'
                else:
                    funcs += 'function ' + name + '(self, value){\n\n}\n\n'
            funclist = f'{types.get(type_name, type_name)}.{prop} = [\n'
            funclist += defs + '\n]\n'
            infos[type_name] = (funcs, funclist)
    return infos

def get_pytype_name(lines, i):
    j = i - 1
    while j > 0:
        defline = lines[j]
        if mo1 := re.match(defline_re, defline):
            info = mo1.groups()[0]
            type_name = info.split()[-1]
            return type_name
        j -= 1

def get_list(prop, lines, name):
    getset_re = rf'{name}\[\] = \{{'
    found = False
    k = 0
    while k < len(lines):
        line = lines[k]
        if not found:
            if re.search(getset_re, line):
                start = k
                found = True
        elif line.startswith('}'):
            deflines = lines[start + 1:k - 1]
            return scan_deflines(prop, deflines)
        k += 1
    print('prop', getset_re, 'not found')

definitions = []
prefix = '    '

def transform_data(data, prop):
    i = 0
    data = data.strip()
    seps = '{,}()'
    delims = []
    parts = []
    item = ''
    s = None
    while i < len(data):
        if data[i] == '"':
            if item:
                parts.append(item)
                item = ''
            j = i + 1
            esc = False
            s = None
            while j < len(data):
                if data[j] == '\\':
                    esc = True
                elif data[j] == '"' and not esc:
                    s = data[i:j+1]
                    delims.append([i, j + 1])
                    parts.append(s)
                    i = j + 1
                    break
                elif esc:
                    esc = False
                j += 1
            if s is None:
                raise SyntaxError(f'unterminated string in {data}')
        else:
            if data[i] in seps:
                if item:
                    parts.append(item.strip())
                delims.append(i)
                parts.append(data[i])
                item = ''
            else:
                item += data[i]
            i += 1
    if item:
        parts.append(item)
    parts0 = parts[:]

    if parts.pop(0) != '{':
        raise SyntaxError('first item is not }')
    while parts:
        if parts.pop() == '}':
            break
    if not parts:
        print(data)
        print(parts0)
        raise SyntaxError('terminal } not found')
    elts = []
    elt = parts.pop(0)
    while parts:
        if (x := parts.pop(0)) != ',':
            elt += x
        else:
            if elt.startswith('('):
                elt = elt[elt.find(')') + 1:]
            elif elt.startswith('_PyCFunction_CAST('):
                elt = elt[len('_PyCFunction_CAST('):-1]
            elts.append(elt)
            elt = ''
    if elt:
        elts.append(elt)
    if prop == 'tp_members':
        if len(elts) > 4:
            elts = elts[:4] # remove doc
    if prop in ['tp_methods', 'tp_getset']:
        if len(elts) > 3:
            elts = elts[:3] # remove doc
    if prop == 'tp_methods':
        if len(elts) == 3:
            elts[2] = elts[2].replace('METH_', '$B.METH_')
    return elts

def funcrefs(prop, data):
    # return the list of functions to define
    res = [('get', data[1])]
    if prop == 'tp_getset' and len(data) > 2 and data[2] != 'NULL':
        res.append(('set', data[2]))
    return res

def tokenize(s):
    i = 0
    while i < len(s) and s[i] != '{':
        i += 1
    yield s[:i]
    if i == len(s):
        raise Exception('opening { not found')
    braces = '{'
    yield s[i]
    i += 1
    while i < len(s):
        if s[i].isalnum() or s[i] == '_':
            j = i + 1
            while j < len(s) and (s[j].isalnum() or s[j] == '_'):
                j += 1
            yield s[i:j]
            i = j
        elif s[i] == '"':
            j = i + 1
            esc = False
            found = False
            while j < len(s):
                if s[j] == '\\':
                    esc = True
                elif s[j] == '"' and not esc:
                    found = True
                    yield s[i:j+1]
                    i = j + 1
                    break
                elif esc:
                    esc = False
                j += 1
            if not found:
                raise SyntaxError(f'unterminated string in {data}')
        elif s[i:i + 2] == '/*':
            j = i + 2
            while j < len(s) and s[j:j + 2] != '*/':
                j += 1
            if j == len(s):
                raise Exception('unterminated comment')
            yield s[i:j + 3]
            i = j + 2
        elif s[i] in '.,=|\n':
            yield s[i]
            i += 1
        elif s[i] == '(':
            yield s[i]
            braces += '('
            i += 1
        elif s[i] == ')':
            if not braces or braces[-1] != '(':
                raise Exception('unexpected )')
            braces = braces[:-1]
            yield s[i]
            i += 1
        elif s[i] == '{':
            yield s[i]
            braces += '{'
            i += 1
        elif s[i] == '}':
            if not braces or braces[-1] != '{':
                print(s)
                raise Exception('unexpected }')
            yield s[i]
            i += 1
        else:
            i += 1

def scan_typedef(s):
    slots = {}
    it = tokenize(s)
    field_num = 0
    head = next(it)
    if not '=' in head:
        # case for memoryobject.c / _PyMemoryIter_Type
        return slots
    # ignore first line
    while True:
        token = next(it)
        if token == ')':
            break
    while (token := next(it)) != '\n':
        continue
    token = next(it)
    # read defs
    while True:
        try:
            if token == '.': # format .tp_name = "type"
                slot = next(it)
                while (token := next(it)) != '=':
                    continue
                v = next(it)
                while (token := next(it)) != ',':
                    v += token
                slots[slot] = v
            else: # format "value,  /* tp_name */"
                v = token
                braces = ''
                while True:
                    token = next(it)
                    if token == ',' and not braces:
                        break
                    elif token == '(':
                        braces += '('
                    elif token == ')':
                        braces = braces[:-1]
                    v += token
                slots[fields[field_num]] = v
            field_num += 1
            while True:
                token = next(it)
                if not token.startswith('/*') and token != '\n':
                    break
        except StopIteration:
            return slots

def scan_deflines(prop, lines):
    # deflines are either an idenfier on a single line,
    # or start with '{' and end with '},'
    defs = []
    functions = []
    i = 0
    while i < len(lines):
        line = lines[i]
        if line.strip().startswith('{'):
            j = i
            while j < len(lines) and '}' not in lines[j]:
                j += 1
            data = ''.join(x.strip() for x in lines[i:j+1])
            data = transform_data(data, prop)
            functions += funcrefs(prop, data)
            defs.append(prefix + '[' + ', '.join(data) + ']')
            i = j + 1
        elif line.strip().startswith('/*'):
            j = i
            while j < len(lines) and '*/' not in lines[j]:
                j += 1
            i = j + 1
        else:
            definition = line.strip()
            if definition in defines:
                data = defines[definition]
                data = transform_data(data, prop)
                functions += funcrefs(prop, data)
                defs.append(prefix + '[' + ', '.join(data) + ']')
            else:
                defs.append(prefix + definition.strip() + ',')
            definitions.append(definition)
            i += 1
    return defs, functions

obj_dir = os.path.join('/cpython', 'Objects')

types_re = r'^PyTypeObject\s+(?P<type_name>[a-zA-z_]+)' #\s*=\s*{{'
include_re = r'#include "(?P<include_name>.*)"'
str_re = re.compile('"(?P<value>.*?)"')

types = {}

with open(os.path.join(src_dir, 'type_info.js'), 'w', encoding='utf-8') as out:
    for filename in os.listdir(obj_dir):
        if filename.endswith('.c'):
            out.write(f'// {filename}\n')
            definitions = []
            found = []
            types = {}
            with open(os.path.join(obj_dir, filename), encoding='utf-8') as f:
                lines = f.readlines()
                content = ''.join(lines)
                types_iter = re.finditer(types_re, content, flags=re.M)
                for mo in types_iter:
                    _type = mo.group('type_name')
                    linenum = content[:mo.end()].count('\n')
                    start = i = 1
                    tp_name = None
                    while i < len(lines) - linenum:
                        line = lines[linenum + i]
                        if 'tp_name' in line:
                            mo = str_re.search(line)
                            tp_name = mo.group('value')
                        elif i == 2 and (mo := str_re.search(line)):
                            tp_name = mo.group('value')
                        elif line.strip().startswith('}'):
                            if tp_name is None:
                                print('tp name not found', filename, _type)
                            break
                        i += 1
                    types[_type] = tp_name
                    print(tp_name)
                    s = ''.join(lines[linenum:linenum + i + 1])
                    slots = scan_typedef(s)
                    print(slots)
                infos = {}
                for prop in props:
                    info = scan(lines, prop)
                    for _type in info:
                        if _type not in types:
                            continue
                        tp_name = types[_type]
                        if tp_name not in infos:
                            infos[tp_name] = {}
                        infos[tp_name][prop] = info[_type]
                for tp_name in infos:
                    out.write('\n')
                    for prop in infos[tp_name]:
                        funcs, funclist = infos[tp_name][prop]
                        out.write(funcs)
                        out.write(f'/* {tp_name}.{prop} start */\n')
                        out.write(funclist)
                        out.write(f'/* {tp_name}.{prop} end */\n')
                    out.write('\n')
                for definition in definitions:
                    if not definition in defines:
                        print('def not found', definition)


    for filename in os.listdir(obj_dir):
        if filename.endswith('.c.h'):
            out.write(f'// {filename}\n')
            with open(os.path.join(obj_dir, filename), encoding='utf-8') as f:
                lines = f.readlines()
                content = ''.join(lines)
                types = re.findall(types_re, content, flags=re.M)
                if types:
                    out.write(f'//  types = {types}\n')
                for prop in props:
                    info = scan(lines, prop)
                    if info is not None:
                        out.write(info)
                        out.write('\n')

